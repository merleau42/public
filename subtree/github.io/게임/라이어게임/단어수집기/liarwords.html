<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ë‹¨ì–´ìˆ˜ì§‘ê¸°</title>
  <link rel="stylesheet" href="liarwords.css">
</head>
<body>

<!-- ì…ë ¥ì°½ -->
<div id="div1" class="flex-container"></div>

<!-- ë‹¨ì¼ ì…ë ¥ + ë²„íŠ¼ -->
<div id="div2" class="flex-container">
  <textarea id="singleInput" maxlength="50" tabindex="9"></textarea>
  <!-- â–¶ ë²„íŠ¼: ì´ˆê¸° í…ìŠ¤íŠ¸ 'ë¡œê·¸ì¸' -->
  <button id="add-button">ë¡œê·¸ì¸</button>
  <button onclick="clearInputs()">ë¹„ìš°ê¸°</button>
  <button onclick="showHintModal()">íŒíŠ¸</button>
</div>

<!-- ì¶œë ¥ -->
<div id="div3"><div id="output"></div></div>

<!-- ì´ëª¨ì§€ ì„ íƒ ëª¨ë‹¬ -->
<div class="modal-backdrop" id="modal-backdrop"></div>
<div class="modal" id="emoji-modal">
  <div style="text-align: center; font-weight: bold;">ë°›ì€ íˆ¬í‘œ</div>
  <div id="emoji-buttons"></div>
  <hr>
  
  <!-- í˜ì´ì¦ˆ ë²„íŠ¼ ì˜ì—­ -->
  <div id="phase-buttons" class="phase-buttons-container"></div>
  <div class="modal-footer">
    <button id="clear-current-button">ë¹„ìš°ê¸°</button>
    <button id="reset-all-button">ì´ˆê¸°í™”</button>
    <button id="confirm-button">í™•ì¸</button>
    <button id="cancel-button">ì·¨ì†Œ</button>
  </div>
</div>

<!-- íŒíŠ¸ ëª¨ë‹¬ -->
<div class="modal-backdrop" id="hint-backdrop" style="display:none;"></div>
<div class="modal" id="hint-modal" style="display:none;">
  <div id="hint-content"></div>
  <div class="modal-footer">
    <button onclick="closeHintModal()">ë‹«ê¸°</button>
  </div>
</div>


<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
import { getDatabase, ref, get, set, update } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";
import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";

// Firebase ì´ˆê¸°í™”
const app = initializeApp({
  apiKey: "AIzaSyDVVAx9XRziu8IZ9CLczaG20QEOwyY4uLs",
  authDomain: "liarwords-af033.firebaseapp.com",
  databaseURL: "https://liarwords-af033-default-rtdb.firebaseio.com",
  projectId: "liarwords-af033",
  storageBucket: "liarwords-af033.appspot.com",
  messagingSenderId: "171671976030",
  appId: "1:171671976030:web:59371970ec6b2a70035ccf"
});
const db = getDatabase(app);

// â–¶ Auth
const auth = getAuth(app);
const provider = new GoogleAuthProvider();

// --- ìƒíƒœ ë³€ìˆ˜ (State Variables) ---
let groupList = [];
let visibleCount = 8;
let currentEmojiTarget = null;
let tempEmojiSelection = [];
const emojiList = ['1','2','3','4','5','6','7','8'];

// í˜ì´ì¦ˆ ì‹œìŠ¤í…œ ìƒíƒœ ë³€ìˆ˜
let phaseEmojiMaps = {
  phase1: {},
  phase2: {},
  phase3: {},
  phase4: {}
};
let currentActivePhase = 'phase1';
const phaseConfig = {
  'phase1': { name: 'í˜ì´ì¦ˆ1', colorClass: 'phase-1', emojiColorClass: 'phase-1-color' },
  'phase2': { name: 'í˜ì´ì¦ˆ2', colorClass: 'phase-2', emojiColorClass: 'phase-2-color' },
  'phase3': { name: 'í˜ì´ì¦ˆ3', colorClass: 'phase-3', emojiColorClass: 'phase-3-color' },
  'phase4': { name: 'í˜ì´ì¦ˆ4', colorClass: 'phase-4', emojiColorClass: 'phase-4-color' }
};

// â–¶ ì¶”ê°€ ë²„íŠ¼ ì°¸ì¡°
const addButton = document.getElementById('add-button');

// --- ì´ˆê¸°í™” (Initialization) ---
document.addEventListener('DOMContentLoaded', () => {
  generateInputs();
  restoreState(); // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ëª¨ë“  ìƒíƒœ ë³µì›
  attachInputListeners();
  attachFocusListeners();
  setupEmojiButtons();
  setupPhaseButtons();
  loadFromDB();

  // ëª¨ë‹¬ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  document.getElementById('clear-current-button').addEventListener('click', handleClearCurrentVote);
  document.getElementById('reset-all-button').addEventListener('click', handleResetAllVotes);
  document.getElementById('confirm-button').addEventListener('click', confirmEmojiSelection);
  document.getElementById('cancel-button').addEventListener('click', cancelEmojiSelection);
  document.getElementById('modal-backdrop').addEventListener('click', cancelEmojiSelection);
});

// â–¶ ë¡œê·¸ì¸ ìƒíƒœì— ë”°ë¼ 'ë¡œê·¸ì¸'â†”'ì¶”ê°€' í…ìŠ¤íŠ¸/ë™ì‘ ì „í™˜
onAuthStateChanged(auth, (user) => {
  if (user) {
    // ë¡œê·¸ì¸ ìƒíƒœ: ë²„íŠ¼ì€ 'ì¶”ê°€' ë™ì‘
    addButton.textContent = 'ì¶”ê°€';
    addButton.onclick = addSingle;
  } else {
    // ë¹„ë¡œê·¸ì¸ ìƒíƒœ: ë²„íŠ¼ì€ ë¡œê·¸ì¸ ìœ ë„
    addButton.textContent = 'ë¡œê·¸ì¸';
    addButton.onclick = async () => {
      try {
        await signInWithPopup(auth, provider);
        // Rulesê°€ ì“°ê¸° ê¶Œí•œì„ í†µì œí•˜ë¯€ë¡œ, ì—¬ê¸°ì„  UI ì „í™˜ë§Œ ì²˜ë¦¬
      } catch (e) {
        alert('ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + (e?.message || e));
        console.error(e);
      }
    };
  }
});

// --- ì…ë ¥ì°½ ë° ë²„íŠ¼ ìƒì„± (Input & Button Generation) ---
function generateInputs() {
  const div1 = document.getElementById('div1');
  div1.innerHTML = ''; // ê¸°ì¡´ ì…ë ¥ì°½ ì œê±°

  // 1~8ë²ˆ ì…ë ¥ì°½ ìƒì„±
  for (let i = 1; i <= 8; i++) {
    const wrapper = document.createElement('div');
    wrapper.className = 'textarea-wrapper';
    wrapper.id = `wrapper-input${i}`;

    const textarea = document.createElement('textarea');
    textarea.id = `input${i}`;
    textarea.tabIndex = i;

    const emojiOverlay = document.createElement('div');
    emojiOverlay.className = 'emoji-overlay';
    emojiOverlay.id = `emoji-overlay-input${i}`;

    const emojiButton = document.createElement('button');
    emojiButton.className = 'emoji-button';
    emojiButton.innerText = 'ğŸ¹';
    emojiButton.onclick = () => openEmojiModal(`input${i}`);

    wrapper.appendChild(textarea);
    wrapper.appendChild(emojiOverlay);
    wrapper.appendChild(emojiButton);

    div1.appendChild(wrapper);
  }

  // + - ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
  const iconContainer = document.createElement('div');
  iconContainer.id = 'icon-container';
  
  const addBtn = document.createElement('span');
  addBtn.id = 'addBtn';
  addBtn.className = 'icon-btn';
  addBtn.innerText = 'â•';
  addBtn.onclick = addInput;

  const removeBtn = document.createElement('span');
  removeBtn.id = 'removeBtn';
  removeBtn.className = 'icon-btn';
  removeBtn.innerText = 'â–';
  removeBtn.onclick = removeInput;

  iconContainer.appendChild(removeBtn);
  iconContainer.appendChild(addBtn);
  div1.appendChild(iconContainer);
  
  updateInputVisibility(); // ì´ˆê¸° ê°€ì‹œì„± ì„¤ì •
  attachFocusListeners();
}

// â•â– ë²„íŠ¼ ë¡œì§
function addInput() {
  if (visibleCount < 8) {
    visibleCount++;
    saveState(); 
    updateInputVisibility();
    attachFocusListeners(); 
  }
}
function removeInput() {
  if (visibleCount > 3) {
    const inputToRemoveId = `input${visibleCount}`;
    Object.keys(phaseEmojiMaps).forEach(phaseId => {
      if (phaseEmojiMaps[phaseId][inputToRemoveId]) {
        delete phaseEmojiMaps[phaseId][inputToRemoveId];
      }
    });
    visibleCount--;
    saveState(); 
    updateInputVisibility();
    updateDiv1Visuals();
    attachFocusListeners(); 
  }
}
function updateInputVisibility() {
  for (let i = 1; i <= 8; i++) {
    const wrapper = document.getElementById(`wrapper-input${i}`);
    if (wrapper) {
      wrapper.style.display = i <= visibleCount ? 'inline-block' : 'none';
    }
  }
  [...document.querySelectorAll('.textarea-wrapper')]
    .filter(wr => wr.style.display!='none')
    .at(-1).appendChild(document.querySelector('#icon-container'))

  document.getElementById('addBtn').style.display = visibleCount === 8 ? 'none' : 'inline-block';
  document.getElementById('removeBtn').style.display = visibleCount === 3 ? 'none' : 'inline-block';
}

// --- ì´ëª¨ì§€ ë° í˜ì´ì¦ˆ ëª¨ë‹¬ ---
function setupEmojiButtons() {
  const container = document.getElementById('emoji-buttons');
  container.innerHTML = '';
  emojiList.forEach(emoji => {
    const btn = document.createElement('button');
    btn.innerText = emoji;
    btn.onclick = () => toggleTempEmoji(emoji);
    container.appendChild(btn);
  });
}
function setupPhaseButtons() {
  const container = document.getElementById('phase-buttons');
  container.innerHTML = '';
  Object.keys(phaseConfig).forEach(phaseId => {
    const config = phaseConfig[phaseId];
    const btn = document.createElement('div');
    btn.className = `phase-button ${config.colorClass}`;
    btn.dataset.phaseId = phaseId;
    btn.innerText = config.name;
    btn.onclick = () => switchPhase(phaseId);
    container.appendChild(btn);
  });
  updatePhaseButtonStates();
}
function openEmojiModal(targetId) {
  currentEmojiTarget = targetId;
  const currentPhaseVotes = phaseEmojiMaps[currentActivePhase];
  tempEmojiSelection = [...(currentPhaseVotes[currentEmojiTarget] || [])];
  updateModalButtonStates();
  document.getElementById('emoji-modal').style.display = 'block';
  document.getElementById('modal-backdrop').style.display = 'block';
}
function switchPhase(phaseId) {
  currentActivePhase = phaseId;
  updatePhaseButtonStates();
  updateDiv1Visuals();
  if (document.getElementById('emoji-modal').style.display === 'block') {
    const currentPhaseVotes = phaseEmojiMaps[currentActivePhase];
    tempEmojiSelection = [...(currentPhaseVotes[currentEmojiTarget] || [])];
    updateModalButtonStates();
  }
  saveState(); 
}
function toggleTempEmoji(emoji) {
  const index = tempEmojiSelection.indexOf(emoji);
  if (index > -1) tempEmojiSelection.splice(index, 1);
  else tempEmojiSelection.push(emoji);
  updateModalButtonStates();
}
function updateModalButtonStates() {
  const buttons = document.querySelectorAll('#emoji-buttons button');
  const activePhaseColorClass = phaseConfig[currentActivePhase].emojiColorClass;

  buttons.forEach(btn => {
    Object.values(phaseConfig).forEach(config => {
      btn.classList.remove(config.emojiColorClass);
    });
    if (tempEmojiSelection.includes(btn.innerText)) {
      btn.classList.add('active');
      btn.classList.add(activePhaseColorClass);
    } else {
      btn.classList.remove('active');
    }
  });
}
function updatePhaseButtonStates() {
  const buttons = document.querySelectorAll('.phase-button');
  buttons.forEach(btn => {
    if (btn.dataset.phaseId === currentActivePhase) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}
function confirmEmojiSelection() {
  if (currentEmojiTarget) {
    phaseEmojiMaps[currentActivePhase][currentEmojiTarget] = [...tempEmojiSelection];
    updateDiv1Visuals();
    saveState(); 
  }
  closeEmojiModal();
}
function cancelEmojiSelection() { closeEmojiModal(); }
function closeEmojiModal() {
  document.getElementById('emoji-modal').style.display = 'none';
  document.getElementById('modal-backdrop').style.display = 'none';
  currentEmojiTarget = null;
}
function handleClearCurrentVote() {
  if (currentEmojiTarget) {
    phaseEmojiMaps[currentActivePhase][currentEmojiTarget] = [];
    updateDiv1Visuals();
    saveState();
    tempEmojiSelection = [];
    updateModalButtonStates();
  }
}
function handleResetAllVotes() {
  phaseEmojiMaps = { phase1: {}, phase2: {}, phase3: {}, phase4: {} }; 
  currentActivePhase = 'phase1';
  updateDiv1Visuals();
  updatePhaseButtonStates();
  saveState();
  if (document.getElementById('emoji-modal').style.display === 'block') {
    tempEmojiSelection = [];
    updateModalButtonStates();
  }
}

async function showHintModal() {
  const query = document.getElementById("singleInput").value.trim();
  if (!query) { alert("ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }
  const keywords = query.split(',').map(w => w.trim()).filter(Boolean);
  if (!keywords.length) return;

  const snapshot = await get(ref(db, "liar_groups"));
  if (!snapshot.exists()) { alert("DBì— ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤."); return; }

  const data = snapshot.val();
  const matchingGroups = Object.values(data).filter(group =>
    group.words.some(word => keywords.includes(word))
  );

  const hintContent = document.getElementById("hint-content");
  hintContent.innerHTML = '';

  if (matchingGroups.length === 0) {
    hintContent.innerText = 'âŒ ê´€ë ¨ëœ ë‹¨ì–´ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤.';
  } else {
    matchingGroups.forEach(group => {
      const wordsLine = `ğŸ§© ${group.words.join(', ')}`;
      const summaryLines = (group.statements || []).map(stmt =>
        `${stmt.subject ? stmt.subject + ': ' : ''}` +
        `${stmt.opening ? stmt.opening + ' ã…¡ ' : ''}` +
        `${stmt.elaborate1 ? stmt.elaborate1 + ' ' : ''}` +
        `${stmt.elaborate2 ? ' >> ' + stmt.elaborate2 + ' ' : ''}`
      );
      hintContent.innerText += `${wordsLine}\n\n${summaryLines.join('\n')}\n\n`;
    });
  }
  document.getElementById("hint-modal").style.display = 'block';
  document.getElementById("hint-backdrop").style.display = 'block';
}
function closeHintModal() {
  document.getElementById("hint-modal").style.display = 'none';
  document.getElementById("hint-backdrop").style.display = 'none';
}

// --- UI ì—…ë°ì´íŠ¸ ---
function updateDiv1Visuals() {
  for (let i = 1; i <= 8; i++) {
    const inputId = `input${i}`;
    const overlay = document.getElementById(`emoji-overlay-${inputId}`);
    if (!overlay) continue;
    overlay.innerHTML = '';
    Object.keys(phaseConfig).forEach(phaseId => {
      const votesInPhase = phaseEmojiMaps[phaseId];
      if (votesInPhase[inputId] && votesInPhase[inputId].length > 0) {
        votesInPhase[inputId].forEach(voter => {
          const indicator = document.createElement('div');
          indicator.className = `vote-indicator ${phaseConfig[phaseId].colorClass}`;
          indicator.textContent = voter;
          overlay.appendChild(indicator);
        });
      }
    });
  }
}

// --- ë°ì´í„° ì²˜ë¦¬ ---
function parseStatement(text) {
  const stmt = {};
  if (!text) return stmt;
  let remaining = text.trim();

  let parts = remaining.split('!!');
  if (parts.length > 1) {
    const author = parts.pop().trim();
    if (author) stmt.author = author;
    remaining = parts.join('!!').trim();
  }
  parts = remaining.split('//');
  if (parts.length > 1) {
    const respond = parts.pop().trim();
    if (respond) stmt.respond = respond;
    remaining = parts.join('//').trim();
  }
  parts = remaining.split('>>');
  if (parts.length > 1) {
    const elaborate2 = parts.pop().trim();
    if (elaborate2) stmt.elaborate2 = elaborate2;
    remaining = parts.join('>>').trim();
  }
  parts = remaining.split('ã…¡');
  if (parts.length > 1) {
    const elaborate1 = parts.pop().trim();
    if (elaborate1) stmt.elaborate1 = elaborate1;
    remaining = parts.join('ã…¡').trim();
  }
  parts = remaining.split(':');
  if (parts.length > 1) {
    const subject = parts.shift().trim();
    if (subject) stmt.subject = subject;
    const opening = parts.join(':').trim();
    if (opening) stmt.opening = opening;
  } else {
    const opening = remaining.trim();
    if (opening) stmt.opening = opening;
  }
  return stmt;
}
function getStmtSignature(stmt) {
  if (!stmt) return '';
  const parts = [stmt.subject, stmt.opening, stmt.elaborate1, stmt.elaborate2];
  return parts.join('').replace(/\s+/g, '');
}

// â–¶ ì¶”ê°€(ì“°ê¸°) ë¡œì§: ë¡œê·¸ì¸ í•„ìš”. ë¡œê·¸ì¸ì€ onAuthStateChangedì— ë”°ë¼ ë²„íŠ¼ì´ ì²˜ë¦¬.
async function addSingle () {
  if (!auth.currentUser) {
    // ì¼ë°˜ì ìœ¼ë¡œ ì—¬ê¸°ê¹Œì§€ ì˜¤ì§€ ì•Šì§€ë§Œ, ìƒíƒœ ê²½í•© ëŒ€ë¹„
    try {
      await signInWithPopup(auth, provider);
    } catch (e) {
      alert('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤: ' + (e?.message || e));
      return;
    }
  }

  const singleVal = document.getElementById("singleInput").value.trim();
  const words = singleVal.split(',').map(w => w.trim().replace(/\s+/g, '')).filter(Boolean);
  if (!words.length) { alert("ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }

  const newStatements = [];
  for (let i = 1; i <= visibleCount; i++) {
    const input = document.getElementById(`input${i}`);
    const rawText = input.value.trim();
    if (input && rawText) {
      const items = rawText.split(',').map(v => v.trim()).filter(Boolean);
      const parsedItems = items.map(parseStatement);
      newStatements.push(...parsedItems);
    }
  }

  const snapshot = await get(ref(db, "liar_groups"));
  const groupsData = snapshot.exists() ? snapshot.val() : {};

  const wordToGroup = {};
  const groupMap = {};

  Object.entries(groupsData).forEach(([groupId, group]) => {
    groupMap[groupId] = group;
    (group.words || []).forEach(word => {
      wordToGroup[word] = groupId;
    });
  });

  const matchedGroupIds = [...new Set(
    words.map(word => wordToGroup[word]).filter(Boolean)
  )];

  if (matchedGroupIds.length === 0) {
    const allIds = new Set(Object.keys(groupsData));
    let newGroupId = null;
    for (let i = 0; i <= 9999; i++) {
      const candidate = i.toString().padStart(4, '0');
      if (!allIds.has(candidate)) { newGroupId = candidate; break; }
    }
    if (!newGroupId) { alert("ë” ì´ìƒ ìƒì„± ê°€ëŠ¥í•œ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤."); return; }

    const latestTimestamp = Date.now();
    const newGroupData = {
      words: [...new Set(words)],
      statements: newStatements,
      timestamp: latestTimestamp
    };

    await set(ref(db, `liar_groups/${newGroupId}`), newGroupData);
    loadFromDB();
    return;
  }

  let mergedWords = [];
  let mergedStatements = [];
  matchedGroupIds.forEach(groupId => {
    const group = groupMap[groupId];
    mergedWords.push(...(group.words || []));
    mergedStatements.push(...(group.statements || []));
  });

  mergedWords.push(...words);
  mergedWords = [...new Set(mergedWords)];

  const existingSignatures = new Set(mergedStatements.map(getStmtSignature));
  const uniqueNewStatements = newStatements.filter(stmt => {
    const signature = getStmtSignature(stmt);
    return signature && !existingSignatures.has(signature);
  });
  mergedStatements.push(...uniqueNewStatements);

  const latestTimestamp = Date.now();
  const primaryGroupId = matchedGroupIds[0];

  const updates = {};
  updates[`liar_groups/${primaryGroupId}`] = {
    words: mergedWords,
    statements: mergedStatements,
    timestamp: latestTimestamp
  };
  matchedGroupIds.slice(1).forEach(groupId => { updates[`liar_groups/${groupId}`] = null; });

  await update(ref(db), updates);
  loadFromDB();
};

// ë©”ì¸ í™”ë©´ 'ë¹„ìš°ê¸°'
window.clearInputs = function () {
  for (let i = 1; i <= 8; i++) {
    const input = document.getElementById(`input${i}`);
    if (input) input.value = '';
  }
  document.getElementById("singleInput").value = '';

  phaseEmojiMaps = { phase1: {}, phase2: {}, phase3: {}, phase4: {} };
  currentActivePhase = 'phase1';
  updateDiv1Visuals();
  updatePhaseButtonStates();
  updateHighlights();
  localStorage.removeItem('ìƒíƒœë°±ì—…');
};

window.loadFromDB = async function () {
  const output = document.getElementById("output");
  output.innerHTML = "ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...";
  try {
    const snapshot = await get(ref(db, "liar_groups"));
    output.innerHTML = "";
    if (snapshot.exists()) {
      const rawData = snapshot.val();
      const entries = Object.entries(rawData)
        .sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0));
      groupList = entries.map(entry => (entry[1].words || []));
      updateHighlights();
    } else {
      output.innerHTML = "ğŸ”¥ ë°ì´í„° ì—†ìŒ";
    }
  } catch(e) {
    output.innerHTML = `âŒ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${e.message}`;
  }
};

function updateHighlights() {
  const value = document.getElementById("singleInput").value.trim();
  const keywords = value.split(',').map(v => v.trim()).filter(Boolean);
  renderGroups(keywords);
}
function renderGroups(highlightWords = []) {
  const output = document.getElementById("output");
  output.innerHTML = "";
  const highlighted = [], rest = [];
  for (const group of groupList) {
    const text = group.join(", ");
    const div = document.createElement("div");
    div.className = "group";
    div.innerText = text;
    div.onclick = () => {
      document.getElementById("singleInput").value = text;
      updateHighlights();
    };
    if (highlightWords.length > 0 && highlightWords.some(w => group.includes(w))) {
      div.classList.add("highlight");
      highlighted.push(div);
    } else rest.push(div);
  }
  [...highlighted, ...rest].forEach(div => output.appendChild(div));
}

// --- ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ (Local Storage) ---
function saveState() {
  const data = {
    inputs: {},
    phaseMaps: phaseEmojiMaps,
    activePhase: currentActivePhase,
    visible: visibleCount
  };
  for (let i = 1; i <= 8; i++) {
    const input = document.getElementById(`input${i}`);
    if (input) data.inputs[`input${i}`] = input.value;
  }
  data.inputs['singleInput'] = document.getElementById('singleInput').value;
  localStorage.setItem('ìƒíƒœë°±ì—…', JSON.stringify(data));
}
function restoreState() {
  const saved = localStorage.getItem('ìƒíƒœë°±ì—…');
  if (!saved) return;
  try {
    const data = JSON.parse(saved);
    if (data.inputs) {
      for (let key in data.inputs) {
        const el = document.getElementById(key);
        if (el) el.value = data.inputs[key];
      }
    }
    if (data.phaseMaps) phaseEmojiMaps = data.phaseMaps;
    if (data.activePhase) currentActivePhase = data.activePhase;
    if (data.visible) visibleCount = data.visible;

    updateInputVisibility();
    updateDiv1Visuals();
    updatePhaseButtonStates();
    updateHighlights();
  } catch (e) {
    console.error("ìƒíƒœ ë³µì› ì‹¤íŒ¨:", e);
    localStorage.removeItem('ìƒíƒœë°±ì—…');
  }
}

// --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (Event Listeners) ---
function attachFocusListeners() {
  [..."13572468"]
    .map(id => document.querySelector(`#wrapper-input${id}`))
    .filter(wr => wr.style.display!='none')
    .map(wr => wr.querySelector("textarea"))
    .forEach((box, idx, arr) => {
      box.onkeydown = (e) => {
        if (e.key === "Enter" || e.key === "Tab") {
          e.preventDefault();
          if (e.target.id.startsWith("input")) {
            const currentValue = e.target.value.trim();
            if (currentValue !== '' && !currentValue.includes('ã…¡')) {
              e.target.value = e.target.value.trim() + ' ã…¡ ';
            }
          }
          const next = arr[(idx + 1) % (arr.length)];
          next.focus();
        }
      };
    });
}
function attachInputListeners() {
  const ids = ["input1", "input2", "input3", "input4", "input5", "input6", "input7", "input8", "singleInput"];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', saveState);
  });
  document.getElementById("singleInput").addEventListener("input", updateHighlights);
}

// ì „ì—­ ë…¸ì¶œ
window.addSingle = addSingle;
window.clearInputs = clearInputs;
window.loadFromDB = loadFromDB;
window.openEmojiModal = openEmojiModal;
window.addInput = addInput; 
window.removeInput = removeInput; 
window.handleClearCurrentVote = handleClearCurrentVote;
window.handleResetAllVotes = handleResetAllVotes;
window.showHintModal = showHintModal;
window.closeHintModal = closeHintModal;
</script>

</body>
</html>
