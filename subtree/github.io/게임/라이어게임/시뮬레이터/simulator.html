<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<title>ë…¼ë¦¬ í¼ì¦ í”Œë«í¼</title>
	<link rel="stylesheet" href="simulator.css" />
</head>
<body>
	<div class="top-bar">
		ì¸ì›ìˆ˜:
		<button id="decreaseBtn">â—€</button>
		<span id="playerCount">8</span>
		<button id="increaseBtn">â–¶</button>
		<button id="refreshBtn">[ìƒˆë¡œê³ ì¹¨]</button>
	</div>

	<div class="grid-container" id="grid"></div>
	<div class="bottom-bar">í•˜ë‹¨ë°”</div>

	<script>
		const Q = sel => document.querySelector(sel);
		const QQ = sel => Array.from(document.querySelectorAll(sel));
		const Elem = (tag, cls) => {
			const el = document.createElement(tag);
			if (cls) el.className = cls;
			return el;
		};
		const vector = (n, fn) => Array.from({ length: n }, (_, i) => fn(i));
		const randz = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

		const container = Q('#grid');
		const ë™ë¬¼ = ['ì›ìˆ­ì´','ì—¬ìš°','ë¶€ì—‰ì´','ê³°','í† ë¼','ë¼ì§€','ê°•ì•„ì§€','ê³ ì–‘ì´','í–„ìŠ¤í„°','í­ê·„','ì‚¬ì','í˜¸ë‘ì´','íŒë‹¤','ë„ˆêµ¬ë¦¬','ë‹¤ëŒì¥','ì–¼ë£©ë§','ê³ ìŠ´ë„ì¹˜','ì½”ë¼ë¦¬','ì•…ì–´','ìº¥ê±°ë£¨'];
		const íŒ»ë§ = ['ë…¸ë§', 'ì†Œì‹ ì¢Œ', 'ë¼ê²°ì', 'ì–‘ë°œ', 'êº¾ê¸°', 'í˜¼ë€ì¢Œ', 'í¬ê´„', 'ë‹µì½ê¸°', 'ë¹ŒëŸ°', '???'];
		const ì´ëª¨ì§€ì„ íƒì§€ = ['ğŸš«','â­•','âŒ','ğŸ˜ˆ','ğŸ”´','ğŸŸ ','ğŸ¤”','ğŸŸ¡','ğŸŸ£','ğŸ˜‡','ğŸŸ¢','ğŸ”µ'];
		const ì´ëª¨ì§€ê°ë„ = [26, 58, 91];
		const ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ = 45;

		let playerCount = 8;
		const minCount = 4, maxCount = 12;
		let ë™ë¬¼ì¸ë±ìŠ¤ = []; // ì¤‘ë³µ ë°©ì§€ìš©

		function setupEmojiInterface(profileEl) {
			const ìƒíƒœ = { ì´ëª¨ì§€ë“¤: [] };
			const ê°±ì‹  = () => {
				profileEl.querySelectorAll('.emoji-button').forEach(el => el.remove());
				ìƒíƒœ.ì´ëª¨ì§€ë“¤.forEach((emj, i) => {
					const rad = Math.PI * ì´ëª¨ì§€ê°ë„[i] / 180;
					const btn = Elem('div', 'emoji-button');
					btn.textContent = emj;
					btn.style.left = `${50 + ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.sin(rad)}%`;
					btn.style.top = `${50 - ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.cos(rad)}%`;
					btn.addEventListener('click', e => ì—´ê¸°(i, e));
					profileEl.appendChild(btn);
				});
				if (ìƒíƒœ.ì´ëª¨ì§€ë“¤.length < ì´ëª¨ì§€ê°ë„.length) {
					const i = ìƒíƒœ.ì´ëª¨ì§€ë“¤.length;
					const rad = Math.PI * ì´ëª¨ì§€ê°ë„[i] / 180;
					const plus = Elem('div', 'emoji-button');
					plus.textContent = 'â•';
					plus.style.left = `${50 + ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.sin(rad)}%`;
					plus.style.top = `${50 - ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.cos(rad)}%`;
					plus.addEventListener('click', e => ì—´ê¸°(i, e));
					profileEl.appendChild(plus);
				}
			};
			const ì—´ê¸° = (idx, ev) => {
				ev.stopPropagation();
				QQ('.emoji-picker').forEach(p => p.remove());
				const picker = Elem('div', 'emoji-picker');
				ì´ëª¨ì§€ì„ íƒì§€.forEach(emj => {
					const span = Elem('span');
					span.textContent = emj;
					span.addEventListener('click', e => {
						e.stopPropagation();
						if (emj === 'ğŸš«') ìƒíƒœ.ì´ëª¨ì§€ë“¤.splice(idx, 1);
						else ìƒíƒœ.ì´ëª¨ì§€ë“¤[idx] = emj;
						ê°±ì‹ ();
						picker.remove();
					});
					picker.appendChild(span);
				});
				picker.style.left = ev.clientX + 'px';
				picker.style.top = ev.clientY + 'px';
				document.body.appendChild(picker);
			};
			ê°±ì‹ ();
			profileEl._emojiUpdater = ê°±ì‹ ;
		}

		function createCard(index, animalIndex) {
			const wrapper = Elem('div', 'statement-container');
			const profile = Elem('div', 'profile');
			const circle = Elem('div', 'circle');
			const img = Elem('img');
			img.src = `../ë¦¬ì†ŒìŠ¤/ë™ë¬¼${animalIndex}.png`;
			circle.appendChild(img);
			profile.appendChild(circle);

			setupEmojiInterface(profile);

			const demo = íŒ»ë§[randz(0, íŒ»ë§.length - 1)];
			const placard = Elem('div', 'placard');
			placard.textContent = demo;
			placard.dataset.selected = demo;
			profile.appendChild(placard);

			const bubble = Elem('div', 'bubble');
			bubble.textContent = ë™ë¬¼[animalIndex];

			wrapper.appendChild(profile);
			wrapper.appendChild(bubble);
			container.appendChild(wrapper);

			placard.addEventListener('click', e => {
				e.stopPropagation();
				QQ('.placard.expanded').forEach(p => {
					p.classList.remove('expanded');
					p.removeAttribute('style');
					p.textContent = p.dataset.selected;
				});
				const rect = placard.getBoundingClientRect();
				const centerX = rect.left + rect.width / 2;
				const centerY = rect.top + rect.height / 2;
				placard.classList.add('expanded');
				placard.style.left = `${centerX - 125}px`;
				placard.style.top = `${centerY - 30}px`;
				placard.innerHTML = '';
				for (let row = 0; row < 2; row++) {
					const rowDiv = Elem('div', 'choice-row');
					íŒ»ë§.slice(row * 5, (row + 1) * 5).forEach(text => {
						const span = Elem('span', 'choice');
						span.innerHTML = (text === placard.dataset.selected) ? `<strong>${text}</strong>` : text;
						span.addEventListener('click', e => {
							e.stopPropagation();
							placard.textContent = text;
							placard.dataset.selected = text;
							placard.classList.remove('expanded');
							placard.removeAttribute('style');
						});
						rowDiv.appendChild(span);
					});
					placard.appendChild(rowDiv);
				}
			});
		}

		function fillGrid() {
			container.innerHTML = '';
			ë™ë¬¼ì¸ë±ìŠ¤ = randzSet(ë™ë¬¼.length, playerCount);
			for (let i = 0; i < playerCount; i++) {
				createCard(i, ë™ë¬¼ì¸ë±ìŠ¤[i]);
			}
			updateLayoutBasedOnColumn();
		}

		function randzSet(max, count) {
			const pool = vector(max, i => i);
			const result = [];
			while (result.length < count) {
				const idx = randz(0, pool.length - 1);
				result.push(pool.splice(idx, 1)[0]);
			}
			return result;
		}

		Q('#refreshBtn').addEventListener('click', fillGrid);

		Q('#increaseBtn').addEventListener('click', () => {
			if (playerCount >= maxCount) return;
			const newIndex = playerCount++;
			Q('#playerCount').textContent = playerCount;
			const used = new Set(ë™ë¬¼ì¸ë±ìŠ¤);
			const remain = vector(ë™ë¬¼.length, i => i).filter(i => !used.has(i));
			const next = remain[randz(0, remain.length - 1)];
			ë™ë¬¼ì¸ë±ìŠ¤.push(next);
			createCard(newIndex, next);
			updateLayoutBasedOnColumn();
		});

		Q('#decreaseBtn').addEventListener('click', () => {
			if (playerCount <= minCount) return;
			container.lastChild.remove();
			playerCount--;
			ë™ë¬¼ì¸ë±ìŠ¤.pop();
			Q('#playerCount').textContent = playerCount;
			updateLayoutBasedOnColumn();
		});

		document.addEventListener('click', () => {
			QQ('.emoji-picker').forEach(p => p.remove());
			QQ('.placard.expanded').forEach(p => {
				p.classList.remove('expanded');
				p.removeAttribute('style');
				p.textContent = p.dataset.selected;
			});
		});

		function getColumnCount() {
			const items = QQ('.statement-container');
			const left = items.map(x => x.offsetLeft);
			let cols = 0;
			while (left.indexOf(left[cols]) === cols) cols++;
			return cols;
		}

		function updateLayoutBasedOnColumn() {
			QQ('.reverse').forEach(x => x.classList.remove('reverse'));
			const count = getColumnCount();
			QQ('.statement-container').forEach((el, i) => {
				if (count === 2 && i % 2 === 1) el.classList.add('reverse');
			});
		}

		setInterval(() => {
			QQ('.placard.expanded, .emoji-picker').forEach(expanded => {
				const offset = expanded.getBoundingClientRect();
				const shiftX = Math.min(0, offset.left - 10);
				const shiftY = Math.min(0, offset.top - 10);
				const overX = offset.right - window.innerWidth + 10;
				const overY = offset.bottom - window.innerHeight + 10;
				if (shiftX < 0 || overX > 0)
					expanded.style.left = `calc(${expanded.style.left} - ${shiftX || overX}px)`;
				if (shiftY < 0 || overY > 0)
					expanded.style.top = `calc(${expanded.style.top} - ${shiftY || overY}px)`;
			});
		}, 500);

		window.addEventListener('resize', () => {
			QQ('.profile').forEach(p => p._emojiUpdater && p._emojiUpdater());
			updateLayoutBasedOnColumn();
		});

		fillGrid();
	</script>
</body>
</html>
