<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>ë¹„ì¦ˆë‹ˆìŠ¤ ë°°í‹€ ì‹œë®¬ë ˆì´í„°</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			min-height: 100vh;
			background-color: #f0f0f0;
			margin: 0;
		}
		.game-container {
			background-color: #fff;
			padding: 20px;
			border-radius: 8px;
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
			text-align: center;
			width: clamp(300px, 90vmin, 500px);
			height: clamp(350px, 95vmin, 600px);
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			box-sizing: border-box;
		}
		.grid-container {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			grid-template-rows: repeat(3, 1fr);
			gap: 5px;
			margin-top: 20px;
			width: 100%;
			height: 100%;
		}
		/* ê¸°ë³¸ í°íŠ¸ í¬ê¸°ë¥¼ ë³€ìˆ˜ë¡œ ë‘ê³ , ìš°ìŠ¹ ì…€ì—ì„œ 2ë°°ë¡œ í‚¤ì›€ */
		.grid-cell {
			width: 100%;
			height: 100%;
			background-color: #4caf50;
			border: 2px solid #388e3c;
			display: flex;
			align-items: center;
			justify-content: center;
			--base-fs: clamp(1em, 5vmin, 2.5em);
			font-size: var(--base-fs);
			font-weight: bold;
			cursor: pointer;
			transition: background-color 0.3s, transform 0.1s, font-size 0.2s ease;
			color: white;
			user-select: none;
			text-align: center;
		}
		.grid-cell.revealed {
			background-color: #f4f4f4;
			cursor: default;
			color: #333;
		}
		.grid-cell:not(.revealed):hover {
			background-color: #66bb6a;
			transform: scale(1.02);
		}
		/* ìš°ìŠ¹(ë‹¹ì²¨) ì…€: í°íŠ¸ 2ë°° */
		.grid-cell.winner {
			font-size: calc(var(--base-fs) * 2);
		}
		.stage-header {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
		}
		.stage-header h1 {
			margin: 0;
		}
		.stage-title-nav {
			display: flex;
			align-items: center;
			gap: 5px;
		}
		.nav-button {
			background: none;
			border: none;
			font-size: 1.5em;
			cursor: pointer;
			color: #555;
			user-select: none;
			padding: 0 5px;
		}
		.nav-button:hover {
			color: #222;
		}
		#randomStageButton {
			background-color: #e74c3c;
			color: white;
			border: none;
			border-radius: 5px;
			padding: 5px 10px;
			font-size: 1em;
			cursor: pointer;
			transition: background-color 0.2s ease;
		}
		#randomStageButton:hover {
			background-color: #c0392b;
		}
		.seed-display {
			margin-top: 20px;
			font-size: 1.2em;
			color: #333;
		}
		.seed-span {
			color: #888;
			font-size: 0.9em;
			margin: 0 4px;
			cursor: pointer;
			text-decoration: underline;
		}
		.seed-span:hover {
			color: #555;
		}
		.seed-span.active {
			color: #222;
			font-weight: 700;
			text-decoration: underline;
		}
		.seed-sep {
			margin: 0 6px;
			color: #999;
			user-select: none;
		}
		.game-status-display {
			margin-top: 10px;
			font-size: 1em;
			color: #555;
			min-height: 2em;
		}
	</style>
</head>
<body>
	<div class="game-container">
		<div class="stage-header">
			<div class="stage-title-nav">
				<span id="prevStageButton" class="nav-button">â—€</span>
				<h1 id="stageTitle">ìŠ¤í…Œì´ì§€ 000</h1>
				<span id="nextStageButton" class="nav-button">â–¶</span>
			</div>
			<button id="randomStageButton">R</button>
		</div>
		<div class="seed-display" id="seedDisplay"></div>
		<div class="game-status-display" id="gameStatusDisplay"></div>
		<div class="grid-container" id="gameGrid"></div>
	</div>

	<script>
		let Q = (x, y = document) => y.querySelector(x);
		let QQ = (x, y = document) => [...y.querySelectorAll(x)];
		let Elem = (config) => {
			const { tag = "div", text = "", class: className = "", ...attrs } = config;
			const el = document.createElement(tag);
			el.innerText = text;
			el.className = className;
			Object.keys(attrs).forEach((attr) => el.setAttribute(attr, attrs[attr]));
			return el;
		};

		// --- ê²Œì„ ìƒìˆ˜ ---
		const GRID_SIZE = 3;
		const NUM_GEMS_PER_TYPE = 3;
		const GEM_TYPES = ["0", "1", "2"];
		const NUM_MAPS_PER_STAGE = 3;

		const RANDOM_TIPS = [
			"ìˆ¨ê²¨ì§„ ë³´ì„ì„ ì°¾ì•„ë³´ì„¸ìš”!",
			"ì„¸ ê°œì˜ ë§µì´ ë¬´ì‘ìœ„ ìˆœì„œë¡œ ì¶œì œë˜ì–´ìš”",
		];

		// --- ìƒíƒœ ---
		let allStagesData = [];
		let currentStage = 0;
		let currentMapIndex = 0; // ë¬´ì‘ìœ„ ìˆœì„œ ì¤‘ 'ìœ„ì¹˜' (0,1,2)
		let currentMapOrder = []; // ì˜ˆ: [2,0,1] => í‘œì‹œ/ë¡œë”© ìˆœì„œ
		let revealedCells = [];
		let gemCounts = [0, 0, 0];
		let isGameOver = false;
		let currentMapGrid = [];
		let winningGemType = null; // â˜… ìš°ìŠ¹ íƒ€ì… ì €ì¥

		// 16ì§„ìˆ˜ ì‹œë“œë¥¼ 3ì§„ìˆ˜ 3x3 ê²©ìë¡œ
		function hexToTernaryGrid(hexSeed) {
			const decimalValue = parseInt(hexSeed, 16);
			let ternaryString = "";
			let tempValue = decimalValue;

			for (let i = 0; i < 9; i++) {
				ternaryString = (tempValue % 3) + ternaryString;
				tempValue = Math.floor(tempValue / 3);
			}

			const grid = [];
			for (let r = 0; r < GRID_SIZE; r++) {
				const row = [];
				for (let c = 0; c < GRID_SIZE; c++) {
					const value = parseInt(ternaryString[r * GRID_SIZE + c], 10);
					row.push(GEM_TYPES[value]);
				}
				grid.push(row);
			}
			return grid;
		}

		// CSV íŒŒì‹±
		function parseCSV(csvText) {
			const lines = csvText.trim().split("\n");
			const headers = lines[0].split(",").map((h) => h.trim());
			const data = [];

			for (let i = 1; i < lines.length; i++) {
				const values = lines[i].split(",").map((v) => v.trim());
				const stage = {};
				stage.seed = [];

				headers.forEach((header, index) => {
					if (header.startsWith("seed")) {
						stage.seed.push(values[index]);
					} else if (header === "index") {
						stage[header] = parseInt(values[index], 10);
					} else {
						stage[header] = values[index];
					}
				});
				data.push(stage);
			}
			return data;
		}

		async function initGame() {
			try {
				const response = await fetch("stages.csv");
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
				const csvText = await response.text();
				allStagesData = parseCSV(csvText);

				loadStage(0, false); // Initial load

				Q("#randomStageButton").addEventListener("click", () => loadRandomStage(true));
				Q("#prevStageButton").addEventListener("click", () => changeStage(-1));
				Q("#nextStageButton").addEventListener("click", () => changeStage(1));

				updateGameStatusDisplay(getRandomTip());
				loadRandomStage();
			} catch (e) {
				console.error("Error loading stages data:", e);
				updateGameStatusDisplay("ê²Œì„ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
			}
		}

		function loadRandomStage(updateStatus = true) {
			if (allStagesData.length === 0) {
				console.warn("No stage data available to load a random stage.");
				if (updateStatus) updateGameStatusDisplay("ëœë¤ ìŠ¤í…Œì´ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ë°ì´í„° ì—†ìŒ.");
				return;
			}
			const randomIndex = Math.floor(Math.random() * allStagesData.length);
			loadStage(randomIndex, updateStatus);
		}

		function changeStage(direction) {
			if (allStagesData.length === 0) {
				updateGameStatusDisplay("ìŠ¤í…Œì´ì§€ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
				return;
			}

			let newStage = currentStage + direction;
			if (newStage < 0) {
				newStage = allStagesData.length - 1;
			} else if (newStage >= allStagesData.length) {
				newStage = 0;
			}
			loadStage(newStage, true);
		}

		function loadStage(stageIndex, updateStatus = true) {
			if (stageIndex < 0 || stageIndex >= allStagesData.length) {
				console.error("Attempted to load an invalid stage index:", stageIndex);
				if (updateStatus) updateGameStatusDisplay("ìœ íš¨í•˜ì§€ ì•Šì€ ìŠ¤í…Œì´ì§€ ì¸ë±ìŠ¤ì…ë‹ˆë‹¤.");
				return;
			}
			currentStage = stageIndex;
			currentMapIndex = 0;
			isGameOver = false;
			gemCounts = [0, 0, 0];
			winningGemType = null;

			currentMapOrder = Array.from({ length: NUM_MAPS_PER_STAGE }, (_, i) => i).sort(
				() => Math.random() - 0.5
			);

			updateStageUI();
			loadCurrentMap();
			if (updateStatus) updateGameStatusDisplay(getRandomTip());
		}

		// ë¬´ì‘ìœ„ ìˆœì„œëŒ€ë¡œ ì‹œë“œ í‘œì‹œ + â†’ êµ¬ë¶„ì + í˜„ì¬ë§µ ê°•ì¡°
		function updateStageUI() {
			const stageData = allStagesData[currentStage];
			if (!stageData) {
				Q("#stageTitle").textContent = "ê²Œì„ ì¢…ë£Œ";
				Q("#seedDisplay").innerHTML = "";
				return;
			}
			Q("#stageTitle").textContent = `ìŠ¤í…Œì´ì§€ ${String(currentStage + 1).padStart(3, "0")}`;

			const seedDisplayDiv = Q("#seedDisplay");
			seedDisplayDiv.innerHTML = "";

			currentMapOrder.forEach((actualIdx, orderPos) => {
				const seedHex = stageData.seed[actualIdx];
				const span = Elem({
					tag: "span",
					text: seedHex,
					class: "seed-span" + (orderPos === currentMapIndex ? " active" : ""),
					"data-order-pos": orderPos,
				});
				span.addEventListener("click", () => loadMapByOrderPos(orderPos));
				seedDisplayDiv.appendChild(span);

				if (orderPos < currentMapOrder.length - 1) {
					const sep = Elem({ tag: "span", text: "â†’", class: "seed-sep" });
					seedDisplayDiv.appendChild(sep);
				}
			});
		}

		function loadMapByOrderPos(orderPos) {
			currentMapIndex = orderPos;
			loadCurrentMap();
		}

		function loadCurrentMap() {
			const stageData = allStagesData[currentStage];
			if (!stageData || !stageData.seed) {
				console.error("Invalid stage data or seeds not found.", stageData);
				updateGameStatusDisplay("ë§µ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
				return;
			}
			const actualMapIndex = currentMapOrder[currentMapIndex];
			const currentSeed = stageData.seed[actualMapIndex];

			currentMapGrid = hexToTernaryGrid(currentSeed);

			revealedCells = Array(GRID_SIZE)
				.fill(0)
				.map(() => Array(GRID_SIZE).fill(false));
			gemCounts = [0, 0, 0];
			isGameOver = false;
			winningGemType = null;

			createGridUI();
			updateStageUI();
			updateGameStatusDisplay(getRandomTip());
		}

		function createGridUI() {
			Q("#gameGrid").innerHTML = "";
			for (let r = 0; r < GRID_SIZE; r++) {
				for (let c = 0; c < GRID_SIZE; c++) {
					const cell = Elem({
						tag: "div",
						class: "grid-cell",
						"data-row": r,
						"data-col": c,
					});
					cell.addEventListener("click", () => handleCellClick(r, c));
					Q("#gameGrid").appendChild(cell);
				}
			}
		}

		function handleCellClick(row, col) {
			if (isGameOver || revealedCells[row][col]) return;

			revealedCells[row][col] = true;
			const gemType = currentMapGrid[row][col];
			const gemIndex = GEM_TYPES.indexOf(gemType);
			if (gemIndex !== -1) gemCounts[gemIndex]++;

			updateUI();

			// ìŠ¹ë¦¬ ì¡°ê±´: íŠ¹ì • íƒ€ì…ì´ 3ê°œì— ë„ë‹¬
			if (gemCounts[gemIndex] === NUM_GEMS_PER_TYPE) {
				isGameOver = true;
				winningGemType = gemType; // â˜… ìš°ìŠ¹ íƒ€ì… ì €ì¥
				highlightWinningCells(gemType); // â˜… ìš°ìŠ¹ ì…€ ê°•ì¡°

				if (gemType == "0") updateGameStatusDisplay(`ê½! ì•„ì‰¬ì›Œìš”...ğŸ˜¢`);
				if (gemType == "1") updateGameStatusDisplay(`ì¢‹ì•„ìš”~ ğŸ™‚`);
				if (gemType == "2") updateGameStatusDisplay(`ëŒ€ë°•! ğŸ¥°`);
				return;
			}

			updateGameStatusDisplay(getRandomTip());
			checkLossCondition();
		}

		function updateUI() {
			const cells = QQ(".grid-cell", Q("#gameGrid"));
			for (let r = 0; r < GRID_SIZE; r++) {
				for (let c = 0; c < GRID_SIZE; c++) {
					const cellIndex = r * GRID_SIZE + c;
					const cell = cells[cellIndex];
					if (revealedCells[r][c]) {
						cell.classList.add("revealed");
						cell.textContent = ["ğŸ’©", "ğŸ™‚", "ğŸ’"][currentMapGrid[r][c]];
						// ìš°ìŠ¹ ìƒíƒœ ìœ ì§€
						if (winningGemType !== null && currentMapGrid[r][c] === winningGemType) {
							cell.classList.add("winner");
						} else {
							cell.classList.remove("winner");
						}
					} else {
						cell.classList.remove("revealed", "winner");
						cell.textContent = "";
					}
				}
			}
		}

		// ìš°ìŠ¹ ì…€ì— .winner í´ë˜ìŠ¤ ë¶€ì—¬
		function highlightWinningCells(targetGemType) {
			const cells = QQ(".grid-cell", Q("#gameGrid"));
			for (let r = 0; r < GRID_SIZE; r++) {
				for (let c = 0; c < GRID_SIZE; c++) {
					if (revealedCells[r][c] && currentMapGrid[r][c] === targetGemType) {
						const idx = r * GRID_SIZE + c;
						cells[idx].classList.add("winner");
					}
				}
			}
		}

		function updateGameStatusDisplay(message) {
			Q("#gameStatusDisplay").textContent = message;
		}

		function getRandomTip() {
			return RANDOM_TIPS[Math.floor(Math.random() * RANDOM_TIPS.length)];
		}

		// ëª¨ë“  ì…€ì„ ì—° ë’¤ì—ë„ ìŠ¹ë¦¬ ì¡°ê±´ì´ ì—†ìœ¼ë©´ íŒ¨ë°° ì²˜ë¦¬
		function checkLossCondition() {
			if (isGameOver) return;

			let allCellsRevealed = true;
			for (let r = 0; r < GRID_SIZE; r++) {
				for (let c = 0; c < GRID_SIZE; c++) {
					if (!revealedCells[r][c]) {
						allCellsRevealed = false;
						break;
					}
				}
				if (!allCellsRevealed) break;
			}

			if (allCellsRevealed) {
				isGameOver = true;
				updateGameStatusDisplay(
					"ëª¨ë“  ì…€ì„ ë’¤ì§‘ì—ˆì§€ë§Œ ì–´ë–¤ ë³´ì„ë„ 3ê°œì— ë„ë‹¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ê²Œì„ ì˜¤ë²„!"
				);
			}
		}

		window.onload = initGame;
	</script>
</body>
</html>
