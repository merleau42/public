<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>비즈니스 배틀 시뮬레이터</title>
    <link rel="stylesheet" href="비즈니스.css">
  </head>
  <body>
    <div class="app">
      <div class="tabs" role="tablist">
        <button
          class="tab-btn active"
          data-tab="play"
          role="tab"
          aria-controls="panel-play"
          aria-selected="true"
        >
          ▶ 플레이
        </button>
        <button
          class="tab-btn"
          data-tab="make"
          role="tab"
          aria-controls="panel-make"
          aria-selected="false"
        >
          🛠 편집기
        </button>
      </div>

      <!-- 플레이 패널 -->
      <section
        id="panel-play"
        class="panel active"
        role="tabpanel"
        aria-labelledby="tab-play"
      >
        <div class="game-container-inner">
          <div class="stage-header">
            <div class="stage-title-nav">
              <button id="prevStageButton" class="nav-button" title="이전 스테이지" aria-label="이전 스테이지">◀</button>
              <h1 id="stageTitle">스테이지 000</h1>
              <button id="nextStageButton" class="nav-button" title="다음 스테이지" aria-label="다음 스테이지">▶</button>
            </div>
            <div class="stage-buttons">
              <button id="stageOneButton" title="1번 스테이지" aria-label="1번 스테이지">1</button>
              <button id="stageLastButton" title="마지막 스테이지" aria-label="마지막 스테이지">99</button>
              <button id="randomStageButton" title="랜덤 스테이지" aria-label="랜덤 스테이지">R</button>
            </div>
          </div>
          <div class="seed-display" id="seedDisplay"></div>
          <div class="game-status-display"id="gameStatusDisplay"></div>
          <div class="grid-zone">
            <div class="grid-wrap">
              <div class="grid-container" id="gameGrid"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- 편집기 패널 -->
      <section
        id="panel-make"
        class="panel"
        role="tabpanel"
        aria-labelledby="tab-make"
      >
        <div class="game-container-inner" id="creator">
          <div class="stage-header">
            <div class="stage-title-nav">
              <button id="editorPrevStageButton" class="nav-button" title="이전 스테이지" aria-label="이전 스테이지">◀</button>
              <h1 id="makerMapTitle">스테이지 000</h1>
              <button id="editorNextStageButton" class="nav-button" title="다음 스테이지" aria-label="다음 스테이지">▶</button>
            </div>
            <div class="stage-buttons">
              <button id="loadCsvButton" title="CSV 불러오기" aria-label="CSV 불러오기">📂</button>
              <button id="saveCsvButton" title="CSV 저장하기" aria-label="CSV 저장하기">💾</button>
              <button id="uploadCsvButton" title="업로드 (관리자)" aria-label="업로드 (관리자)">📤</button>
            </div>
          </div>
          <!-- 숨김 파일 입력 -->
          <input id="csvFileInput" type="file" accept=".sav,.csv,.txt" />
          <!-- 지도1/2/3 고정 순서 -->
          <div class="seed-display" id="makerSeedDisplay"></div>
          <div class="game-status-display" id="makerStatusDisplay">
            셀을 클릭하여 💩→🙂→💎 순서로 바꿉니다.
          </div>
          <div class="grid-zone">
            <div class="grid-wrap">
              <div class="grid-container" id="makerGrid"></div>
            </div>
          </div>
        </div>
        <!-- /#creator -->
      </section>
    </div>

    <div class="confetti-container" id="confettiContainer"></div>

    <script>
      // ---------- Viewport-safe height CSS var ----------
      const setSVH = () => {
        document.documentElement.style.setProperty("--svh", window.innerHeight + "px");
      };
      setSVH();
      window.addEventListener("resize", setSVH, { passive: true });

      // ---------- DOM helpers ----------
      const Q = (x, y = document) => y.querySelector(x);
      const QQ = (x, y = document) => [...y.querySelectorAll(x)];
      const Elem = (config) => {
        const { tag = "div", text = "", class: className = "", ...attrs } = config;
        const el = document.createElement(tag);
        el.innerText = text;
        el.className = className;
        Object.keys(attrs).forEach((attr) => el.setAttribute(attr, attrs[attr]));
        return el;
      };

      // ---------- Tabs ----------
      function setupTabs() {
        QQ(".tab-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            QQ(".tab-btn").forEach((b) => {
              b.classList.remove("active");
              b.setAttribute("aria-selected", "false");
            });
            QQ(".panel").forEach((p) => p.classList.remove("active"));
            btn.classList.add("active");
            btn.setAttribute("aria-selected", "true");
            const key = btn.dataset.tab;
            Q("#panel-" + key).classList.add("active");
          });
        });
      }

      // ---------- Game constants ----------
      const GRID_SIZE = 3;
      const NUM_GEMS_PER_TYPE = 3;
      const GEM_TYPES = [0, 1, 2];
      const NUM_MAPS_PER_STAGE = 3;

      // 플레이 전용 팁
      const RANDOM_TIPS_PLAY = [
        "숨겨진 보석을 찾아보세요!",
        "세 가지 맵이 무작위 순서로 출제돼요~",
        "나만의 전략을 연구해보세요!",
      ];

      const RANDOM_TIPS_EDITOR = [
        "셀을 클릭하면 💩 → 🙂 → 💎 순서로 바뀌어요.",
        "셀을 클릭하면 💩 → 🙂 → 💎 순서로 바뀌어요.",
        "전체 스테이지를 백업하려면 💾버튼을 눌러주세요",
        "전체 스테이지를 불러오려면 📂버튼을 눌러주세요",
      ];

      function getRandomTipPlay() {
        return RANDOM_TIPS_PLAY[Math.floor(Math.random() * RANDOM_TIPS_PLAY.length)];
      }
      function getRandomTipEditor() {
        return RANDOM_TIPS_EDITOR[Math.floor(Math.random() * RANDOM_TIPS_EDITOR.length)];
      }
      // 30% 확률로만 팁 갱신
      function maybeUpdateTip(targetEl, tipFn, force = false) {
        if (force || Math.random() < 0.25) {
          targetEl.textContent = tipFn();
        }
      }

      // ---------- State (공유) ----------
      let allStagesData = [];
      let currentStage = 0;
      let currentMapIndex = 0; // 플레이 탭 라운드 위치(랜덤 순서)
      let currentMapOrder = [];
      let revealedCells = [];
      let gemCounts = [0, 0, 0];
      let isGameOver = false;
      let currentMapGrid = [];
      let winningGemType = null;
      // 편집기
      let makerMapIndex = 0; // 0:지도1,1:지도2,2:지도3
      let makerGrid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));

      // ---------- Seed enc/dec ----------
      function ternaryStringToGrid(str) {
        const clean = (str || "").replace(/[^012]/g, "");
        if (clean.length !== GRID_SIZE * GRID_SIZE) {
          return Array.from({ length: GRID_SIZE }, () =>
            Array.from({ length: GRID_SIZE }, () => 0)
          );
        }
        const grid = [];
        for (let r = 0; r < GRID_SIZE; r++) {
          const row = [];
          for (let c = 0; c < GRID_SIZE; c++) {
            row.push(parseInt(clean[r * GRID_SIZE + c], 10));
          }
          grid.push(row);
        }
        return grid;
      }
      function gridToTernaryString(grid) {
        let s = "";
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            s += (grid[r][c] || 0).toString();
          }
        }
        return s;
      }

      // ---------- CSV parsing ----------
      function parseCSV(csvText) {
        const lines = csvText.trim().split(/\r?\n/);
        if (lines.length === 0) return [];
        const headers = lines[0].split(",").map((h) => h.trim());
        const data = [];
        for (let i = 1; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          const values = lines[i].split(",").map((v) => v.trim());
          const stage = { seed: [] };
          headers.forEach((header, idx) => {
            if (header.toLowerCase() === "index") {
              stage.index = parseInt(values[idx], 10);
            } else if (header.toLowerCase().startsWith("seed")) {
              stage.seed.push(values[idx]);
            } else {
              stage[header] = values[idx];
            }
          });
          data.push(stage);
        }
        return data;
      }

      // ---------- Game (Play) ----------
      async function initGame() {
        setupTabs();
        try {
          const resStages = await fetch("stages.txt");
          if (resStages.ok) {
            allStagesData = parseCSV(await resStages.text());
          } else {
            allStagesData = [];
          }
        } catch (e) {
          allStagesData = [];
        }
        if (allStagesData.length === 0) {
          allStagesData = [
            { index: 0, seed: ["000111222", "012012012", "210210210"] },
          ];
        }
        initEditor();
        loadStage(0, false);

        Q("#randomStageButton").addEventListener("click", () => loadRandomStage(true));
        Q("#stageOneButton").addEventListener("click", () => loadStage(0, true));
        Q("#stageLastButton").addEventListener("click", () => loadStage(allStagesData.length - 1, true));
        Q("#prevStageButton").addEventListener("click", () => changeStage(-1));
        Q("#nextStageButton").addEventListener("click", () => changeStage(1));

        Q("#stageLastButton").textContent = allStagesData.length;

        // 플레이 탭 초기 팁 (강제 1회 노출)
        maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay, true);
        Q("#makerStatusDisplay").textContent = "셀을 클릭하면 💩 → 🙂 → 💎 순서로 바뀌어요.";
        
      }
      function loadRandomStage(updateStatus = true) {
        const i = Math.floor(Math.random() * allStagesData.length);
        loadStage(i, updateStatus);
      }
      function changeStage(d) {
        let s = currentStage + d;
        if (s < 0) s = allStagesData.length - 1;
        else if (s >= allStagesData.length) s = 0;
        loadStage(s, true);
      }
      function loadStage(stageIndex, updateStatus = true) {
        currentStage = stageIndex;
        currentMapIndex = 0;
        isGameOver = false;
        gemCounts = [0, 0, 0];
        winningGemType = null;
        currentMapOrder = Array.from({ length: NUM_MAPS_PER_STAGE }, (_, i) => i).sort(() => Math.random() - 0.5);
        updateStageUI();
        loadCurrentMap();
        if (updateStatus) maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay);

        // 편집기 동기화
        makerMapIndex = 0;
        updateEditorHeader();
        updateMakerSeedDisplay();
        loadMakerFromSharedSeed();
        // 편집기 탭 상태 메시지 초기 (강제 1회 노출)
        maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor, true);
      }
      function updateStageUI() {
        const stageData = allStagesData[currentStage];
        Q("#stageTitle").textContent = `스테이지 ${String(currentStage + 1).padStart(3, "0")}`;
        const seedDisplayDiv = Q("#seedDisplay");
        seedDisplayDiv.innerHTML = "";
        currentMapOrder.forEach((actualIdx, orderPos) => {
          const span = Elem({
            tag: "span",
            text: `라운드 ${orderPos + 1}`,
            class: "seed-span" + (orderPos === currentMapIndex ? " active" : ""),
            "data-order-pos": orderPos,
          });
          span.addEventListener("click", () => loadMapByOrderPos(orderPos));
          seedDisplayDiv.appendChild(span);
          if (orderPos < currentMapOrder.length - 1) {
            seedDisplayDiv.appendChild(Elem({ tag: "span", text: "→", class: "seed-sep" }));
          }
        });
      }
      function loadMapByOrderPos(orderPos) {
        currentMapIndex = orderPos;
        loadCurrentMap();
      }
      function loadCurrentMap() {
        const stageData = allStagesData[currentStage];
        const actualMapIndex = currentMapOrder[currentMapIndex];
        const currentSeed = stageData.seed[actualMapIndex];
        currentMapGrid = ternaryStringToGrid(currentSeed);
        revealedCells = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
        gemCounts = [0, 0, 0];
        isGameOver = false;
        winningGemType = null;
        createGridUI();
        updateStageUI();
        maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay);
      }
      function createGridUI() {
        const gridEl = Q("#gameGrid");
        gridEl.innerHTML = "";
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const cell = Elem({
              tag: "div",
              class: "grid-cell",
              "data-row": r,
              "data-col": c,
            });
            cell.addEventListener("click", () => handleCellClick(r, c));
            gridEl.appendChild(cell);
          }
        }
        updateUI();
      }
      function handleCellClick(row, col) {
        if (isGameOver) {
          currentMapIndex = (currentMapIndex + 1) % NUM_MAPS_PER_STAGE;
          loadCurrentMap();
          return;
        }
        if (revealedCells[row][col]) return;
        revealedCells[row][col] = true;
        const gemType = currentMapGrid[row][col];
        gemCounts[gemType]++;
        updateUI();
        if (gemCounts[gemType] === NUM_GEMS_PER_TYPE) {
          isGameOver = true;
          winningGemType = gemType;
          highlightWinningCells(gemType);
          if (gemType === 0) updateGameStatusDisplay("꽝! 아쉬워요...😢");
          if (gemType === 1) {
            updateGameStatusDisplay("좋아요~ 🙂");
            triggerConfetti(55);
          }
          if (gemType === 2) {
            updateGameStatusDisplay("대박! 🥰");
            triggerConfetti(80);
          }
          return;
        }
        maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay);
        checkLossCondition();
      }
      function updateUI() {
        const cells = QQ(".grid-cell", Q("#gameGrid"));
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const idx = r * GRID_SIZE + c;
            const cell = cells[idx];
            if (revealedCells[r][c]) {
              cell.classList.add("revealed");
              const v = currentMapGrid[r][c];
              cell.textContent = ["💩", "🙂", "💎"][v];
              if (winningGemType !== null && v === winningGemType) cell.classList.add("winner");
              else cell.classList.remove("winner");
            } else {
              cell.classList.remove("revealed", "winner");
              cell.textContent = "?";
            }
          }
        }
      }
      function highlightWinningCells(t) {
        const cells = QQ(".grid-cell", Q("#gameGrid"));
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (revealedCells[r][c] && currentMapGrid[r][c] === t) {
              const el = cells[r * GRID_SIZE + c];
              el.classList.add("winner");
              el.textContent = ["💩", "😀", "👑"][t];
            }
          }
        }
      }
      function updateGameStatusDisplay(message) {
        Q("#gameStatusDisplay").textContent = message;
      }
      function checkLossCondition() {}

      // ---------- Confetti ----------
      function triggerConfetti(num) {
        const box = Q("#confettiContainer");
        const colors = ["#f00", "#0f0", "#00f", "#ff0", "#0ff", "#f0f"];
        for (let i = 0; i < num; i++) {
          const conf = Elem({ tag: "div", class: "confetti" });
          conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          conf.style.left = Math.random() * 100 + "vw";
          conf.style.animationDelay = Math.random() * 1 + "s";
          conf.style.animationDuration = 2 + Math.random() * 2 + "s";
          box.appendChild(conf);
          conf.addEventListener("animationend", () => conf.remove());
        }
      }

      // ---------- Editor (편집기) ----------
      function initEditor() {
        const host = Q("#makerGrid");
        host.innerHTML = "";
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const cell = Elem({
              tag: "div",
              class: "grid-cell revealed",
              "data-r": r,
              "data-c": c,
            });
            cell.addEventListener("click", () => toggleMakerCell(r, c));
            host.appendChild(cell);
          }
        }
        updateEditorHeader();
        updateMakerSeedDisplay();
        loadMakerFromSharedSeed();

        // CSV 불러오기/저장하기
        Q("#loadCsvButton").addEventListener("click", () => Q("#csvFileInput").click());
        Q("#csvFileInput").addEventListener("change", handleCsvLoad);
        Q("#saveCsvButton").addEventListener("click", handleCsvSave);
        // 관리자 업로드 (상세 구현은 추후)
        Q("#uploadCsvButton").addEventListener("click", () => {
          alert("구현 예정");
        });

        // 스테이지 이동 (편집기 전용)
        Q("#editorPrevStageButton").addEventListener("click", () => changeStage(-1));
        Q("#editorNextStageButton").addEventListener("click", () => changeStage(1));

        // 편집기 탭 초기 팁 (강제 1회 노출)
        maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor, true);
      }
      function updateEditorHeader() {
        Q("#makerMapTitle").textContent = `스테이지 ${String(currentStage + 1).padStart(3, "0")}`;
      }
      function updateMakerSeedDisplay() {
        const host = Q("#makerSeedDisplay");
        host.innerHTML = "";
        [0, 1, 2].forEach((i) => {
          const span = Elem({
            tag: "span",
            text: `지도 ${i + 1}`,
            class: "seed-span" + (i === makerMapIndex ? " active" : ""),
            "data-map-index": i,
          });
          span.addEventListener("click", () => {
            makerMapIndex = i;
            loadMakerFromSharedSeed();
            updateMakerSeedDisplay();
            maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor);
          });
          host.appendChild(span);
          if (i < 2) host.appendChild(Elem({ tag: "span", text: "　", class: "seed-sep" }));
        });
      }
      function loadMakerFromSharedSeed() {
        const stageData = allStagesData[currentStage];
        const seedStr = stageData.seed[makerMapIndex];
        makerGrid = ternaryStringToGrid(seedStr);
        updateMakerUI();
      }
      function toggleMakerCell(r, c) {
        const cur = makerGrid[r][c];
        const next = (cur + 1) % 3;
        makerGrid[r][c] = next;
        commitMakerToSharedSeed();
        updateMakerUI();
        maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor);
      }
      function commitMakerToSharedSeed() {
        const seed = gridToTernaryString(makerGrid);
        allStagesData[currentStage].seed[makerMapIndex] = seed;

        // 플레이 쪽과 같은 지도를 편집 중이면 미리보기 반영
        const actualMapIndex = currentMapOrder[currentMapIndex];
        if (makerMapIndex === actualMapIndex) {
          currentMapGrid = ternaryStringToGrid(seed);
          updateUI();
        }
      }
      function updateMakerUI() {
        const cells = QQ("#makerGrid .grid-cell");
        if (!cells || cells.length === 0) return;
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const idx = r * GRID_SIZE + c;
            const v = makerGrid[r][c];
            cells[idx].textContent = ["💩", "🙂", "💎"][v];
          }
        }
      }

      // ---------- CSV Load/Save ----------
      function validateStagesCsv(arr) {
        if (!Array.isArray(arr) || arr.length === 0) return false;
        return arr.every(
          (stage) =>
            Array.isArray(stage.seed) &&
            stage.seed.length === 3 &&
            stage.seed.every(
              (s) => typeof s === "string" && s.replace(/[^012]/g, "").length === 9
            )
        );
      }
      async function handleCsvLoad(ev) {
        const file = ev.target.files && ev.target.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const parsed = parseCSV(text);
          if (!validateStagesCsv(parsed))
            throw new Error("형식 오류: index, seed1~3 컬럼 / 각 seed는 3x3(9글자) 0/1/2 문자열이어야 합니다.");
          allStagesData = parsed.map((s, i) => ({
            index: typeof s.index === "number" ? s.index : i,
            ...s,
          }));
          loadStage(0, true);
          Q("#makerStatusDisplay").textContent = "CSV를 불러왔습니다.";
        } catch (err) {
          console.error(err);
          alert("CSV 불러오기 실패: " + err.message);
        } finally {
          ev.target.value = "";
        }
      }
      function handleCsvSave() {
        const headers = ["index", "seed1", "seed2", "seed3"];
        const rows = allStagesData.map((s, i) => {
          const idx = typeof s.index === "number" ? s.index : i;
          const [a, b, c] = s.seed || ["", "", ""];
          return [idx, a, b, c].join(",");
        });
        const csv = [headers.join(","), ...rows].join("\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "stages.txt";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // ---------- boot ----------
      window.addEventListener("load", initGame);
    </script>
  </body>
</html>
