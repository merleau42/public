<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ë¹„ì¦ˆë‹ˆìŠ¤ ë°°í‹€ ì‹œë®¬ë ˆì´í„°</title>
    <link rel="stylesheet" href="ë¹„ì¦ˆë‹ˆìŠ¤.css">
  </head>
  <body>
    <div class="app">
      <div class="tabs" role="tablist">
        <button
          class="tab-btn active"
          data-tab="play"
          role="tab"
          aria-controls="panel-play"
          aria-selected="true"
        >
          â–¶ í”Œë ˆì´
        </button>
        <button
          class="tab-btn"
          data-tab="make"
          role="tab"
          aria-controls="panel-make"
          aria-selected="false"
        >
          ğŸ›  í¸ì§‘ê¸°
        </button>
      </div>

      <!-- í”Œë ˆì´ íŒ¨ë„ -->
      <section
        id="panel-play"
        class="panel active"
        role="tabpanel"
        aria-labelledby="tab-play"
      >
        <div class="game-container-inner">
          <div class="stage-header">
            <div class="stage-title-nav">
              <button id="prevStageButton" class="nav-button" title="ì´ì „ ìŠ¤í…Œì´ì§€" aria-label="ì´ì „ ìŠ¤í…Œì´ì§€">â—€</button>
              <h1 id="stageTitle">ìŠ¤í…Œì´ì§€ 000</h1>
              <button id="nextStageButton" class="nav-button" title="ë‹¤ìŒ ìŠ¤í…Œì´ì§€" aria-label="ë‹¤ìŒ ìŠ¤í…Œì´ì§€">â–¶</button>
            </div>
            <div class="stage-buttons">
              <button id="stageOneButton" title="1ë²ˆ ìŠ¤í…Œì´ì§€" aria-label="1ë²ˆ ìŠ¤í…Œì´ì§€">1</button>
              <button id="stageLastButton" title="ë§ˆì§€ë§‰ ìŠ¤í…Œì´ì§€" aria-label="ë§ˆì§€ë§‰ ìŠ¤í…Œì´ì§€">99</button>
              <button id="randomStageButton" title="ëœë¤ ìŠ¤í…Œì´ì§€" aria-label="ëœë¤ ìŠ¤í…Œì´ì§€">R</button>
            </div>
          </div>
          <div class="seed-display" id="seedDisplay"></div>
          <div class="game-status-display"id="gameStatusDisplay"></div>
          <div class="grid-zone">
            <div class="grid-wrap">
              <div class="grid-container" id="gameGrid"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- í¸ì§‘ê¸° íŒ¨ë„ -->
      <section
        id="panel-make"
        class="panel"
        role="tabpanel"
        aria-labelledby="tab-make"
      >
        <div class="game-container-inner" id="creator">
          <div class="stage-header">
            <div class="stage-title-nav">
              <button id="editorPrevStageButton" class="nav-button" title="ì´ì „ ìŠ¤í…Œì´ì§€" aria-label="ì´ì „ ìŠ¤í…Œì´ì§€">â—€</button>
              <h1 id="makerMapTitle">ìŠ¤í…Œì´ì§€ 000</h1>
              <button id="editorNextStageButton" class="nav-button" title="ë‹¤ìŒ ìŠ¤í…Œì´ì§€" aria-label="ë‹¤ìŒ ìŠ¤í…Œì´ì§€">â–¶</button>
            </div>
            <div class="stage-buttons">
              <button id="loadCsvButton" title="CSV ë¶ˆëŸ¬ì˜¤ê¸°" aria-label="CSV ë¶ˆëŸ¬ì˜¤ê¸°">ğŸ“‚</button>
              <button id="saveCsvButton" title="CSV ì €ì¥í•˜ê¸°" aria-label="CSV ì €ì¥í•˜ê¸°">ğŸ’¾</button>
              <button id="uploadCsvButton" title="ì—…ë¡œë“œ (ê´€ë¦¬ì)" aria-label="ì—…ë¡œë“œ (ê´€ë¦¬ì)">ğŸ“¤</button>
            </div>
          </div>
          <!-- ìˆ¨ê¹€ íŒŒì¼ ì…ë ¥ -->
          <input id="csvFileInput" type="file" accept=".sav,.csv,.txt" />
          <!-- ì§€ë„1/2/3 ê³ ì • ìˆœì„œ -->
          <div class="seed-display" id="makerSeedDisplay"></div>
          <div class="game-status-display" id="makerStatusDisplay">
            ì…€ì„ í´ë¦­í•˜ì—¬ ğŸ’©â†’ğŸ™‚â†’ğŸ’ ìˆœì„œë¡œ ë°”ê¿‰ë‹ˆë‹¤.
          </div>
          <div class="grid-zone">
            <div class="grid-wrap">
              <div class="grid-container" id="makerGrid"></div>
            </div>
          </div>
        </div>
        <!-- /#creator -->
      </section>
    </div>

    <div class="confetti-container" id="confettiContainer"></div>

    <script>
      // ---------- Viewport-safe height CSS var ----------
      const setSVH = () => {
        document.documentElement.style.setProperty("--svh", window.innerHeight + "px");
      };
      setSVH();
      window.addEventListener("resize", setSVH, { passive: true });

      // ---------- DOM helpers ----------
      const Q = (x, y = document) => y.querySelector(x);
      const QQ = (x, y = document) => [...y.querySelectorAll(x)];
      const Elem = (config) => {
        const { tag = "div", text = "", class: className = "", ...attrs } = config;
        const el = document.createElement(tag);
        el.innerText = text;
        el.className = className;
        Object.keys(attrs).forEach((attr) => el.setAttribute(attr, attrs[attr]));
        return el;
      };

      // ---------- Tabs ----------
      function setupTabs() {
        QQ(".tab-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            QQ(".tab-btn").forEach((b) => {
              b.classList.remove("active");
              b.setAttribute("aria-selected", "false");
            });
            QQ(".panel").forEach((p) => p.classList.remove("active"));
            btn.classList.add("active");
            btn.setAttribute("aria-selected", "true");
            const key = btn.dataset.tab;
            Q("#panel-" + key).classList.add("active");
          });
        });
      }

      // ---------- Game constants ----------
      const GRID_SIZE = 3;
      const NUM_GEMS_PER_TYPE = 3;
      const GEM_TYPES = [0, 1, 2];
      const NUM_MAPS_PER_STAGE = 3;

      // í”Œë ˆì´ ì „ìš© íŒ
      const RANDOM_TIPS_PLAY = [
        "ìˆ¨ê²¨ì§„ ë³´ì„ì„ ì°¾ì•„ë³´ì„¸ìš”!",
        "ì„¸ ê°€ì§€ ë§µì´ ë¬´ì‘ìœ„ ìˆœì„œë¡œ ì¶œì œë¼ìš”~",
        "ë‚˜ë§Œì˜ ì „ëµì„ ì—°êµ¬í•´ë³´ì„¸ìš”!",
      ];

      const RANDOM_TIPS_EDITOR = [
        "ì…€ì„ í´ë¦­í•˜ë©´ ğŸ’© â†’ ğŸ™‚ â†’ ğŸ’ ìˆœì„œë¡œ ë°”ë€Œì–´ìš”.",
        "ì…€ì„ í´ë¦­í•˜ë©´ ğŸ’© â†’ ğŸ™‚ â†’ ğŸ’ ìˆœì„œë¡œ ë°”ë€Œì–´ìš”.",
        "ì „ì²´ ìŠ¤í…Œì´ì§€ë¥¼ ë°±ì—…í•˜ë ¤ë©´ ğŸ’¾ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”",
        "ì „ì²´ ìŠ¤í…Œì´ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ë ¤ë©´ ğŸ“‚ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”",
      ];

      function getRandomTipPlay() {
        return RANDOM_TIPS_PLAY[Math.floor(Math.random() * RANDOM_TIPS_PLAY.length)];
      }
      function getRandomTipEditor() {
        return RANDOM_TIPS_EDITOR[Math.floor(Math.random() * RANDOM_TIPS_EDITOR.length)];
      }
      // 30% í™•ë¥ ë¡œë§Œ íŒ ê°±ì‹ 
      function maybeUpdateTip(targetEl, tipFn, force = false) {
        if (force || Math.random() < 0.25) {
          targetEl.textContent = tipFn();
        }
      }

      // ---------- State (ê³µìœ ) ----------
      let allStagesData = [];
      let currentStage = 0;
      let currentMapIndex = 0; // í”Œë ˆì´ íƒ­ ë¼ìš´ë“œ ìœ„ì¹˜(ëœë¤ ìˆœì„œ)
      let currentMapOrder = [];
      let revealedCells = [];
      let gemCounts = [0, 0, 0];
      let isGameOver = false;
      let currentMapGrid = [];
      let winningGemType = null;
      // í¸ì§‘ê¸°
      let makerMapIndex = 0; // 0:ì§€ë„1,1:ì§€ë„2,2:ì§€ë„3
      let makerGrid = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));

      // ---------- Seed enc/dec ----------
      function ternaryStringToGrid(str) {
        const clean = (str || "").replace(/[^012]/g, "");
        if (clean.length !== GRID_SIZE * GRID_SIZE) {
          return Array.from({ length: GRID_SIZE }, () =>
            Array.from({ length: GRID_SIZE }, () => 0)
          );
        }
        const grid = [];
        for (let r = 0; r < GRID_SIZE; r++) {
          const row = [];
          for (let c = 0; c < GRID_SIZE; c++) {
            row.push(parseInt(clean[r * GRID_SIZE + c], 10));
          }
          grid.push(row);
        }
        return grid;
      }
      function gridToTernaryString(grid) {
        let s = "";
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            s += (grid[r][c] || 0).toString();
          }
        }
        return s;
      }

      // ---------- CSV parsing ----------
      function parseCSV(csvText) {
        const lines = csvText.trim().split(/\r?\n/);
        if (lines.length === 0) return [];
        const headers = lines[0].split(",").map((h) => h.trim());
        const data = [];
        for (let i = 1; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          const values = lines[i].split(",").map((v) => v.trim());
          const stage = { seed: [] };
          headers.forEach((header, idx) => {
            if (header.toLowerCase() === "index") {
              stage.index = parseInt(values[idx], 10);
            } else if (header.toLowerCase().startsWith("seed")) {
              stage.seed.push(values[idx]);
            } else {
              stage[header] = values[idx];
            }
          });
          data.push(stage);
        }
        return data;
      }

      // ---------- Game (Play) ----------
      async function initGame() {
        setupTabs();
        try {
          const resStages = await fetch("stages.txt");
          if (resStages.ok) {
            allStagesData = parseCSV(await resStages.text());
          } else {
            allStagesData = [];
          }
        } catch (e) {
          allStagesData = [];
        }
        if (allStagesData.length === 0) {
          allStagesData = [
            { index: 0, seed: ["000111222", "012012012", "210210210"] },
          ];
        }
        initEditor();
        loadStage(0, false);

        Q("#randomStageButton").addEventListener("click", () => loadRandomStage(true));
        Q("#stageOneButton").addEventListener("click", () => loadStage(0, true));
        Q("#stageLastButton").addEventListener("click", () => loadStage(allStagesData.length - 1, true));
        Q("#prevStageButton").addEventListener("click", () => changeStage(-1));
        Q("#nextStageButton").addEventListener("click", () => changeStage(1));

        Q("#stageLastButton").textContent = allStagesData.length;

        // í”Œë ˆì´ íƒ­ ì´ˆê¸° íŒ (ê°•ì œ 1íšŒ ë…¸ì¶œ)
        maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay, true);
        Q("#makerStatusDisplay").textContent = "ì…€ì„ í´ë¦­í•˜ë©´ ğŸ’© â†’ ğŸ™‚ â†’ ğŸ’ ìˆœì„œë¡œ ë°”ë€Œì–´ìš”.";
        
      }
      function loadRandomStage(updateStatus = true) {
        const i = Math.floor(Math.random() * allStagesData.length);
        loadStage(i, updateStatus);
      }
      function changeStage(d) {
        let s = currentStage + d;
        if (s < 0) s = allStagesData.length - 1;
        else if (s >= allStagesData.length) s = 0;
        loadStage(s, true);
      }
      function loadStage(stageIndex, updateStatus = true) {
        currentStage = stageIndex;
        currentMapIndex = 0;
        isGameOver = false;
        gemCounts = [0, 0, 0];
        winningGemType = null;
        currentMapOrder = Array.from({ length: NUM_MAPS_PER_STAGE }, (_, i) => i).sort(() => Math.random() - 0.5);
        updateStageUI();
        loadCurrentMap();
        if (updateStatus) maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay);

        // í¸ì§‘ê¸° ë™ê¸°í™”
        makerMapIndex = 0;
        updateEditorHeader();
        updateMakerSeedDisplay();
        loadMakerFromSharedSeed();
        // í¸ì§‘ê¸° íƒ­ ìƒíƒœ ë©”ì‹œì§€ ì´ˆê¸° (ê°•ì œ 1íšŒ ë…¸ì¶œ)
        maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor, true);
      }
      function updateStageUI() {
        const stageData = allStagesData[currentStage];
        Q("#stageTitle").textContent = `ìŠ¤í…Œì´ì§€ ${String(currentStage + 1).padStart(3, "0")}`;
        const seedDisplayDiv = Q("#seedDisplay");
        seedDisplayDiv.innerHTML = "";
        currentMapOrder.forEach((actualIdx, orderPos) => {
          const span = Elem({
            tag: "span",
            text: `ë¼ìš´ë“œ ${orderPos + 1}`,
            class: "seed-span" + (orderPos === currentMapIndex ? " active" : ""),
            "data-order-pos": orderPos,
          });
          span.addEventListener("click", () => loadMapByOrderPos(orderPos));
          seedDisplayDiv.appendChild(span);
          if (orderPos < currentMapOrder.length - 1) {
            seedDisplayDiv.appendChild(Elem({ tag: "span", text: "â†’", class: "seed-sep" }));
          }
        });
      }
      function loadMapByOrderPos(orderPos) {
        currentMapIndex = orderPos;
        loadCurrentMap();
      }
      function loadCurrentMap() {
        const stageData = allStagesData[currentStage];
        const actualMapIndex = currentMapOrder[currentMapIndex];
        const currentSeed = stageData.seed[actualMapIndex];
        currentMapGrid = ternaryStringToGrid(currentSeed);
        revealedCells = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
        gemCounts = [0, 0, 0];
        isGameOver = false;
        winningGemType = null;
        createGridUI();
        updateStageUI();
        maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay);
      }
      function createGridUI() {
        const gridEl = Q("#gameGrid");
        gridEl.innerHTML = "";
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const cell = Elem({
              tag: "div",
              class: "grid-cell",
              "data-row": r,
              "data-col": c,
            });
            cell.addEventListener("click", () => handleCellClick(r, c));
            gridEl.appendChild(cell);
          }
        }
        updateUI();
      }
      function handleCellClick(row, col) {
        if (isGameOver) {
          currentMapIndex = (currentMapIndex + 1) % NUM_MAPS_PER_STAGE;
          loadCurrentMap();
          return;
        }
        if (revealedCells[row][col]) return;
        revealedCells[row][col] = true;
        const gemType = currentMapGrid[row][col];
        gemCounts[gemType]++;
        updateUI();
        if (gemCounts[gemType] === NUM_GEMS_PER_TYPE) {
          isGameOver = true;
          winningGemType = gemType;
          highlightWinningCells(gemType);
          if (gemType === 0) updateGameStatusDisplay("ê½! ì•„ì‰¬ì›Œìš”...ğŸ˜¢");
          if (gemType === 1) {
            updateGameStatusDisplay("ì¢‹ì•„ìš”~ ğŸ™‚");
            triggerConfetti(55);
          }
          if (gemType === 2) {
            updateGameStatusDisplay("ëŒ€ë°•! ğŸ¥°");
            triggerConfetti(80);
          }
          return;
        }
        maybeUpdateTip(Q("#gameStatusDisplay"), getRandomTipPlay);
        checkLossCondition();
      }
      function updateUI() {
        const cells = QQ(".grid-cell", Q("#gameGrid"));
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const idx = r * GRID_SIZE + c;
            const cell = cells[idx];
            if (revealedCells[r][c]) {
              cell.classList.add("revealed");
              const v = currentMapGrid[r][c];
              cell.textContent = ["ğŸ’©", "ğŸ™‚", "ğŸ’"][v];
              if (winningGemType !== null && v === winningGemType) cell.classList.add("winner");
              else cell.classList.remove("winner");
            } else {
              cell.classList.remove("revealed", "winner");
              cell.textContent = "?";
            }
          }
        }
      }
      function highlightWinningCells(t) {
        const cells = QQ(".grid-cell", Q("#gameGrid"));
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (revealedCells[r][c] && currentMapGrid[r][c] === t) {
              const el = cells[r * GRID_SIZE + c];
              el.classList.add("winner");
              el.textContent = ["ğŸ’©", "ğŸ˜€", "ğŸ‘‘"][t];
            }
          }
        }
      }
      function updateGameStatusDisplay(message) {
        Q("#gameStatusDisplay").textContent = message;
      }
      function checkLossCondition() {}

      // ---------- Confetti ----------
      function triggerConfetti(num) {
        const box = Q("#confettiContainer");
        const colors = ["#f00", "#0f0", "#00f", "#ff0", "#0ff", "#f0f"];
        for (let i = 0; i < num; i++) {
          const conf = Elem({ tag: "div", class: "confetti" });
          conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          conf.style.left = Math.random() * 100 + "vw";
          conf.style.animationDelay = Math.random() * 1 + "s";
          conf.style.animationDuration = 2 + Math.random() * 2 + "s";
          box.appendChild(conf);
          conf.addEventListener("animationend", () => conf.remove());
        }
      }

      // ---------- Editor (í¸ì§‘ê¸°) ----------
      function initEditor() {
        const host = Q("#makerGrid");
        host.innerHTML = "";
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const cell = Elem({
              tag: "div",
              class: "grid-cell revealed",
              "data-r": r,
              "data-c": c,
            });
            cell.addEventListener("click", () => toggleMakerCell(r, c));
            host.appendChild(cell);
          }
        }
        updateEditorHeader();
        updateMakerSeedDisplay();
        loadMakerFromSharedSeed();

        // CSV ë¶ˆëŸ¬ì˜¤ê¸°/ì €ì¥í•˜ê¸°
        Q("#loadCsvButton").addEventListener("click", () => Q("#csvFileInput").click());
        Q("#csvFileInput").addEventListener("change", handleCsvLoad);
        Q("#saveCsvButton").addEventListener("click", handleCsvSave);
        // ê´€ë¦¬ì ì—…ë¡œë“œ (ìƒì„¸ êµ¬í˜„ì€ ì¶”í›„)
        Q("#uploadCsvButton").addEventListener("click", () => {
          alert("êµ¬í˜„ ì˜ˆì •");
        });

        // ìŠ¤í…Œì´ì§€ ì´ë™ (í¸ì§‘ê¸° ì „ìš©)
        Q("#editorPrevStageButton").addEventListener("click", () => changeStage(-1));
        Q("#editorNextStageButton").addEventListener("click", () => changeStage(1));

        // í¸ì§‘ê¸° íƒ­ ì´ˆê¸° íŒ (ê°•ì œ 1íšŒ ë…¸ì¶œ)
        maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor, true);
      }
      function updateEditorHeader() {
        Q("#makerMapTitle").textContent = `ìŠ¤í…Œì´ì§€ ${String(currentStage + 1).padStart(3, "0")}`;
      }
      function updateMakerSeedDisplay() {
        const host = Q("#makerSeedDisplay");
        host.innerHTML = "";
        [0, 1, 2].forEach((i) => {
          const span = Elem({
            tag: "span",
            text: `ì§€ë„ ${i + 1}`,
            class: "seed-span" + (i === makerMapIndex ? " active" : ""),
            "data-map-index": i,
          });
          span.addEventListener("click", () => {
            makerMapIndex = i;
            loadMakerFromSharedSeed();
            updateMakerSeedDisplay();
            maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor);
          });
          host.appendChild(span);
          if (i < 2) host.appendChild(Elem({ tag: "span", text: "ã€€", class: "seed-sep" }));
        });
      }
      function loadMakerFromSharedSeed() {
        const stageData = allStagesData[currentStage];
        const seedStr = stageData.seed[makerMapIndex];
        makerGrid = ternaryStringToGrid(seedStr);
        updateMakerUI();
      }
      function toggleMakerCell(r, c) {
        const cur = makerGrid[r][c];
        const next = (cur + 1) % 3;
        makerGrid[r][c] = next;
        commitMakerToSharedSeed();
        updateMakerUI();
        maybeUpdateTip(Q("#makerStatusDisplay"), getRandomTipEditor);
      }
      function commitMakerToSharedSeed() {
        const seed = gridToTernaryString(makerGrid);
        allStagesData[currentStage].seed[makerMapIndex] = seed;

        // í”Œë ˆì´ ìª½ê³¼ ê°™ì€ ì§€ë„ë¥¼ í¸ì§‘ ì¤‘ì´ë©´ ë¯¸ë¦¬ë³´ê¸° ë°˜ì˜
        const actualMapIndex = currentMapOrder[currentMapIndex];
        if (makerMapIndex === actualMapIndex) {
          currentMapGrid = ternaryStringToGrid(seed);
          updateUI();
        }
      }
      function updateMakerUI() {
        const cells = QQ("#makerGrid .grid-cell");
        if (!cells || cells.length === 0) return;
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const idx = r * GRID_SIZE + c;
            const v = makerGrid[r][c];
            cells[idx].textContent = ["ğŸ’©", "ğŸ™‚", "ğŸ’"][v];
          }
        }
      }

      // ---------- CSV Load/Save ----------
      function validateStagesCsv(arr) {
        if (!Array.isArray(arr) || arr.length === 0) return false;
        return arr.every(
          (stage) =>
            Array.isArray(stage.seed) &&
            stage.seed.length === 3 &&
            stage.seed.every(
              (s) => typeof s === "string" && s.replace(/[^012]/g, "").length === 9
            )
        );
      }
      async function handleCsvLoad(ev) {
        const file = ev.target.files && ev.target.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const parsed = parseCSV(text);
          if (!validateStagesCsv(parsed))
            throw new Error("í˜•ì‹ ì˜¤ë¥˜: index, seed1~3 ì»¬ëŸ¼ / ê° seedëŠ” 3x3(9ê¸€ì) 0/1/2 ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
          allStagesData = parsed.map((s, i) => ({
            index: typeof s.index === "number" ? s.index : i,
            ...s,
          }));
          loadStage(0, true);
          Q("#makerStatusDisplay").textContent = "CSVë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.";
        } catch (err) {
          console.error(err);
          alert("CSV ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: " + err.message);
        } finally {
          ev.target.value = "";
        }
      }
      function handleCsvSave() {
        const headers = ["index", "seed1", "seed2", "seed3"];
        const rows = allStagesData.map((s, i) => {
          const idx = typeof s.index === "number" ? s.index : i;
          const [a, b, c] = s.seed || ["", "", ""];
          return [idx, a, b, c].join(",");
        });
        const csv = [headers.join(","), ...rows].join("\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "stages.txt";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // ---------- boot ----------
      window.addEventListener("load", initGame);
    </script>
  </body>
</html>
