<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Firebase DB 마이그레이션 도구 (Add Author)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #status { margin-top: 20px; white-space: pre-wrap; border: 1px solid #ccc; padding: 10px; min-height: 100px; background-color: #f9f9f9; }
    button { font-size: 16px; padding: 10px 15px; }
  </style>
</head>
<body>

  <h1>Liar Groups DB 마이그레이션 (Add Author)</h1>
  <p>이 도구는 'liar_groups'의 모든 데이터에 대해 'statements' 배열을 마이그레이션합니다.</p>
  <ul>
    <li>'statements' 배열의 각 항목이 문자열인 경우, <code>{ text: "...", author: "" }</code> 형태의 객체로 변환합니다.</li>
    <li>'statements' 배열의 각 항목이 객체이지만 'author' 필드가 없는 경우, 'author' 필드를 추가합니다.</li>
  </ul>
  <p><strong>주의: 이 작업은 되돌릴 수 없습니다. 시작하기 전에 DB를 백업했는지 확인하세요.</strong></p>
  
  <button id="start-migration-btn">마이그레이션 시작</button>

  <div id="status">진행 상황이 여기에 표시됩니다...</div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getDatabase, ref, get, set } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyDVVAx9XRziu8IZ9CLczaG20QEOwyY4uLs",
        authDomain: "liarwords-af033.firebaseapp.com",
        databaseURL: "https://liarwords-af033-default-rtdb.firebaseio.com",
        projectId: "liarwords-af033",
        storageBucket: "liarwords-af033.appspot.com",
        messagingSenderId: "171671976030",
        appId: "1:171671976030:web:59371970ec6b2a70035ccf"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const dbRef = ref(db, 'liar_groups');
    const startBtn = document.getElementById('start-migration-btn');
    const statusEl = document.getElementById('status');

    const log = (message) => {
      console.log(message);
      statusEl.textContent += message + '';
    };

    startBtn.addEventListener('click', async () => {
      if (!confirm('정말로 마이그레이션을 시작하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
        log('마이그레이션이 취소되었습니다.');
        return;
      }

      startBtn.disabled = true;
      log('마이그레이션을 시작합니다...');

      try {
        const snapshot = await get(dbRef);
        if (!snapshot.exists()) {
          log('데이터를 찾을 수 없습니다.');
          return;
        }

        const allData = snapshot.val();
        let changesMade = 0;

        for (const groupId in allData) {
          const group = allData[groupId];
          if (group.statements && Array.isArray(group.statements)) {
            
            const newStatements = group.statements.map(stmt => {
              if (typeof stmt === 'string') {
                changesMade++;
                return { text: stmt, author: '' };
              }
              if (typeof stmt === 'object' && stmt !== null && !stmt.hasOwnProperty('author')) {
                changesMade++;
                stmt.author = '';
                return stmt;
              }
              // If it's an object that already has an author, or something else, return as is.
              return stmt;
            });

            group.statements = newStatements;
          }
        }

        if (changesMade > 0) {
          log(`${changesMade}개의 항목을 변경했습니다. DB에 쓰는 중...`);
          await set(dbRef, allData);
          log('마이그레이션이 성공적으로 완료되었습니다!');
        } else {
          log('변경할 항목이 없습니다. 모든 데이터가 이미 최신 형식입니다.');
        }

      } catch (error) {
        log('오류 발생: ' + error.message);
        console.error(error);
      } finally {
        startBtn.disabled = false;
      }
    });

  </script>
</body>
</html>
