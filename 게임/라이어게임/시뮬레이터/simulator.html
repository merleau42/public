<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë¼ì´ì–´ê²Œì„ ì‹œë®¬ë ˆì´í„°</title>
    <link rel="stylesheet" href="simulator.css" />
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDVVAx9XRziu8IZ9CLczaG20QEOwyY4uLs",
            authDomain: "liarwords-af033.firebaseapp.com",
            databaseURL: "https://liarwords-af033-default-rtdb.firebaseio.com",
            projectId: "liarwords-af033",
            storageBucket: "liarwords-af033.appspot.com",
            messagingSenderId: "171671976030",
            appId: "1:171671976030:web:59371970ec6b2a70035ccf"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        async function getFirebaseData(path) {
            try {
                const snapshot = await get(ref(db, path));
                if (snapshot.exists()) {
                    return snapshot.val();
                } else {
                    console.log("No data available at path:", path);
                    return null;
                }
            } catch (error) {
                console.error("Error loading data from Firebase:", error);
                return null;
            }
        }

        window.getFirebaseData = getFirebaseData;
    </script>
</head>
<body>
    <div class="top-bar">
        <span id="gameTypeDisplay" class="setting-value-display menu"></span>
        <span id="playTypeDisplay" class="setting-value-display menu"></span>
        <span id="playerCountDisplay" class="setting-value-display menu"></span>
        <span id="liarCountDisplay" class="setting-value-display menu"></span>
        <span id="missionInfoDisplay" class="setting-value-display menu">ë‚˜ì˜ ë‹¨ì–´</span>
    </div>
    
    <div class="grid-container" id="grid"></div>
    
    <div class="bottom-bar">
        <span id="refreshBtn" class="setting-value-display menu">ìƒˆë¡œê³ ì¹¨</span>
        <span id="startGameBtn" class="setting-value-display menu">ê²Œì„ ì‹œì‘</span>
        <span id="nextRoundBtn" class="menu">ë‹¤ìŒ ë¼ìš´ë“œ</span>
        <span class="menu">íˆ¬í‘œ ì‹œì‘</span> 
        <span class="menu">ë°œì–¸ ì‹œì‘</span>
    </div>

    <script>
        const Q = sel => document.querySelector(sel);
        const QQ = sel => Array.from(document.querySelectorAll(sel));
        const Elem = (tag, cls) => {
            const el = document.createElement(tag);
            if (cls) el.className = cls;
            return el;
        };
        const vector = (n, fn) => Array.from({ length: n }, (_, i) => fn(i));
        const randz = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        const container = Q('#grid');

        const ë™ë¬¼ = ['ì›ìˆ­ì´','ì—¬ìš°','ë¶€ì—‰ì´','ê³°','í† ë¼','ë¼ì§€','ê°•ì•„ì§€','ê³ ì–‘ì´','í–„ìŠ¤í„°','í­ê·„','ì‚¬ì','í˜¸ë‘ì´','íŒë‹¤','ë„ˆêµ¬ë¦¬','ë‹¤ëŒì¥','ì–¼ë£©ë§','ê³ ìŠ´ë„ì¹˜','ì½”ë¼ë¦¬','ì•…ì–´','ìº¥ê±°ë£¨'];
        const íŒ»ë§ = ['ë…¸ë§', 'ì†Œì‹ ì¢Œ', 'ë¼ê²°ì', 'ì–‘ë°œ', 'êº¾ê¸°', 'í˜¼ë€ì¢Œ', 'í¬ê´„', 'ë‹µì½ê¸°', 'ë¹ŒëŸ°', '???'];
        const ì´ëª¨ì§€ì„ íƒì§€ = ['ğŸš«','â­•','âŒ','ğŸ˜ˆ','ğŸ”´','ğŸŸ ','ğŸ¤”','ğŸŸ¡','ğŸŸ£','ğŸ˜‡','ğŸŸ¢','ğŸ”µ'];
        const ì´ëª¨ì§€ê°ë„ = [26, 58, 91];
        const ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ = 45;
        
        const gameTypes = ['ë¼ì´ì–´ê²Œì„', 'ì–´ëª½ì–´ìŠ¤', 'ë§ˆí”¼ì•„', 'ê¸°ì‚¬ì™€ ê±´ë‹¬'];
        let currentGameType = gameTypes[0];
        const playTypes = ['ëœë¤ ê²Œì„', 'ì—í”¼ì†Œë“œ'];
        let currentplayType = playTypes[0];
        let playerCountState = 8;
        let liarCountState = 1;
        const minPlayerCount = 4, maxPlayerCount = 12;
        const maxLiarCount = 2; // ë¼ì´ì–´ ìµœëŒ€ ì¸ì›ìˆ˜
        let ë™ë¬¼ì¸ë±ìŠ¤ = []; // ì¤‘ë³µ ë°©ì§€ìš©
        let currentRound = 0; // í˜„ì¬ ë¼ìš´ë“œ (0: ê²Œì„ ì‹œì‘ ì „, 1: opening, 2: elaborate1, 3: elaborate2)

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        async function gameStart() {
            currentRound = 0; // ê²Œì„ ì‹œì‘ ì‹œ ë¼ìš´ë“œ ì´ˆê¸°í™”

            // 1. ë¼ì´ì–´ ë¶€ì—¬
            const liarIndices = randzSet(playerCountState, liarCountState);

            // 2. íŒŒì´ì–´ë² ì´ìŠ¤ DBì—ì„œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
            const dbData = await window.getFirebaseData('liar_groups/0096');
            if (!dbData) {
                alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                return;
            }
            const allStatements = dbData.statements;

            // 3. ê³ ìœ í•œ unique ID ëª©ë¡ ìƒì„± ë° í• ë‹¹
            let distinctUniqueIds = [...new Set(allStatements.map(s => s.unique))];
            if (distinctUniqueIds.length < playerCountState) {
                alert('í”Œë ˆì´ì–´ì—ê²Œ í• ë‹¹í•  ê³ ìœ í•œ ë°œì–¸ IDê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.');
                return;
            }
            distinctUniqueIds = shuffleArray(distinctUniqueIds);
            const assignedUniqueIds = distinctUniqueIds.slice(0, playerCountState);

            // 4. ì£¼ì œì–´ 2ê°œ ëœë¤ ì„ íƒ
            const wordIndices = randzSet(dbData.words.length, 2);
            const citizenWord = dbData.words[wordIndices[0]];
            const liarWord = dbData.words[wordIndices[1]];
            
            // 5. ë°œì–¸ì„ ì‰½ê²Œ ì°¾ê¸° ìœ„í•œ ë§µ ìƒì„±
            const statementMap = new Map();
            allStatements.forEach(stmt => {
                if (!statementMap.has(stmt.unique)) {
                    statementMap.set(stmt.unique, {});
                }
                statementMap.get(stmt.unique)[stmt.subject] = stmt;
            });

            // 6. ê° í”Œë ˆì´ì–´ì—ê²Œ ë°œì–¸ í• ë‹¹
            const players = QQ('.statement-container');
            players.forEach((player, i) => {
                const uniqueId = assignedUniqueIds[i];
                let assignedStatement;
                let role, word;

                if (liarIndices.includes(i)) {
                    role = 'liar';
                    player.classList.add('liar'); // ë¼ì´ì–´ì—ê²Œ 'liar' í´ë˜ìŠ¤ ì¶”ê°€
                    word = liarWord;
                } else {
                    role = 'citizen';
                    player.classList.remove('liar'); // ë¼ì´ì–´ í´ë˜ìŠ¤ ì œê±° (í˜¹ì‹œ ëª¨ë¥¼ ì´ˆê¸°í™”)
                    word = citizenWord;
                }

                const possibleStatements = statementMap.get(uniqueId);
                if (possibleStatements && possibleStatements[word]) {
                    assignedStatement = possibleStatements[word];
                } else {
                    // í•´ë‹¹ uniqueIdì™€ subjectì— ë§ëŠ” ë°œì–¸ì´ ì—†ëŠ” ê²½ìš°, ë‹¤ë¥¸ ë°œì–¸ìœ¼ë¡œ ëŒ€ì²´ (ì˜¤ë¥˜ ë°©ì§€)
                    const fallbackStatements = allStatements.filter(s => s.subject === word && !assignedUniqueIds.includes(s.unique));
                    assignedStatement = fallbackStatements[randz(0, fallbackStatements.length - 1)] || { opening: "ë°œì–¸ ì—†ìŒ", elaborate1: "ë°œì–¸ ì—†ìŒ", elaborate2: "ë°œì–¸ ì—†ìŒ", unique: "N/A", author: "ì•Œ ìˆ˜ ì—†ìŒ" };
                    console.warn(`ëŒ€ì²´ ë°œì–¸ í• ë‹¹: player ${i}, uniqueId ${uniqueId}, word ${word}`);
                }
                
                player.dataset.role = role;
                player.dataset.word = word;
                
                // ì €ì ì •ë³´ í¬í•¨í•˜ì—¬ statements ë°°ì—´ ìƒì„±
                const statementsWithAuthor = [assignedStatement.opening, assignedStatement.elaborate1, assignedStatement.elaborate2]
                    .filter(Boolean)
                    .concat(`ì§€ì€ì´: ${assignedStatement.author || "ì•Œ ìˆ˜ ì—†ìŒ"}`);
                
                player.dataset.statements = JSON.stringify(statementsWithAuthor);
                player.dataset.unique = assignedStatement.unique;
                // player.dataset.authorëŠ” ë” ì´ìƒ ì§ì ‘ ì‚¬ìš©ë˜ì§€ ì•Šì§€ë§Œ, ë””ë²„ê¹…ì„ ìœ„í•´ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                // player.dataset.author = assignedStatement.author || "ì•Œ ìˆ˜ ì—†ìŒ";

                player.dataset.currentStatementIndex = 0; // ì´ˆê¸° ë°œì–¸ ì¸ë±ìŠ¤ ì„¤ì •
                updateBubbleContent(player); // ë°œì–¸ ë‚´ìš© ì—…ë°ì´íŠ¸
            });
            currentRound = 1; // ê²Œì„ ì‹œì‘ê³¼ í•¨ê»˜ 1ë¼ìš´ë“œë¡œ ì„¤ì •
        }
        
        function updateBubbleContent(playerElement) {
            const bubble = playerElement.querySelector('.bubble');
            const statementTextEl = bubble.querySelector('.statement-text');
            // authorDisplayElì€ ë” ì´ìƒ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
            const prevButton = bubble.querySelector('.prev-button');
            const nextButton = bubble.querySelector('.next-button');

            const statements = JSON.parse(playerElement.dataset.statements);
            let currentStatementIndex = parseInt(playerElement.dataset.currentStatementIndex, 10);
            
            // í˜„ì¬ ë°œì–¸ í‘œì‹œ
            if (currentStatementIndex < statements.length) {
                statementTextEl.textContent = statements[currentStatementIndex];
            } else {
                statementTextEl.textContent = "ë” ì´ìƒ ë°œì–¸ì´ ì—†ìŠµë‹ˆë‹¤.";
            }

            // ë²„íŠ¼ ê°€ì‹œì„± ì—…ë°ì´íŠ¸
            prevButton.style.color = currentStatementIndex > 0 ? 'black' : 'gray';
            nextButton.style.color = currentStatementIndex < statements.length - 1 ? 'black' : 'gray';
        }

        function showPreviousStatement(playerElement) {
            let currentStatementIndex = parseInt(playerElement.dataset.currentStatementIndex, 10);
            if (currentStatementIndex > 0) {
                currentStatementIndex--;
                playerElement.dataset.currentStatementIndex = currentStatementIndex;
                updateBubbleContent(playerElement);
            }
        }

        function showNextStatement(playerElement) {
            const statements = JSON.parse(playerElement.dataset.statements);
            let currentStatementIndex = parseInt(playerElement.dataset.currentStatementIndex, 10);
            if (currentStatementIndex < statements.length - 1) { // ë§ˆì§€ë§‰ ë°œì–¸ (ì €ì ì •ë³´) ì§ì „ê¹Œì§€ë§Œ ì´ë™ ê°€ëŠ¥
                currentStatementIndex++;
                playerElement.dataset.currentStatementIndex = currentStatementIndex;
                updateBubbleContent(playerElement);
            }
        }

        function nextRound() {
            currentRound++;
            const players = QQ('.statement-container');
            players.forEach(player => {
                // ë‹¤ìŒ ë¼ìš´ë“œ ë²„íŠ¼ í´ë¦­ ì‹œëŠ” í•­ìƒ ë‹¤ìŒ ë°œì–¸ìœ¼ë¡œ ì´ë™
                showNextStatement(player);
            });
        }

        function setupEmojiInterface(profileEl) {
            const ìƒíƒœ = { ì´ëª¨ì§€ë“¤: [] };
            const ê°±ì‹  = () => {
                profileEl.querySelectorAll('.emoji-button').forEach(el => el.remove());
                ìƒíƒœ.ì´ëª¨ì§€ë“¤.forEach((emj, i) => {
                    const rad = Math.PI * ì´ëª¨ì§€ê°ë„[i] / 180;
                    const btn = Elem('div', 'emoji-button');
                    btn.textContent = emj;
                    btn.style.left = `${50 + ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.sin(rad)}%`;
                    btn.style.top = `${50 - ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.cos(rad)}%`;
                    btn.addEventListener('click', e => ì—´ê¸°(i, e));
                    profileEl.appendChild(btn);
                });
                if (ìƒíƒœ.ì´ëª¨ì§€ë“¤.length < ì´ëª¨ì§€ê°ë„.length) {
                    const i = ìƒíƒœ.ì´ëª¨ì§€ë“¤.length;
                    const rad = Math.PI * ì´ëª¨ì§€ê°ë„[i] / 180;
                    const plus = Elem('div', 'emoji-button');
                    plus.textContent = 'â•';
                    plus.style.left = `${50 + ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.sin(rad)}%`;
                    plus.style.top = `${50 - ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.cos(rad)}%`;
                    plus.addEventListener('click', e => ì—´ê¸°(i, e));
                    profileEl.appendChild(plus);
                }
            };
            const ì—´ê¸° = (idx, ev) => {
                ev.stopPropagation();
                QQ('.emoji-picker').forEach(p => p.remove());
                const picker = Elem('div', 'emoji-picker');
                ì´ëª¨ì§€ì„ íƒì§€.forEach(emj => {
                    const span = Elem('span');
                    span.textContent = emj;
                    span.addEventListener('click', e => {
                        e.stopPropagation();
                        if (emj === 'ğŸš«') ìƒíƒœ.ì´ëª¨ì§€ë“¤.splice(idx, 1);
                        else ìƒíƒœ.ì´ëª¨ì§€ë“¤[idx] = emj;
                        ê°±ì‹ ();
                        picker.remove();
                    });
                    picker.appendChild(span);
                });
                picker.style.left = ev.clientX + 'px';
                picker.style.top = ev.clientY + 'px';
                document.body.appendChild(picker);
            };
            ê°±ì‹ ();
            profileEl._emojiUpdater = ê°±ì‹ ;
        }

        function createCard(index, animalIndex) {
            const wrapper = Elem('div', 'statement-container');
            const profile = Elem('div', 'profile');
            const circle = Elem('div', 'circle');
            const img = Elem('img');
            img.src = `../ë¦¬ì†ŒìŠ¤/ë™ë¬¼${animalIndex}.png`;
            circle.appendChild(img);
            profile.appendChild(circle);

            setupEmojiInterface(profile);

            const bubble = Elem('div', 'bubble');
            
            const statementTextEl = Elem('div', 'statement-text');
            statementTextEl.textContent = ë™ë¬¼[animalIndex]; // ì´ˆê¸° í…ìŠ¤íŠ¸ (ê²Œì„ ì‹œì‘ ì‹œ ë³€ê²½ë¨)
            bubble.appendChild(statementTextEl);

            // authorDisplayEl ì‚­ì œë¨
            
            // Navigation controls container
            const bubbleNavControls = Elem('div', 'bubble-nav-controls');
            const prevButton = Elem('span', 'prev-button');
            prevButton.textContent = 'â—€';
            prevButton.addEventListener('click', () => showPreviousStatement(wrapper)); // wrapper (playerElement) ì „ë‹¬
            bubbleNavControls.appendChild(prevButton);

            const nextButton = Elem('span', 'next-button');
            nextButton.textContent = 'â–¶';
            nextButton.addEventListener('click', () => showNextStatement(wrapper)); // wrapper (playerElement) ì „ë‹¬
            bubbleNavControls.appendChild(nextButton);
            bubble.appendChild(bubbleNavControls);

            const demo = íŒ»ë§[randz(0, íŒ»ë§.length - 1)];
            const placard = Elem('div', 'placard');
            placard.textContent = demo;
            placard.dataset.selected = demo;
            bubble.appendChild(placard); // íŒ»ë§ì„ bubbleì˜ ìì‹ìœ¼ë¡œ ì¶”ê°€

            wrapper.appendChild(profile);
            wrapper.appendChild(bubble);
            container.appendChild(wrapper);

            placard.addEventListener('click', e => {
                e.stopPropagation();
                QQ('.placard.expanded').forEach(p => {
                    p.classList.remove('expanded');
                    p.removeAttribute('style');
                    p.textContent = p.dataset.selected;
                });
                const rect = placard.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                placard.classList.add('expanded');
                placard.style.left = `${centerX - 125}px`;
                placard.style.top = `${centerY - 30}px`;
                placard.innerHTML = '';
                for (let row = 0; row < 2; row++) {
                    const rowDiv = Elem('div', 'choice-row');
                    íŒ»ë§.slice(row * 5, (row + 1) * 5).forEach(text => {
                        const span = Elem('span', 'choice');
                        span.innerHTML = (text === placard.dataset.selected) ? `<strong>${text}</strong>` : text;
                        span.addEventListener('click', e => {
                            e.stopPropagation();
                            placard.textContent = text;
                            placard.dataset.selected = text;
                            placard.classList.remove('expanded');
                            placard.removeAttribute('style');
                        });
                        rowDiv.appendChild(span);
                    });
                    placard.appendChild(rowDiv);
                }
                QQ('.placard.expanded, .emoji-picker').forEach(expanded => {
                const offset = expanded.getBoundingClientRect();
                const shiftX = Math.min(0, offset.left - 10);
                const shiftY = Math.min(0, offset.top - 10);
                const overX = offset.right - window.innerWidth + 10;
                const overY = offset.bottom - window.innerHeight + 10;
                if (shiftX < 0 || overX > 0)
                    expanded.style.left = `calc(${expanded.style.left} - ${shiftX || overX}px)`;
                if (shiftY < 0 || overY > 0)
                    expanded.style.top = `calc(${expanded.style.top} - ${shiftY || overY}px)`;
                })
            });
        }

        function fillGrid() {
            container.innerHTML = '';
            ë™ë¬¼ì¸ë±ìŠ¤ = randzSet(ë™ë¬¼.length, playerCountState);
            for (let i = 0; i < playerCountState; i++) {
                createCard(i, ë™ë¬¼ì¸ë±ìŠ¤[i]);
            }
            updateLayoutBasedOnColumn();
        }

        function randzSet(max, count) {
            const pool = Array.from({ length: max }, (_, i) => i);
            const result = [];
            while (result.length < count) {
                const idx = randz(0, pool.length - 1);
                result.push(pool.splice(idx, 1)[0]);
            }
            return result;
        }

        function closeAllCustomDropdowns() {
            QQ('.custom-dropdown-options').forEach(dropdown => dropdown.remove());
        }

        function openCustomDropdown(displayElement, type) {
            closeAllCustomDropdowns();

            const optionsDiv = Elem('div', 'custom-dropdown-options');
            let options;

            if (type === 'player') {
                const min = minPlayerCount;
                const max = maxPlayerCount;
                options = Array.from({ length: max - min + 1 }, (_, i) => min + i);
            } else if (type === 'liar') {
                const min = 1;
                const max = Math.min(Math.floor((playerCountState - 1) / 2), maxLiarCount);
                options = Array.from({ length: max - min + 1 }, (_, i) => min + i);
            } else if (type === 'gameType') {
                options = gameTypes;
            } else if (type === 'playType') {
                options = playTypes;
            }

            if (type === 'gameType' || type === 'playType') {
                optionsDiv.classList.add('full-width-options');
            }

            options.forEach(option => {
                const optionSpan = Elem('span', 'custom-dropdown-option');
                optionSpan.textContent = option;
                optionSpan.dataset.value = option;
                optionSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newValue = e.target.dataset.value;

                    if (type === 'player') {
                        playerCountState = parseInt(newValue, 10);
                        populatePlayerDisplay();
                        populateLiarDisplay();
                        fillGrid();
                    } else if (type === 'liar') {
                        liarCountState = parseInt(newValue, 10);
                        populateLiarDisplay();
                    } else if (type === 'gameType') {
                        currentGameType = newValue;
                        populateGameTypeDisplay();
                    } else if (type === 'playType') {
                        currentplayType = newValue;
                        populateplayTypeDisplay();
                    }
                    closeAllCustomDropdowns();
                });
                optionsDiv.appendChild(optionSpan);
            });

            const rect = displayElement.getBoundingClientRect();
            optionsDiv.style.top = `${rect.bottom}px`;
            optionsDiv.style.left = `${rect.left}px`;
            optionsDiv.style.width = `${rect.width}px`;
            document.body.appendChild(optionsDiv);
        }

        function populateGameTypeDisplay() {
            Q('#gameTypeDisplay').textContent = `${currentGameType}`;
        }
        
        function populateplayTypeDisplay() {
            Q('#playTypeDisplay').textContent = `${currentplayType}`;
        }

        function populatePlayerDisplay() {
            Q('#playerCountDisplay').textContent = `ì¸ì›ìˆ˜: ${playerCountState}`;
        }

        function populateLiarDisplay() {
            const maxLiars = Math.min(Math.floor((playerCountState - 1) / 2), maxLiarCount);
            if (liarCountState < 1 || liarCountState > maxLiars) {
                liarCountState = 1;
            }   
            Q('#liarCountDisplay').textContent = `ë¼ì´ì–´: ${liarCountState}`;
        }

        Q('#refreshBtn').addEventListener('click', fillGrid);   
        Q('#startGameBtn').addEventListener('click', gameStart);
        Q('#nextRoundBtn').addEventListener('click', nextRound); // ë‹¤ìŒ ë¼ìš´ë“œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        Q('#gameTypeDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'gameType'));
        Q('#playTypeDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'playType'));
        Q('#playerCountDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'player'));
        Q('#liarCountDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'liar'));

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.custom-dropdown-options') && !e.target.closest('.setting-value-display')) {
                closeAllCustomDropdowns();
            }
            // íŒ»ë§ í™•ì¥ ë‹«ê¸°
            const expandedPlacard = Q('.placard.expanded');
            if (expandedPlacard && !e.target.closest('.placard.expanded')) {
                expandedPlacard.classList.remove('expanded');
                expandedPlacard.removeAttribute('style');
                expandedPlacard.textContent = expandedPlacard.dataset.selected;
            }
        });

        function getColumnCount() {
            const items = QQ('.statement-container');
            if (items.length === 0) return 0;
            const left = items.map(x => x.offsetLeft);
            let cols = 0;
            while (cols < left.length && left.indexOf(left[cols]) === cols) {
                cols++;
            }
            return cols;
        }

        function updateLayoutBasedOnColumn() {
            QQ('.reverse').forEach(x => x.classList.remove('reverse'));
            const count = getColumnCount();
            if (count === 0) return;
            QQ('.statement-container').forEach((el, i) => {
                if (count === 2 && i % 2 === 1) { // ì§ìˆ˜ ì—´ì¼ ë•Œ ì§ìˆ˜ ë²ˆì§¸ ìì‹ë“¤ reverse
                    el.classList.add('reverse');
                }
            });
        }
        
        window.addEventListener('resize', () => {
            QQ('.profile').forEach(p => p._emojiUpdater && p._emojiUpdater());
            updateLayoutBasedOnColumn();
        });
        
        populateGameTypeDisplay();
        populateplayTypeDisplay();
        populatePlayerDisplay();
        populateLiarDisplay();
        fillGrid();
    </script>
</body>
</html>