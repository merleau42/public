//! 레거시 코드
notate = function (r, base=range(r)) { return (this<r) ? [base[this]] : [...floor(this / r).notate(r, base), base[this % r]] };
notate = function (r, p=this.len(r), b=range(r)) {return vector(p-1).reduce((s,_,i)=>[floor(s[0]/r), b[s[0]%r], ...s.slice(1)],[this])},
notate = function (b) { [base,rad] = b[0] ? [b,b.len()] : [vector(b, String),b]; return vector(p-1).reduce(s=>[floor(s[0]/r), b[s[0]%r], ...s.slice(1)],[this]).update(0,x=>b[x])},

//! 풀이 과정 (브론즈5)
//: 28113
// n  > b ---> 걸어서 지하철 잡을 수 없다, 버스를 탄다
// n <= b ---> 걸어서 지하철 잡을 수 있다, 버스랑 지하철 중에 먼저 오는 것을 탄다
// 		a  < b ---> 버스를 탄다
//		a == b ---> 아무거나 탄다
//		a  > b ---> 지하철을 탄다
(n > b ? 'Bus' : a < b ? 'Bus' : a == b ? 'Anything' : a > b ? 'Subway' : '').log()

//! 풀이 과정 (브론즈4)
//: 5532
//	L == 남은방학
//	ceil(B / D) == 수학 소요시간
//	ceil(A / C) == 국어 소요시간
//	숙제하는 날 == max(수학, 국어)
//	노는 날 == 남은 방학 - 숙제하는 날
log( l - max( ceil(b / d), ceil(a / c) ) );

//: 14652
//		0	1	2	3
//	\__________________
//	0|	0	1	2	3
//	1|	4	5	6	7
//	2|	8	9	10	11
//
//	행좌표 == floor(K / 열규모)
//	열좌표 == floor(K % 열규모)

//: 17362
// f(n) == n에 해당하는 손가락 번호
//
//	f(n)|	n		|	n		|	n		|	(n-1)%8
//	1엄	|	1		|	9		|	17		|	0	
//	2검	|	2	8	|	10	16	|	18	24	|	1	7
//	3중	|	3	7	|	11	15	|	19	23	|	2	6
//	4약	|	4	6	|	12	14	|	20	22	|	3	5
//	5새	|	5		|	13		|	21		|	4
//
// f(n) = 1 + (n-1)%8
[1,2,3,4,5,4,3,2][((input()-1) % 8)].log();

//: 13866
// 가정: a>b>c>d

// 경우1: (a,b) vs (c,d) ===> a + b - c - d
// 경우2: (a,c) vs (b,d) ===> a + c - b - d
// 경우3: (a,d) vs (b,c) ===> a + d - b - c

// 경우1: a + (b - c) - d		--- 괄호가 양수, 나머지항 동일
// 경우2: a + (c - b) - d		--- 괄호가 음수, 나머지항 동일
// --->  경우1 > 경우2

// 경우2: a + (c - d) - b		--- 괄호가 양수, 나머지항 동일
// 경우3: a + (d - c) - b		--- 괄호가 음수, 나머지항 동일
// --->  경우2 > 경우3

// 두 팀의 능력 차이: 경우1 > 경우2 > 경우3
[w, x, y, z] = input(' ').map(Number).toSorted((a,b)=>b-a);
log(abs(w + z - x - y)) //13866

//: 14924
//	D = 처음 기차 사이의 거리
//	2t의 속도로 D에서 거리가 줄어듦.
//	D/2t = 열차 충돌 시간 = 파리가 이동한 시간
//	p * D/2t = 파리가 이동한 거리
[t, p, d] = input(' ').mapleaves(Number); log( p * d/(2*t) )


//: 11943
//	사과(a/A), 오렌지(b/B)
//	초기:	ab	AB
//	상태 1 또는 2가 목표. 두 상태 중의 최솟값.
//	상태1:	aA	bB		<---	횟수 = 좌우(b) + 우좌(A) = b + A
//	상태2:	bB	aA		<---	횟수 = 좌우(a) + 우좌(B) = a + B

//: 16204
//	M을 기준점으로 둠.
//
//	M = K 인 경우
//	OOOOOO | XXXXXX
//	OOOOOO | XXXXXX
//	N개의 카드 전체가 앞뒤가 동일함.
//	전체에서 0개를 (m-k) 제외한 값과 공교롭게도 같음
//
//	M > K 인 경우
//	OOOOOO | XXXXXX
//	OOOOXX | XXXXXX		---	m-k 만큼 왼쪽으로 X가 늘어남
//	m-k를 제외한 모든 카드가 앞뒤가 동일함.
//
//	M < K 인 경우
//	OOOOOO | XXXXXX
//	OOOOOO | OOXXXX		--- k-m 만큼 오른쪽으로 O가 늘어남
//	k-m을 제외한 모든 카드가 앞뒤가 동일함.
//
//	총 N - |M - K| 개

//: 25494
// 조건
// 1 <= x,y,z
// x%y == y%z == z%x

// 몫과 나머지의 관계에 의해서 다음을 얻는다.
// x = ya + r
// y = zb + r
// z = xc + r

// 대입법으로 다음을 얻는다.
// x = abcx + abr + ar + r
// y = abcy + bcr + br + r
// z = abcz + acr + cr + r

// 합산하고, 이항하고, 정리하여 다음을 얻는다.
// (x + y + z)(1 - abc)
// = r(ab + bc + ac + a + b + c + 1)

// 우변은 0이상이고, x+y+z는 양수이다.
// 좌변이 음수가 되지않으려면 abc <= 1 이다.
// abc <= 1 을 만족하는 자연수는 a=b=c=1 이다.
// abc = 1 이므로, 좌항은 0이되며, r=0 이다.

// a=b=c=1과 r=0을 원래의 식에 대입하면,
// x=y=z가 성립합니다


// x=y=z가 성립하므로, 순서쌍의 모양은 (a,a,a)가 됩니다.
// (1,1,1) 에서부터 (2,2,2) (3,3,3) 으로 상승하는데,
// 이것의 상한선은 x,y,z 중 최솟값에 걸리게 됩니다.

// 종합하면,
// (x,y,z) 모든 순서쌍 중에서, 문제 조건을 만족하는 것은 (a,a,a) 모양의 순서쌍입니다.
// (a,a,a) 순서쌍의 갯수는 min( x,y,z )와 같습니다.

//: 25494 (2)
// 다른 증명

// 자연수의 나눗셈은 다음과 같이 표현할 수 있습니다

// A ÷ B (피제수 ÷ 제수)
// A = BQ + R (피제수 = 제수×몫 + 나머지)
// 다음의 성질이 성립합니다

// 0 < 피제수(A), 제수(B)
// 0 <= 몫(Q)
// 0 <= 나머지(R) <  제수(B) 
// 0 <= 나머지(R) <= 피제수(A)
// (피제수 = 제수) ⇔ (나머지 = 0)
// (피제수 < 제수) ⇔ (나머지 = 피제수) ⇔ (몫 = 0)
// 문제 조건

// R = (x % y) = (y % x) = (x % z)
// 제수 y, x, z 는 나머지보다 큽니다.

// R < x
// R < y
// R < z
// 피제수 x, y, z 중 어느 것도, 자기 순서의 연산에서 나머지와 동일하지 않습니다.

// (x % y) < x
// (y % z) < y
// (z % x) < z
// 피제수와 나머지가 같은 경우는, 맨 위의 성질에서 (피제수 < 제수) 뿐입니다.

// 따라서, 언제나 (피제수 >= 제수) 가 성립합니다.

// x >= y
// y >= z
// z >= x
// x >= y >= z >= x 에서, 다음이 성립합니다

// x = y = z


//: 27590
// 해님은 A년 전에 정상 위치, B년 마다 정상 위치
// 달님은 C년 전에 정상 위치, D년 마다 정상 위치
// 해님이 정상 위치인 연도 == [ (B - A) + B*i]  -----  i = 0, 1, 2, 3, 4, ..., N
// 달님이 정상 위치인 연도 == [ (D - C) + D*j]  -----  j = 0, 1, 2, 3, 4, ..., N
// 일식 조건: A + B*i == C + D*j  -----  [i,j] 공간의 원소 하나를 활용하는 함수.



//: ???
// "5280의 애너그램 중 30의 배수를 만족하는 최댓값"

// // 완전탐색으로 푼다면
// number.anagrams.filter('30의배수').filter(max)


// // 조건을 활용해서 후보를 줄인다면
// number.filter('30의배수').anagrams.filter(max)