//! 레거시 코드
notate = function (r, base=range(r)) { return (this<r) ? [base[this]] : [...floor(this / r).notate(r, base), base[this % r]] };

//! 풀이 과정 (브론즈5)
//: 28113
// n  > b ---> 걸어서 지하철 잡을 수 없다, 버스를 탄다
// n <= b ---> 걸어서 지하철 잡을 수 있다, 버스랑 지하철 중에 먼저 오는 것을 탄다
// 		a  < b ---> 버스를 탄다
//		a == b ---> 아무거나 탄다
//		a  > b ---> 지하철을 탄다
(n > b ? 'Bus' : a < b ? 'Bus' : a == b ? 'Anything' : a > b ? 'Subway' : '').log()

//! 풀이 과정 (브론즈4)
//: 5532
//	L == 남은방학
//	ceil(B / D) == 수학 소요시간
//	ceil(A / C) == 국어 소요시간
//	숙제하는 날 == max(수학, 국어)
//	노는 날 == 남은 방학 - 숙제하는 날
log( l - max( ceil(b / d), ceil(a / c) ) );

//: 14652
//		0	1	2	3
//	\__________________
//	0|	0	1	2	3
//	1|	4	5	6	7
//	2|	8	9	10	11
//
//	행좌표 == floor(K / 열규모)
//	열좌표 == floor(K % 열규모)

//: 11943
//	사과(a/A), 오렌지(b/B)
//	초기:	ab	AB
//	상태 1 또는 2가 목표. 두 상태 중의 최솟값.
//	상태1:	aA	bB		<---	횟수 = 좌우(b) + 우좌(A) = b + A
//	상태2:	bB	aA		<---	횟수 = 좌우(a) + 우좌(B) = a + B

//: 17362
// f(n) == n에 해당하는 손가락 번호
//
//	f(n)|	n		|	n		|	n		|	(n-1)%8
//	1엄	|	1		|	9		|	17		|	0	
//	2검	|	2	8	|	10	16	|	18	24	|	1	7
//	3중	|	3	7	|	11	15	|	19	23	|	2	6
//	4약	|	4	6	|	12	14	|	20	22	|	3	5
//	5새	|	5		|	13		|	21		|	4
//
// f(n) = 1 + (n-1)%8
[1,2,3,4,5,4,3,2][((input()-1) % 8)].log();

//: 13866
// 가정: a>b>c>d

// 경우1: (a,b) vs (c,d) ===> a + b - c - d
// 경우2: (a,c) vs (b,d) ===> a + c - b - d
// 경우3: (a,d) vs (b,c) ===> a + d - b - c

// 경우1: a + (b - c) - d		--- 괄호가 양수, 나머지항 동일
// 경우2: a + (c - b) - d		--- 괄호가 음수, 나머지항 동일
// --->  경우1 > 경우2

// 경우2: a + (c - d) - b		--- 괄호가 양수, 나머지항 동일
// 경우3: a + (d - c) - b		--- 괄호가 음수, 나머지항 동일
// --->  경우2 > 경우3

// 두 팀의 능력 차이: 경우1 > 경우2 > 경우3
[w, x, y, z] = input(' ').map(Number).toSorted((a,b)=>b-a);
log(abs(w + z - x - y)) //13866