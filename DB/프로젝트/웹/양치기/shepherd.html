<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>문제 뷰어</title>
    <link rel="stylesheet" href="style.css" />
  </head>
<body class="TRUE showTag showTier showSubTag"> 
  <header>
    <div class="controls">
      <label>검색:</label><input id="searchInput" type="text" style="width:12%" placeholder="...">
      <label>티어:</label><input type="checkbox" id="toggleTier" checked />
      <input id="tierMin" type="number" min="1" max="30" placeholder="최소" style="width:45px;" /> ~
      <input id="tierMax" type="number" min="1" max="30" placeholder="최대" style="width:45px;" />
      <label>태그:</label><input type="checkbox" id="toggleTag" checked />
      <button id="toggleSubTag">부태그</button>
      <label>중복:</label><input type="checkbox" id="toggleDuple" />
      <label>해답:</label><input type="checkbox" id="toggleSolution" />
      <label id="cardCount">문제: 0</label>
    </div>
    <div id="toc"></div>
  </header>
  <main>
    <div id="deck"></div>
  </main>
  <script> 
    let Q = s => document.querySelector(s);
    let QQ = s => [...document.querySelectorAll(s)];

    let state = {
      problems: [], categories: [], problemElements: [], renderMax: 30,
      showSolution: false, showTier: true, showTag: true,
      showDuple: false, showSubTag: false,
      tagFilters: {}, tierMin: null, tierMax: null,
    };

    function createElement(tag, className, content) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (content) el.textContent = content;
      return el;
    }

    function parseTags(tags) {
      const main = tags.filter(t => t.endsWith('!')).map(t => t.slice(0, -1));
      const sub = tags.map(t => t.endsWith('!') ? t.slice(0, -1) : t).filter(t => !main.includes(t));
      return { main, sub };
    }

    function renderCategoryNav(categories, container) {
      container.innerHTML = '';
      if (!state.showTag) return;
      categories.forEach(({ group, tags }) => {
        const groupBtn = createElement('button', `tag-button group-button ${state.tagFilters[group] || ''}`, group);
        groupBtn.addEventListener('click', e => { e.preventDefault(); toggleTag(group, 'include'); });
        groupBtn.addEventListener('contextmenu', e => { e.preventDefault(); toggleTag(group, 'exclude'); });
        container.appendChild(groupBtn);

        tags.forEach(tag => {
          const btn = createElement('button', `tag-button ${state.tagFilters[tag] || ''}`, tag);
          btn.addEventListener('click', e => { e.preventDefault(); toggleTag(tag, 'include'); });
          btn.addEventListener('contextmenu', e => { e.preventDefault(); toggleTag(tag, 'exclude'); });
          container.appendChild(btn);
        });
      });
    }

    function toggleTag(tag, mode) {
      const current = state.tagFilters[tag];
      state.tagFilters[tag] = current === mode ? null : mode;
      renderCategoryNav(state.categories, Q('#toc'));
      renderProblems();
    }

    function createProblemElements(container) {
      container.innerHTML = '';
      state.problemElements = [];

      state.problems.forEach(problem => {
        const card = createElement('div', 'card');
        card.dataset.id = problem.id;

        const 급간 = ['', '브론즈', '실버', '골드', '플래', '다이아', '루비'][Math.ceil(problem.tier / 5)];
        const tier = createElement('span', `tier ${급간}`, `${급간}${5 - (problem.tier - 1) % 5}`);
        card.append(tier);

        const summary = createElement('p', 'summary', `${problem.summary} `);
        card.append(summary);

        const { main, sub } = parseTags(problem.tags || []);
        if (problem.tags?.length === 0) card.append(createElement('span', 'tag sub-tag', '#미분류'));


        const solution = createElement('p', 'solution', problem.solution1 || '');
        const hr = createElement('hr', 'hr');
        card.append(hr, solution);
        
        const tagbox = createElement('div', 'tagbox');
        main.forEach(tag => tagbox.append(createElement('span', 'tag main-tag', `#${tag}`)));
        sub.forEach(tag => tagbox.append(createElement('span', 'tag sub-tag', `#${tag}`)));
        card.append(tagbox);

        if (problem.dup) card.classList.add('dup');

        container.appendChild(card);
        state.problemElements.push({ element: card, problem });
      });
    }

    function renderProblems() {
      QQ('.draw').forEach(prev => prev.classList.toggle('draw'));

      const search = Q('#searchInput').value.toLowerCase();
      const min = parseInt(Q('#tierMin').value) || null;
      const max = parseInt(Q('#tierMax').value) || null;
      state.tierMin = min;
      state.tierMax = max;
      state.rendered = 0;
      state.valid = 0;

      state.problemElements.forEach(({ element, problem }) => {
        const tags = problem.tags || [];
        const tagList = tags.map(t => t.replace('!', ''));
        const resolved = tagList.length ? tagList : ['미분류'];

        const includes = Object.entries(state.tagFilters).filter(([_, m]) => m === 'include').map(([k]) => k);
        const excludes = Object.entries(state.tagFilters).filter(([_, m]) => m === 'exclude').map(([k]) => k);
        const inInclude = includes.every(tag => resolved.includes(tag));
        const inExclude = excludes.some(tag => resolved.includes(tag));
        const inSearch = problem.summary.toLowerCase().includes(search) || resolved.some(t => t.toLowerCase().includes(search));
        const inTier = (!min || problem.tier >= min) && (!max || problem.tier <= max);
        const valid = (!problem.dup || state.showDuple) && inInclude && !inExclude && inSearch && inTier;

        state.valid = state.valid + valid*1;
        if (valid && (state.rendered < state.renderMax)){
          element.classList.toggle('draw');
          state.rendered = state.rendered + 1;
        }
      });

      Q('#cardCount').textContent = `문제: ${state.valid}`;
    }

    document.addEventListener('DOMContentLoaded', async () => {
      const problems = await fetch('./problems.json').then(r => r.json());
      const categories = await fetch('./categories.json').then(r => r.json());
      state.problems = problems;
      state.categories = categories;
      renderCategoryNav(state.categories, Q('#toc'));
      createProblemElements(Q('#deck'));
      renderProblems();

      Q('#searchInput').addEventListener('input', renderProblems);
      Q('#tierMin').addEventListener('input', renderProblems);
      Q('#tierMax').addEventListener('input', renderProblems);
      Q('#toggleTier').addEventListener('change', e=>Q('body').classList.toggle('showTier'));
      Q('#toggleTag').addEventListener('change', e=>Q('body').classList.toggle('showTag'));
      Q('#toggleDuple').addEventListener('change', e=> {state.showDuple = !state.showDuple; renderProblems()} );
      Q('#toggleSolution').addEventListener('change', e=>Q('body').classList.toggle('showSolution'));
      Q('#toggleSubTag').addEventListener('click', e=>Q('body').classList.toggle('showSubTag'));
    });
  </script>
</body>
</html>
