//#include <unistd.h>
#include <io.h>
#include <stdio.h>
//!  가이드
//: 확장(컨쉬X)		 폴더(컨쉬E)		노미(옵쉬F)			접기(컨K0)		헤더(컨옵H)		설정(컨,)
//: 🔴미해결		🌸평가필요		   ❌문제발생		 ❗️컴파일에러		✅기계통과
//: 확장프로그램>> norminette, 42header, pdf, 

///!  SH00
////: z					--- 00✅cat으로 접근시 Z를 출력하는 파일
//// echo “Z"			터미널에 Z 출력
//// echo “Z"  > z		Z라는 값을 z라는 파일에 덮어쓰기
//// echo “Z" >> z		Z라는 값을 z라는 파일에 이어쓰기
//// echo는 자체적으로 파일끝에 \n을 추가해주므로 “Z" 까지만 입력해도 문제에서 요구하는 ‘새 줄’ 을 만들 수 있음
////		$> cat z
////		Z
////		$>
///:  testShell00.tar	--- 01✅파일의 [접근 권한, 바이트, 날짜, 이름] 을 설정하고, 압축하기
///:  과제의 요구사항
/// ls -l 으로 파일 정보를 확인할 수 있음
/// 	[파일유형]  [     권한 비트     ]  [하드링크수]  [소유권자]  [소유그룹]  [용량]  [날짜]  [파일명]
/// 	[일반파일]  [r—-]  [r-x]  [r-x]  [1링크]     [무관]     [무관]     [40]   [날짜]  [testShell00]
///		-r--r-xr-x 1 XX XX 40 Jun 1 23:42 testShell00
/// 파일의 유형:	-
/// 파일의 권한:	r—- r-x r-x
/// 파일의 용량:	40바이트
/// 파일의 날짜:	Jun 1   23:42
/// 파일의 이름:	testShell00
///ㅡ
///:  권한비트란?
/// 권한비트는 총 아홉비트로, 접근자 유형마다 달리 부여되는 권한을 나타냄
/// 유저,그룹,기타라는 세가지 유형마다 권한을 달리 부여할 수 있음
/// 세비트: U유저 ㅡ 읽기 (r / -)   쓰기 (w / -)   실행 (x / -)
/// 세비트: G그룹 ㅡ 읽기 (r / -)   쓰기 (w / -)   실행 (x / -)
/// 세비트: O기타 ㅡ 읽기 (r / -)   쓰기 (w / -)   실행 (x / -)
/// 읽기/쓰기/실행 가능하면 r/w/x을, 불가능하면 -을 표기함
///ㅡ
///:  파일의 유형 [-]
///		-r--r-xr-x 1 XX XX 40 Jun 1 23:42 testShell00
/// 맨 앞의 한글자가 파일의 유형에 해당함
/// 맨 앞이 d였다면 디렉토리를 의미함
/// 맨 앞이 -라는건 평범하게 일반 파일을 의미함. 그냥 아무 파일을 만들면 됨
///ㅡ
///:  파일의 용량 [40]  &&  파일의 이름 [testShell00]
/// 문자하나는 1바이트이고, 문자열에는 문자열의 끝을 나타내는 널문자가 '\0' 하나 붙어있다
/// echo를 통해서, 39개의 아무 문자열를 기입하여 파일을 만들면, 39+1 = 40바이트짜리 파일이 됨
///		echo “아무39자리문자열" > testShell00
///ㅡ
///:  파일의 권한 [r-- r-x r-x]
///    [일반파일]  [r—-]  [r-x]  [r-x]  [1링크]  [무관]  [무관]  [용량40]  [날짜]  [파일명]
///		-r--r-xr-x 1 XX XX 40 Jun 1 23:42 testShell00
/// 유저에게는 r—- 권한을 부여함.
/// 그룹에게는 r-x 권한을 부여함.
/// 그외에게는 r-x 권한을 부여함.
/// 명령어를 통해서 권한 비트를 수정할 수 있음
///		chmod  [U][G][O] testShell00
/// 3가지 접근 유형 ( UGO ) 각각에는 0~7 이라는 숫자를 기입해서 권한 변경.
/// 3가지 접근 유형마다 3자리 비트를 부여해서 권한을 설정한다고 했는데 갑자기 한자리 값을 넣는 이유는,
/// 다음의 표처럼 2진수 표기를 10진수 표기로 대체했더니 0~7까지가 된 것
///" 	10진수		2진수	  권한비트
///" 		0		000		- - -
///" 		1		001		- - x
///" 		2		010		- w -
///" 		3		011		- w x
///" 		4		100		r - -
///" 		5		101		r - x
///" 		6		110		r w -
///" 		7		111		r w x
/// 표에서 [r—-]  [r-x]  [r-x] 에 해당하는 십진법 표기를 찾아보면 각각 4, 5, 5 이므로
///		chmod 455 testShell00
///	이라고 입력하면 파일의 권한이 변경된다
///ㅡ
///:  파일의 시간 [Jun 1   23:42]
/// 파일의 최근 수정 시간도 변경할 수 있음. touch명령어의 time 옵션을 활용함. 형식은 다음과 같음
///		touch -t [yyyy][dddd][hhmm] testShell00
/// 2023년 june월 1일 23시 42분으로 변경하려면 다음과 같이 입력함
///		touch -t [2023][0601][2342] testShell00
///ㅡ
///:  과제 파일 압축하기
/// tar의 c옵션을 이용해서 압축파일을 생성함
/// 원래 git에 push를 하면 파일의 권한이 변경되는데, 이는 채점에 방해가 되므로 이 문제를 예방하려고 압축해서 제출하도록 했다는 썰이 있다
///		tar -cf testShell00.tar testShell00
////: exo2.tar			--- 02✅파일의 [접근 권한, 링크수, 바이트, 날짜, 이름] 을 설정하고, 압축하기
////:  과제의 요구사항
//// 	ls -l 으로 파일 정보를 확인
//// 	[파일유형]  [권한비트]  [하드링크수]  [소유권자]  [소유그룹]  [용량]  [날짜]  [파일명]
////		d rwx--xr-x 2 XX XX XX Jun 1 20:47 test0
////		- rwx--xr-- 1 XX XX 4  Jun 1 21:46 test1
////		d r-x---r-- 2 XX XX XX Jun 1 22:45 test2
////		- r-----r-- 2 XX XX 1  Jun 1 23:44 test3
////		- rw-r----x 1 XX XX 2  Jun 1 23:43 test4
////		- r-----r-- 2 XX XX 1  Jun 1 23:44 test5
////		l rwxrwxrwx 1 XX XX 5  Jun 1 22:20 test6 -> test0
////ㅡ
////:  파일의 용량, 이름, 권한
////   이전 과제에서 실습한대로, 파일 용량/이름/권한을 부여한다
////ㅡ
////:  링크란?  하드링크 vs 심볼릭링크
////> 하드링크	 분신/가명	분신 중에 누구를 건드려도 모든 분신이 일제히 영향받는 파일 생성.	물리적으로 같은 파일
////> 심볼릭링크		사생팬	본인이 그 파일은 아니지만, 해당 파일로 연결해주는 새 파일 생성.		물리적으로 다른 파일
////  원본 파일을 복제하지 않아도 해당 파일을 여러 디렉토리에서 사용하고 싶을때 바로가기를 만든다.
////  바로가기는 '하드링크'와 '심볼릭링크' 두가지 방식이 있다.
////ㅡ
////> 하드링크는 동일한 대상에게 접근하는 여러개의 이름이다. 디스크 상에서 하나의 자리만 차지한다.
////  저의 본명인 김근용이랑 저의 닉네임인 큰김은 같은 집에서 살고,
////  큰김을 때리면 김근용이 아프고 김근용을 떄리면 큰김이 아프다.
////  파일정보 ls -l 에서 확인할 수 있는 ‘하드링크 수’ 는 분신의 갯수를 의미한다
////  다음 명령어를 실행해서, test5라는 분신을 생성한다.
////		ln test3 test5
////  둘 중에서 누가 진짜인지는 구별할 수 없다. 하나의 진짜를 가리키는 2개의 분신일 뿐이다.
////  파일의 물리적인 주소같은 고유한 값을 포함하는 inode라는 변수가 있다.  ls -i 옵션으로 볼 수 있다.
////  하드링크 명령어로 생성된 분신은 서로 똑같은 inode를 공유한다. 여기서 inode가 바로 본체이다.
////ㅡ
////> 심볼릭링크는 특정한 대상에게 접근하는 사생팬이고, 사생팬은 본인 집에서 사니깐, 디스크 상에서 두개의 자리가 존재한다.
////  밤이되면 연예인은 숙소에 들어가고, 사생팬은 본인 집으로 들어간다. 사생팬이 다쳐도 연예인이 다치지 않는다.
////  연예인이 다쳐도 사생팬 자체는 다치지않는다, 대신에 사생팬은 연예인이 다쳤다고 커뮤에 널리널리 알려서 연예인을 대변한다
////  ln 명령어에 -s (symbolic link) 옵션을 추가해서, test6라는 사생팬을 생성한다.
////		ln -s test0 test6
//// 둘 중에서 누가 진짜인지는 분명하다. test0 이 원본이고, 원본을 스토킹하는 test6이 존재한다
////ㅡ
////:  파일의 유형 [d l -]
////  하드링크를 가진다고 파일의 성질이 변화는 것이 아니기 때문인지 그냥 - 일반 파일임을 알 수 있고
////  심볼릭링크는 본인 정체성은 없고 링크라는 특수한 목표로만 쓰일 수 있기 때문인지 l 이라는 기호로 구별함을 알 수 있다
////  5라고하는 바이트도 그러한 목적을 위해서 사용되었다
////" 		기호		파일종류
////" 		-			일반파일 (하드링크가 존재한다는 이유로 변하지 않음)
////" 		d			디렉토리
////" 		l 			심볼릭링크
////ㅡ
////:  파일의 권한
////  사생팬과 연예인의 구별에도 불구하고, 심볼릭 링크의 권한을 변경 시도하면 원본 파일의 권한이 변경되는데,
////		Chmod -h 777 test6
////  처럼 -h 옵션을 추가하면 사생팬이 가리키는 연예인이 아니라 사생팬 그 자체의 권한이 바뀐다
////ㅡ
////:  과제 파일 압축하기/압축풀기
////  tar의 c옵션을 이용해서 압축파일을 생성함
////		tar -cf exo2.tar *를 실행하여 압축 파일을 생성함.
////  파일을 압축하고 다시 해제하면, 내가 설정한 것과는 다르게 파일 권한이 저절로 변경되기도 함.
////  압축하거나 해제할때 -p 옵션을 추가하면 파일의 권한이 보존된 상태로 압축 해제가 가능
////  압축하기 tar  -cpvf   파일명		(-v 내용안내    -f 대상명시)
////  압축해제 tar  -xpvf  파일명		(-v 내용안내    -f 대상명시)
///:  id_rsa_pub		--- 03✅인트라넷에 나의 퍼블릭키를 연동하기
///: 두 개의 파일
/// id_rsa     파일을 cat 명령어로 확인하면, 개인 키임을 안내하고 있음
/// id_rsa.pub 파일은 확장자가 public의 약자가 아닌지 추측해보았음.
/// cat 명령어로 공개키를 확인하고 인트라넷 개인 설정란에 업데이트 하였음
///ㅡ
///: 문제가 요구하는 파일을 깃에 올리기
/// 다음과 같이 파일을 복제하였음			  cp id_rsa.pub ID_RSA_PUB
/// 다음과 같이 상위폴더로 이동시켰음		   mv ID_RSA_PUB ..
/// 다음과 같이 깃 폴더로 이동시켰음		  mv ID_RSA_PUB ./piscine/ex03
/// 다음과 같이 업데이트 하였음				 git add ID_RSA_PUB
/// 다음과 같이 커밋하였음					git commit -m "ex03"
/// 다음과 같이 푸쉬하였음					git push
///ㅡ
///: 파일 확장자를 변경해도 되는 이유
/// 파일이란 근본적으로 바이트의 나열이라고 할 수 있음. 그림파일이든 음악파일이든 0과 1의 비트가 나열되어 있음.
/// 그러한 0과 1로 이루어진 덩어리를 어떤 식으로 해석하고 렌더링하느냐에 따라서,
/// 완전히 똑같은 덩어리가 비로소 그림이 되기도 하고 소리가 되기도 함.
/// 헤더와 확장자는 그 파일을 실행하는 프로그램이 이러한 바이트를 어떤 방식으로 인식할 것인지 알려줌.
/// 한장의 사진을 특정한 방식으로 열람하면 그림이 되는데, 또다른 방식으로 열람하면 소리가 될 수도 있음.
/// 파일은 단지 바이트의 나열일 뿐이지만 그 바이트를 해석하여 의미를 부여하도록 방향성을 제시하는 것이, 헤더와 확장자임.
/// 즉, 확장자를 없애버리고 아무런 확장자도 갖지 않는 새로운 파일로 복사하더라도. 본질적으로 그 파일의 성질은 변하지 않음.
///ㅡ
///: 공개 키와 개인 키의 차이점
/// 원본 문서를 ‘공개키’ 라는 기준으로 변환해서 암호 문서를 만든다.
/// 이 암호는 ‘공개키’ 를 기준으로 만들었음에도, ‘공개키’를 통해서는 원문을 알아낼 수 없다.
/// 이 암호를 원문으로 변환하려면 ‘개인키’ 가 필요하다
///ㅡ
///: 공개키 와 개인 키의 비유
/// 나의 공개키는 “사투리" 이고, 나의 개인키는 “제주도" 이다.
/// 42서버에서 “고구마라고 대답해" 라는 메시지를 공개키를 이용해서 암호화하였다.
/// “감저랭고릅서" 라는 메시지가 발생한다. 사람들은 이것이 임의의 지방의 사투리임은 알고있다.
/// 그럼에도 불구하고 해석하지 못한다. 나는 제주도 사람이므로 제주도 방언임을 알아차리고
/// “고구마" 라고 신호를 보낸다. 그러면 42서버에서는 나를 나라고 확신하고 리포지토리를 보내준다.
////: midLS				--- 04✅현재 디렉토리의 모든 파일/폴더를, 콤마/스페이스로 구분하고 날짜순으로 출력하는 명령어. 숨김파일은 제외.
//// ls 명령어는 현재 디렉토리의 모근 파일/폴더를 보여준다
////		ls
////		exo2.tar	test1		test3		test5
////		test0		test2		test4		test6
//// -m 옵션은 각 항목을 콤마와 띄어쓰기로 구분해주고
//// -p 옵션은 폴더에만 슬래쉬 문자를 붙여줌
//// -t 옵션은 수정된 순서대로 나열해주고
//// 옵션을 조합해서 ls -tmp 라고 입력하면 다음과 같은 예시를 얻음
//// 일부러 쩜(dot)으로 시작하는 파일을 만들어봤지만 숨겨져서 보이지 않았음
////		ls -mpt
////		exo2.tar, test3, test5, test4, test2/, test6, test1, test0/
//// -F 옵션도 슬래쉬 문자를 붙여주는데, 폴더가 아닌 다른 파일까지도 저마다의 기호로 구별해줌
////		ls -Fmt
////		exo2.tar, test3, test5, test4*, test2/, test6@, test1*, test0/
///:  git_commit.sh		--- 05✅최근 5개의 커밋 기록 중에서, 커밋ID만 뽑아내는 쉘 스크립트
///: 깃 명령어
///		git status					최근 갱신한 버전 내역과, 실제 파일 현황 사이의 차이를 알아냄
///		git add 파일명				차이점이 발견된 파일 중, 버전 내역에 새로 갱신하고 싶은 것을 예약
///		git commit -m "설명"		파일 현황대로 버전 내역을 갱신함. (버전에 대한 설명을 곁들임)
///		git push					갱신된 버전 내역에 따라서 파일을 업로드
///		git log —format="%H"		커밋 기록 중에서 ID만 (HASH) 출력
///		git log —n 5				커밋 기록 중에서 최근 5개만 출력
///ㅡ
///: 쉘 스크립트 작성하기
/// 명렁어 여러줄을 순서대로 실행해주는 편리한 프로그램
/// 파일의 맨 윗줄에 #!/bin/sh 를 명시하고,
/// 터미널에서 하던 것처럼 명령어를 그대로 작성하고,
/// 파일의 확장자를 .sh 로 저장하면 쉘 스크립트로 인식함
///ㅡ
///: git_commit.sh 작성하기
///> 	#!/bin/sh
///> 	git log -n 5 —format="%H"
///ㅡ
///: 쉘 스크립트 실행하기
///		bash git_commit.sh | cat -e
///ㅡ
////: git_ignore.sh		--- 06✅깃이 무시하는 모든 파일을 출력하는 쉘 스크립트
////: 깃 명령어
////		git ls-files				깃이 접근하는 모든 파일 표시
////			--ignored				무시된 파일 표시 (무시하는 기준을 필요로 함)
////			--exclude-standard		.gitignore 등, 표준적인 기준으로 무시
////			--others				깃이 추적하지 않는 파일도 표시
//// git은 모든 파일에 접근할 수 있고
//// git status 는 달라지거나 새롭게 찾은 파일을 보여주며
//// git add하는 순간 새로운 파일들은 깃의 추적 대상이 됩니다.
//// git commit을 하면 ‘버전 내역’ 에 등록됩니다.
//// git push를 하면 ‘버전 내역’ 을 따라서 파일들을 일제히 서버에 업로드합니다.
//// others 옵션을 추가하는 이유는, 아직 add를 하지 않았지만 깃이 무시하는 파일들도 보여주기 위해서 입니다.
////ㅡ
////: git_ignore.sh 작성하기
////> 	#!/bin/sh
////> 	git ls-files --ignored --exclude-standard --others
////ㅡ
////: 쉘 스크립트 실행하기
////		bash git_ignore.sh | cat -e
////ㅡ
///:  b					--- 07✅두 파일 사이의 차이점을 (명시한 vs 추적한) diff 파일을 활용해서, 원본 파일을 목적 파일로 패치시키기
/// 방정식  diff a b == f  를 만족하는 b를 구하시오.
/// a문서와 b문서의 차이점을 알려주는 diff 라는 명령어가 있습니다. 결과물인 diff 문서를 가지고 역으로 b문서의 내용을 추측할 수 있습니다.
/// b의 내용을 달리하면 diff a b > sw.diff의 내용도 달라집니다.
/// 처음에는 sw.diff 문서처럼 나오게끔 b를 일일이 수정해보므로써 b를 알아내려고 시도하였습니다.
/// patch a sw.diff -o b
/// diff 파일은 기호들이 난잡하게 섞여있어서. 처음에는 이 기호들을 직접 걸러내서 a랑 형식을 일치시켜줘야 patch를 적용할 수 있는 것으로 착각했고, patch를 사용하지 않고 관찰과 대입만으로 어떻게든 b를 만들어냈는데.
/// 다른 분을 평가하고 오니까 patch가 생각보다 간단하고 강력한 기능임을 알게 됐습니다. diff 파일에 나와있는 기호들 자체가 patch 명령어를 사용하기 위해 만들어진 거더군요. 난잡한 기호들이 있어야지 오히려 patch가 작동하는 것이고, 제가 막 sw파일을 정제해서 a랑 맞춰줘야 하는게 아니었습니다.    patch는 sw.diff이라는 변동 사항 안내서를 이용해서 a를 변경시켜줍니다. 기본적으로 a에 덮어쓰는 방식이라서 원본 a를 잃어버립니다. -o 옵션을 넣어주면 a를 보존시키고 b라는 파일을 새로 만들어줍니다.   diff a b > sw2.diff 를 하고, 또다시 diff sw1 sw2 를 비교해주면 차이가 없으므로 우리가 만들어낸 b는, 처음에 제공받은 sw랑 똑같은 sw를 만들어내는 것을 알 수 있습니다. 처음 방정식을 만족시킵니다.
////: clean				--- 08✅현재 경로로부터, 이름규칙을 만족하는 '파일' 을 속속들이 찾아내서, 콤마/스페이스로 구분하여 출력하는 명령어.
//// find 명령어를 사용하면, 현재 경로로 시작하는 모든 경로의 파일/폴더들을 속속들이 찾아준다
////		find .
//// -name 옵션을 사용하면, 이름 규칙을 만족하는 대상만을 뽑아준다
//// #으로 시작해서, 공백 또는 아무 문자열이 존재하고, #으로 끝나는 이름은 #*# 으로 특정할 수 있다
//// 공백 또는 아무 문자열이 존재하고, ~으로 시작해서 끝나는 이름은 *~ 으로 특정할 수 있다
////		find . -name “이름규칙"
////		find . -name "#*#"
////		find . -name "*~"
//// -o(또는) 옵션을 사용하면, 이름 규칙을 추가해서 더 많은 대상을 찾아준다
////		find . -name “이름규칙1" -o -name “이름규칙2"
////		find . -name "#*#" -o -name "*~"
//// -delete 옵션은 발견한 파일을 삭제하는데, or로 결합된 두 항목 중에서 한쪽에만 적용됨.
//// -print 옵션은 삭제하기 이전에 리스트를 출력해줌.
////		find . -name "#*#" -o -name "*~" -print -delete
////  \(  \) 괄호를 써서 하나로 묶어주면 양쪽 모두에 적용됨.
////		find . \( -name "#*#" -o -name "*~" \) -print -delete
//// -type f 를 추가해주면 디렉토리가 아니라 파일만 보여줌.
////		find . -type f
////		find . -type f \( -name "#*#" -o -name "*~" \) -print -delete
//// 해당 명령어를 저장하는 텍스트를 만드는 것이 과제의 요구 조건이므로 Echo의 > 기능을 이용함
////		Echo “find . -type F \( -name "#*#" -o -name "*~" \) -print -delete" > clean
///:  ft_magic			--- 09✅42번째 바이트부터 "42" 라는 문자열이 등장하는 "42 file" 이라는 파일타입을 판별해주는 매직파일
/// file 이라는 명령어는 파일의 타입을 알려줍니다.
/// 프로그래밍 언어에 변수의 자료형을 알려주는 명령어가 있듯이,
/// 파일에도 파일타입이란게 있고, file 명령어는 그런 파일타입을 알려줍니다.
/// 프로그래밍 언어에 int, char, double 같은 다양한 자료형이 있듯이
/// 파일타입에도 여러가지가 있고, file 명령어는 그 중에서 하나라고 알려줍니다
/// 그런데 사용자가 직접 특수한 파일타입을 정의할 수도 있습니다.
/// file -m 명령어를 사용하면, 특정한 파일이 기본 파일타입에 해당하는지에 앞서서,
/// 사용자가 궁금해하는 특수한 파일타입인에 해당하는지를 알아볼 수 있습니다.
/// 문제가 요구하는 것은, “42 file" 라는 특수타입인지 판정하는 매직 파일을 만드는 것입니다.
/// 어떠한 파일이 우리가 궁금해하는 특수한 타입인지 알려면, 그러한 기준이 필요합니다.
/// 그런데 그 기준이 어딘가에 적혀져있어야만 그 기준을 바탕으로 판단을 할 수 있습니다.
/// 즉 파일을 판정하기 위해서도 그 메뉴얼이 되는 파일이 필요합니다. 그런 매뉴얼은 매직 파일이라고 합니다.
/// ft_magic 이라는 매직 파일을 만들어야 합니다.
///
/// “42 file" 이라는 파일타입은 다음 성질을 가집니다.
/// 파일타입의 이름이 42 file 이다
/// 42바이트 자리에 42라는 문자열 내용이 존재함
/// ft_magic 이라는 매직파일은 다음 목적을 가집니다.
///  42라는 특수타입을 판정하기 위해서, file 명령어랑 연동할 목적으로 제작하는 메뉴얼
///  file -m 매직파일 검사파일 이라는 명령어를 통해서 원하는 파일이 42특수타입인지 알 수 있습니다.
/// 매직파일이 메뉴얼로 이용되기 위해서 지켜야하는 문법이 있습니다
/// (41) (string) (42) (42 file)
/// (41) 번째 바이트 이후를 의미합니다. 즉, 42번째 자리부터 무엇이 올것인지를 설정합니다.
/// somefile 을 열어서 바이트를 일일이 세어봅니다.
/// 42번째 자리에 특정한 문자열이 있는지 알아보려고 하므로 (string) (42) 라고 넣어줍니다
/// 조건을 만족하면 (42 file) 이라는 특수타입으로 인지하게끔 (42 file) 이라고 넣어줍니다
/// 낱말이 5개라서 5가지 설정을 넣은 것 같지만 사실은 4개의 항으로 되어있습니다.

//!  SH01
///:  print_groups.sh		--- 01✅환경 변수 FT_USER에 저장된 유저가 속해있는 모든 그룹을 콤마로 구분하여 출력하는 쉘 스크립트
/// 리눅스 계정 사용자는 한개 이상의 그룹에 소속되어 있다.
/// 사용자가 속해있는 그룹 목록은 두 가지 방법으로 출력할 수 있다. id를 권장하므로 id를 이용한다.
///		groups 유저명
///		id -Gn 유저명
///ㅡ
/// id -G는 그룹의 일련번호가 출력되고, id -Gn은 그룹의 닉네임으로 출력된다.
///		id -Gn keunkim
///		2023_seoul everyone netaccounts _developer
///ㅡ
/// 파이프라인은, 왼쪽 명령어의 출력을 오른쪽 명령어의 입력으로 전달해서, 연쇄적으로 데이터를 가공할 수 있게한다
/// tr 명령어는 집합 두 개를 입력받아서, 한쪽 집합에 속하는 원소를 다른 집합의 원소로 치환해주는 기능을 가지고 있다.
///		id -Gn keunkim | tr ' ' ','
///		2023_seoul,everyone,netaccounts,_developer
///ㅡ
/// 과제 예시를 보면, 결과물을 출력하고 나서 새로운 명령줄이 곧바로 이어지는 것을 볼 수 있다. 이것은 개행문자가 생략되었음을 의미한다
///> FT_USER=nours 인 경우의 예시
///		$>./print_groups.sh
///		god,root,admin,master,nours,bocal$>새명령줄
///> FT_USER=daemon 인 경우의 예시
///		$>./print_groups.sh
///		daemon,bin$>새명령줄
///ㅡ
/// tr -d 명령어는 주어진 집합의 원소를 모두 찾아서 삭제해주는 기능을 가지고 있다
///		id -Gn keunkim | tr ' ' ',' | tr -d '\n'
///		2023_seoul,everyone,netaccounts,_developer%
///ㅡ
/// export 명령어를 이용해서 환경 변수 FT_USER에 특정한 값을 저장할 수 있고, 명령어에서 변수를 사용할때는 변수 앞에 $달러를 붙여준다
///		export FT_USER="keunkim"
///		id -Gn $FT_USER | tr ' ' ',' | tr -d '\n'
///ㅡ
/// 쉘 스크립트 작성하기 ( print_groups.sh )
///>	#!/bin/sh
///>	id -Gn $FT_USER | tr ' ' ',' | tr -d '\n'
///ㅡ
/// 쉘 스크립트 실행하기
///>	bash print_groups.sh | cat -e
////: find_sh.sh			--- 02✅이름이 '.sh'로 끝나는 파일을 속속들이 찾아내어, 이름에서 확장자를 제외해서 출력하는 쉘 스크립트
//// find 명령어를 사용하면, 지정한 경로에서 시작하는 모든 경로의 파일/폴더들을 속속들이 찾아준다
////		find .
////ㅡ
//// -name 옵션을 사용하면, 이름 규칙을 만족하는 대상만을 뽑아준다
//// 공백이나 아무 문자열이 이어지다 .sh 으로 끝나는 이름은 "*.sh" 으로 특정할 수 있다
////		find . -name "이름규칙"
////		find . -name "*.sh"
////ㅡ
//// 그런데 디렉토리가 아닌 파일만을 찾아야하므로 -type f 옵션도 추가해준다
////		find . -type f -name "*.sh"
////ㅡ
//// basename 명령어를 사용하면, 파일의 이름을 가공하여 새로운 문자열을 만들 수 있다
//// 파일명의 다음 인자에 접미사를 넣으면, 파일이름 뒷자리가 접미사와 일치할 경우에 해당 문자열을 지워준다
////		basename 파일명
////		basename 파일명 접미사
////ㅡ
//// 즉, 파일명의 다음 인자에 확장자를 묘사하면 확장자만 지워진다
////		basename a.out .out
////		a
////ㅡ
//// find 명령어에 -exec 옵션을 사용하면, 찾아낸 리스트를 대상으로 추가적인 작업을 수행할 수 있다.
//// 찾아낸 리스트는 {} 라는 대명사로 지칭할 수 있다
//// 명령문의 끝에는 이스케이프 문자와 함께 세미콜론이 \; 온다.
////		find . -exec 명령어 {} \;
////ㅡ
//// find로 찾아낸 리스트에서 .sh 만을 제거하려면 다음과 같이 작성할 수 있다.
////		find . -exec basename {} .sh \;
////		find . -type f -name "*.sh" -exec basename {} ".sh" \;
////ㅡ
//// 쉘 스크립트 작성하기 ( find_sh.sh )
////> 		#!/bin/sh
////> 		find . -type f -name "*.sh" -exec basename {} ".sh" \;
////ㅡ
//// 쉘 스크립트 실행하기
////		bash find_sh.sh | cat -e
///:  count_files.sh		--- 03✅현재 경로에서 시작하는 모든 경로의 파일/폴더를 속속들이 찾아내고 총 갯수를 표시하는 쉘 스크립트
/// wc 명령어를 사용하면, 파일 내용을 읽어서 라인수(line), 단어수(word), 문자수(char), 파일명을 알려준다
///			%> echo "aaaa\nbbbb\n\ndddd\n\nffff" > test
///			%> wc test
///			%>       6       4      22 test
///ㅡ
/// 세가지 정보의 앞글자를 따서 (l, w, c) 명령어 옵션으로 입력하면 해당 정보만 알아낼 수 있다
///			wc -l test
///			6 test
///ㅡ
/// 파이프라인은, 왼쪽 명령어의 최종 결과물을 오른쪽 명령어의 입력으로 전달해서, 연쇄적으로 데이터를 가공할 수 있게한다
/// find 명령어를 사용하면, 지정한 경로에서 시작하는 모든 경로의 파일/폴더들을 속속들이 찾아주고, 각 항목을 줄마다 하나씩 알려준다
/// 이러한 find의 출력 결과물을 그대로 wc -l 명령어의 인자로 넘기면, 파일의 갯수를 알 수 있다
///			find . | wc -l
///ㅡ
/// 그런데 wc는 본래 여러가지 정보를 표현하는 명령어이고, 한가지 정보를 출력할때 앞에 공백문자를 덧붙이므로써, 다른 정보와 칸을 구분하는 특징이 있다
/// 이러한 스페이스를 제거해야한다. cat -e 명령어로 개행문자가 어디 있는지 확인하면, 뒷쪽으로는 스페이스나 탭이 따로 붙지 않음을 알 수 있다.
///			find . | wc -l | cat -e
///			       23$						(스페이스 대신 ~라고 표현했음)
///ㅡ
/// tr -d 명령어는 주어진 집합의 원소를 모두 찾아서 삭제해주는 기능을 가지고 있다
///			find . | wc -l | tr -d ' '
///			23
///ㅡ
/// 쉘 스크립트 작성하기 ( count_files.sh )
///> 		#!/bin/sh
///> 		find . | wc -l | tr -d ' '
///ㅡ
/// 쉘 스크립트 실행하기
///			bash count_files.sh | cat -e
////: MAC.sh				--- 04✅ifconfig에서 볼 수 있는 장치 정보들 중에서 맥어드레스 값만 추출해서 표시하는 쉘 스크립트
//// 우리 주위의 다양한 장치들이 근거리 네트워크를 이룰 때 이것이 돌아가게 하는 시스템이 이더넷이고,
//// 이더넷은 근거리 네트워크에 소속된 장치들마다 (하드웨어들) 지문과 같은 고유번호를 부여하는데 이것이 맥 어드레스이다.
//// 이러한 맥 어드레스는 ifconfig 실행시 'ether 이더' 항목으로 안내가 된다.
////>	    ifconfig
////		en3: flags=8963<UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500
////		options=460<TSO4,TSO6,CHANNEL_IO>
////<	    ether 82:dd:09:41:d0:01
////		media: autoselect <full-duplex>
////		status: inactive
////ㅡ
//// 장치들의 리스트와 함께 ether도 여러개 등장한다. 이러한 ether만 뽑아내고 싶다.
//// grep 명령어는 주어진 정규식에 해당하는 라인만을 뽑아준다.
////>	    ifconfig | grep "ether"
//// 		ether 3c:cd:36:69:72:cb
////< 		media: autoselect (1000baseT <full-duplex,energy-efficient-ethernet>)
////		ether 82:dd:09:41:d0:00
////		ether 82:dd:09:41:d0:01
//// 		ether 82:dd:09:41:d0:00
////		ether 3e:22:fb:64:bc:1c
//// 		ether 3c:22:fb:64:bc:1c
////		ether 0e:22:fb:64:bc:1c
//// 		ether f2:11:5b:13:9d:54
////		ether f2:11:5b:13:9d:54
////ㅡ
////\ "ether" 이더라는 규칙만으로는 energy-efficient-ethernet 이라는 정보를 가지는 또다른 장치를 걸러내지 못한다
////  이 장치가 걸러지기 위해서 문자규칙에 스페이스바를 살짝 추가한다
////>	    ifconfig | grep "ether "
////		ether 3c:cd:36:69:72:cb
////		ether 82:dd:09:41:d0:00
////		ether 82:dd:09:41:d0:01
////		ether 82:dd:09:41:d0:00
////		ether 3e:22:fb:64:bc:1c
////		ether 3c:22:fb:64:bc:1c
////		ether 0e:22:fb:64:bc:1c
////		ether f2:11:5b:13:9d:54
////		ether f2:11:5b:13:9d:54
////ㅡ
//// grep은 문자열 추출이 아니고 라인을 추출하기 때문에 이후의 가공은 다른 명령어가 필요하다
//// tr -d 명령어는 주어진 집합의 원소를 모두 찾아서 삭제해주는 기능을 가지고 있다. "ehrt" 라는 집합을 주면, 16진수의 e문자까지 삭제되어버린다
//// sed 's/원본문자열/바꿀문자열/g' 라는 명령어는, 특정한 문자열을 지정하여 새로운 문자열로 찾아바꾸기 할 수 있다.
//// 위의 문자리스트는 사실 맨앞에 스페이스바랑 탭문자가 들어있다. "스페이스바 혹은 탭문자 반복으로 시작하여 ether등장하고 스페이스가 하나" 가 규칙이다
//// 이것을 정규식으로 번역하면 "[ \t]+ether " 가 되지만, 이 규칙을 넣어서 다음과 같이 출력하면 무슨일인지 잘 작동하지 않는다
////		ifconfig | grep "ether " | sed 's/[ \t]+ether //g' |
////		ifconfig | grep "ether " | sed 's/ether//g'
//// 그래서 sed로는 ether까지만 제거하기로 하고, 공백과 탭은 tr로 삭제하도록 한다
////>	    ifconfig | grep "ether " | sed 's/ether//g' | tr -d " \t"
////		3c:cd:36:69:72:cb$
////		82:dd:09:41:d0:00$
////		82:dd:09:41:d0:01$
////		82:dd:09:41:d0:00$
////		3e:22:fb:64:bc:1c$
////		3c:22:fb:64:bc:1c$
////		0e:22:fb:64:bc:1c$
////		f2:11:5b:13:9d:54$
////		f2:11:5b:13:9d:54$
////ㅡ
//// 쉘 스크립트 작성하기 ( MAC.sh )
////> 		#!/bin/sh
////> 		ifconfig | grep "ether " | sed 's/ether//g' | tr -d " \t"
////ㅡ
//// 쉘 스크립트 실행하기
////		bash MAC.sh | cat -e
///:  "\?$*'MaRViN'*$?\"	--- 05✅오직 4와 2라는 두개 문자를 내용으로 가지면서, 이름으로 사용할 수 없는 특수문자를 이름으로 갖는 파일
/// 다음과 같은 명세에 따라서 파일을 작성하기
///		ls -lRa *MaRV* | cat -e
///		-rw---xr-- 1 75355 32015 2 Oct 2 12:21 "\?$*'MaRViN'*$?\"$
///>	파일의 유형:	-
///>	파일의 권한:	rw-  --x  r--
///>	파일의 용량:	2바이트
///>	파일의 날짜:	Oct 2   12:21
///>	파일의 이름:	마빈
///>	파일의 내용:	42
///ㅡ
/// echo는 기본적으로 문자열을 출력해주는데, 개행문자를 포함해서 출력해준다.
/// cat -e 를 이용해서 개행문자의 존재를 확인할 수 있다.
///		echo "42" | cat -e
///		42$
///ㅡ
/// tr -d 명령어는 주어진 집합의 원소를 모두 찾아서 삭제해주는 기능을 가지고 있다
/// 개행문자가 없을때 나타나는 흰색 블럭의 %문자를 볼 수 있다
///		echo "42" | tr -d "\n"
///		42%
///ㅡ
/// 다양한 명령어와 호환하여, 출력값을 파일로 저장해주는 > 라는 기호가 있다. 이를 이용해서 파일을 만든다
/// tr -d로 개행문자를 제거하면, 일반적인 경우처럼 2+1 바이트가 아닌, 2바이트만이 저장되어있음을 알 수 있다
///		echo "42" | tr -d "\n" > 파일명
///		ls -l 파일명
///		-rw-r--r--  1 keunkim  2023_seoul  2 --  -- 18:39 파일명
///ㅡ
/// 컴퓨터 시스템에서는 특정한 기능을 위해서 특별하게 정의된 문자들이 있다. 그런데 그러한 문자를 기능으로서가 아니라 단지 문양으로서 사용하고 싶을 때가 있다.
/// 그럴 경우에는 이스케이프 문자를 쓰면 기능으로서가 아니라 순수한 모양으로서의 문자로 쓸 수가 된다.
/// 따옴표"'  물음표?  별표*  역슬래시\  달러$는  특별한 기능이 있기 때문에, 기능의 호출이 아니라 단순히 문양으로 쓰려면 이스케이프 문자(\)를 붙여준다.
///			"\?*$'MaRViN'*$?\"					복붙하고 알맞은 곳에 이스케이프 문자 기입
///			\"\\\?\$\*\'MaRViN\'\*\$\?\\\"7777
///ㅡ
/// 최종적으로 파일 생성 명령어는 다음과 같다
///		echo "42" | tr -d "\n" > \"\\\?\$\*\'MaRViN\'\*\$\?\\\"7777
///ㅡ
/// 파일의 권한과 시간은 다음과 같이 부여한다. 바이트와 문자, 이름을 보는 과제라서, 권한과 시간이 어긋나도 기계채점에서는 통과한다고 한다
///	권한은 깃 푸시할때 변경되기에 SH00 과제에서 압축을 해서 올렸던 것이고, 날짜랑 시간은 잘 안바뀌고 시간 자리에 날짜가 들어가기도 한다
///		chmod 614 마빈
///		touch -t 202310021221 마빈
////: skip.sh				--- 06🔴
//// Write a command line that displays one line out of two for the command ls -l,
//// starting from the first line
///:  r_dwssap.sh			--- 07🔴
/// 마지막 개행 지우기 tr -d
/// Write a command line that displays the output of a cat /etc/passwd command,
/// removing comments, every other line starting from the second line, reversing each lo-
/// gin, sorted in reverse alphabetical order, and keeping only logins between FT_LINE1
/// and FT_LINE2 included, and they must separated by ", " (without quotation
/// marks), and the output must end with a ".".
/// •Example: Between lines 7 and 15, the result should be something like this :
/// $> ./r_dwssap.sh
/// sstq_, sorebrek_brk_, soibten_, sergtsop_, scodved_, rlaxcm_, rgmecived_, revreswodniw_, revressta_
////: add_chelou.sh			--- 08🔴
////Write a command line that takes numbers from variables FT_NBR1, in ’\"?! base,
//// and FT_NBR2, in mrdoc base, and displays the sum of both in gtaio luSnemf base.
//// ◦Example 1:
//// FT_NBR1=\'?"\"'\
//// FT_NBR2=rcrdmddd
//// ◦The sum is :
//// Salut
//// ◦Example 2 :
//// FT_NBR1=\"\"!\"\"!\"\"!\"\"!\"\"!\"\"
//// FT_NBR2=dcrcmcmooododmrrrmorcmcrmomo
///// ◦The sum is :
//// Segmentation fault

//!	 C00
void ft_putchar(char c) // ✅문자 하나를 찍어주는 함수
{
	write(1, &c, 1);
	/// 첫번째인자에 1을 넣으면 출력을 의미
	/// 두번째인자로 받은 지점에서 (주소에서) 시작해서,
	/// 세번째인자의 갯수만큼 연속된 데이터를 출력
}
void ft_print_alphabet(void) // ✅알파벳을 순서대로 출력하는 함수
{
	write(1, "abcdefghijklmnopqrstuvwxyz", 26);
	/// 문자열 리터럴은 자신만의 고유한 주소를 갖는다
	/// 변수로 지정해서 붙잡아두지도 않더라도, 휘발되지도 않고 자신의 고유한 주소를 가진다
	/// 맨땅에 근본없이 선언하여도, 그것을 받아주는 변수가 없어도, 컴파일 시간에 프로그램이 문자열 리터럴을 붙잡아서 주소를 부여한다
	/// 배열의 이름이 배열의 시작(첫칸) 주소를 가리키듯이, 문자열 리터럴은 그 문자열의 시작(첫칸) 주소를 가리킨다
	/// write함수는 두번째 인자로, 데이터의 주소 (혹은 연속데이터의 시작주소) 를 전달받는다. 문자열 리터럴은 고유한 주소를 가지고 있으므로
	/// 그대로 사용해도 write함수가 특정해낼 수 있다. 변수에 값을 인계시켜서 변수의 주소를 인자에 넣는 과정을 생략해도 된다
}
void ft_print_reverse_alphabet(void) // ✅알파벳을 역순으로 출력하는 함수
{
	int i;
	i = 'z';
	while (i >= 'a')
	{
		write(1, &i, 1);
		i--;
	}
	write(1, "\n", 1);
}
void ft_print_numbers(void) // ✅0~9를 오름차순으로 출력하는 함수
{
	write(1, "0123456789", 10);
	///	이스케이프 문자는 두개의 문자처럼 보이지만, 역슬래쉬 뒤에 기호가 짝지어져서 비로소 하나의 문자를 이룸
	///	문자 하나는 1바이트이므로 10+1 = 11개 출력하기
}
void ft_is_negative(int n) // ✅양수와 음수를 구분하는 함수
{
	//		정수형으로 표현할 수 있는 수의 범위는, -2의 31승 ~ 2의 31승
	//									 –2147483648 ~ 2147483647 .... 10자리
	char flag;
	flag = 'P' - 2 * (n < 0); /// 음수에 대해서만 'P'의 아스키코드에 -2가 더해져서 'N'의 아스키코드가 됨

	write(1, &flag, 1);
}
void ft_print_comb(void) // ✅0~9로 이루어진, 세자리 순열을, 중복없이 오름차순으로 출력하는 함수
{
	char dec[4];	  //! 세자리 수이므로, 자릿값을 나타내기 위한 세자리의 배열을 사용함 (앞에서부터 첫번째 자리, 두번째 자리, 세번째 자리)
	dec[0] = '0' - 1; //! 0번째 자리는 없지만, 자릿값을 초기화하는 양식을 통일하려고 임의로 값을 부여함

	dec[1] = dec[0] + 1;  // 첫번째 자릿값을 '0' 으로 초기화
	while (dec[1] <= '7') // 순열의 최댓값이자 최종값은 789이므로, 첫번째 자리값은 '7' 이 한계임
	{

		dec[2] = dec[1] + 1;  // 두번째 자릿값을 '1' 로 초기화, 중복없는 오름차순이므로 이전 자릿값보다 커야한다 (같으면 중복, 작으면 No오름차순)
		while (dec[2] <= '8') // 순열의 최댓값이자 최종값은 789이므로, 두번째 자리값은 '8' 이 한계임
		{
			// 셋번째 자릿값을 '2' 로 초기화, 세번째 자리값은 '9'가 한계임
			dec[3] = dec[2] + 1;  //>  (6)--- 세번째 자릿값을 다시 초기화해주는데 두번째 자릿값보다 커야함
			while (dec[3] <= '9') //>  (4)--- '9' 도달하면 while문 빠져나감
			{

				write(1, dec + 1, 3);							//> (1)--- 최초로 "012" 을 찍고, 이어서 013 014 015 016 찍음
				if (dec[1] + dec[2] + dec[3] < '7' + '8' + '9') //: 각 자릿값이 '7''8''9' 인지
					write(1, ", ", 2);							//> (3)---  124 125 126 127 128 129 찍어나가다가

				dec[3]++; //> (2)--- dec[3]이 하나씩 커짐
			}
			dec[2]++; //>  (5)--- 세번째 자릿값이 차오르며 다 찍히고 나서야, 두번째 자릿값이 자리올림 됨
		}
		dec[1]++;
	}
}
void ft_convert_and_print(int n) /// 99이하의 숫자를 "00" 꼴로 포맷팅하여 출력하는 함수
{
	char conv[2];
	conv[0] = n / 10 + '0'; // 73을 10으로 나눈 몫인 7을 '7' 으로 변환함
	conv[1] = n % 10 + '0'; // 73을 10으로 나눈 나머지 3을 '3' 으로 변환함
	write(1, conv, 2);		// 73은 '7'과 '3'이 되어 conv배열에 각각 연속적으로 담김. write는 연속자료를 출력함
}
void ft_print_comb2(void) // ✅0~9로 이루어진, 두자리 순열을, 중복없이 오름차순으로, "00 00" 꼴로 출력하는 함수
{
	int dec[3];
	dec[0] = -1;

	dec[1] = dec[0] + 1;
	while (dec[1] <= 98)
	{

		dec[2] = dec[1] + 1;
		while (dec[2] <= 99)
		{
			ft_convert_and_print(dec[1]);
			write(1, " ", 1);
			ft_convert_and_print(dec[2]);
			if (dec[1] + dec[2] < 98 + 99)
				write(1, ", ", 2);

			dec[2]++;
		}
		dec[1]++;
	}
	write(1, "\n", 1);
}
unsigned long long ft_pow(int n, int a) /// n^a승 구하는 재귀적인 함수
{
	if (a)
		return ft_pow(n, a - 1) * n;
	else
		return 1;
}
void EXPLAIN_putnbr(int nb) ///: 정수를 숫자문자열로 출력하는 함수
{
	///	583647	---->  "583647"
	char conv[12];

	//: 다음과 같은 방식으로 각 자리의 숫자를 (자릿값) 추출할 수 있음.
	//: 배열의 뒤에서부터 10진수 모양으로 채워나감. 앞의 빈자리는 0으로 채워짐. 0000583647
	conv[9] = (583647 % 10) / 1;				   ///	7
	conv[8] = (583647 % 100) / 10;				   ///	4
	conv[7] = (583647 % 1000) / 100;			   ///	6
	conv[6] = (583647 % 10000) / 1000;			   ///	3
	conv[5] = (583647 % 100000) / 10000;		   ///	8
	conv[4] = (583647 % 1000000) / 100000;		   ///	5
	conv[3] = (583647 % 10000000) / 1000000;	   ///	0
	conv[2] = (583647 % 100000000) / 10000000;	   ///	0
	conv[1] = (583647 % 1000000000) / 100000000;   ///	0
	conv[0] = (583647 % 10000000000) / 1000000000; ///	0

	//: 자릿번째에 따른 공식을 발견. 공식을 이용해서, 각 자릿번째에 자릿값을 대입함.
	conv[9] = (nb % 10 ^ 1) / 10 ^ 0;
	conv[8] = (nb % 10 ^ 2) / 10 ^ 1;
	conv[7] = (nb % 10 ^ 3) / 10 ^ 2;
	conv[6] = (nb % 10 ^ 4) / 10 ^ 3;
	conv[5] = (nb % 10 ^ 5) / 10 ^ 4;
	conv[4] = (nb % 10 ^ 6) / 10 ^ 5;
	conv[3] = (nb % 10 ^ 7) / 10 ^ 6;
	conv[2] = (nb % 10 ^ 8) / 10 ^ 7;
	conv[1] = (nb % 10 ^ 9) / 10 ^ 8;
	conv[0] = (nb % 10 ^ 10) / 10 ^ 9;

	int i;
	i = 10;
	while (i--)
	{
		conv[i] = (nb % 10 ^ (10 - i)) / 10 ^ (9 - i);
	}

	i = 10;
	while (i--)
	{
		conv[i] = (nb % ft_pow(10, (10 - i))) / ft_pow(10, (9 - i));
		/// ^ 기호는 제곱 모양이지만, 제곱이 아니라 xor 연산자라서 다른 결과가 발생함
		/// n의 a승을 구하는 함수인 pow를 만들어서 사용함
	}
}
void OLD_putnbr(int nb) // ✅정수를 숫자문자열로 출력하는 함수
{
	//		정수형으로 표현할 수 있는 수의 범위는, -2의 31승 ~ 2의 31승-1
	//									 –2147483648 ~ 2147483647 .... 10자리
	char conv[10];
	char start;
	int i;

	if (nb < 0)
		write(1, "-", 1);
	if (nb == -2147483648)
		write(1, "2147483648\n", 11);
	else
	{
		nb = nb * (2 * (nb > 0) - 1);
		///:	32비트 정수		 부호1비트		절댓값31비트 (2의 보수: 반전하고 +1 == -1곱하기)
		/// 	-2147483648		1			0000....000000
		/// 	+2147483647		0			1111....111111
		/// 	+2147483646		0			1111....111110
		/// 	+2147483645		0			1111....111101
		/// 			 +3		0			0000....000011
		/// 			 +2		0			0000....000010
		/// 			 +1		0			0000....000001
		/// 			 +0		0			0000....000000
		/// 			 -1		1			1111....111111
		/// 			 -2		1			1111....111110
		/// 			 -3		1			1111....111101
		/// 	-2147483645		1			0000....000011
		/// 	-2147483646		1			0000....000010
		/// 	-2147483647		1			0000....000001
		/// 	-2147483648		1			0000....000000
		/// 	+2147483647		0			1111....111111
		///:	-2147483648는 nb변수로 정상적으로 받아진다. 여기에서 2의 보수를 구하면 (겉보기 -1 곱하기에 해당)
		/// 	-2147483648		1			0000....000000
		/// 	-2147483648		1			0000....000000	(2의 보수: 반전하고 + 1)
		///:	조작적 정의로 "-1을 곱했다고" 생각했지만 그냥 자기 자신이 되어버렸다. nb = -nb 아무런 변화도 일어나지 않았음
		///:	10000000000000000000000000000000 비트가 전달되고 음수 번역 결과로 ./,),(-*,( 가 나온다
		///:	-2147483648 을 출력하기에는 아래 로직이 무용지물이므로 예외적으로 직접 출력해준다
		///>	[반론] 10000...0000 비트를 반전하여 +1 하면, 0111...111 에서 +1 하는 것으로서, 이것도 일종의 오버플로이며,
		///>	이것은 정의되지 않은 동작이라서 반드시 1000..0000 이라기 보다는 어쨌든 이상한 비트가 들어가게된다.
		///>	이 경우도 마찬가지로 조작적 정의로 "-1을 곱하기" 에 해당하는 값이 되지는 않는다.
		///>	어쨌든 의도치 않은 비트가 되어서, 의도치 않은 번역결과를 가진다. 그러므로 -2147483648 만은 예외적으로 직접 출력해준다.
		i = 10;
		start = 9; // 시작위치를 9로 초기화하면, nb가 0일때 한번도 숫자를 못만나서 0000000000 출력되는 것을 방지
		while (i--)
		{
			conv[i] = nb % ft_pow(10, (10 - i)) / ft_pow(10, (9 - i)) + '0';
			if (conv[i] != '0') // 수가 몇 자린지 알아내기 (앞에서 어느 인덱스부터 숫자가 등장하는지)
				start = i;
		}
		write(1, conv + start, 10 - start); // 숫자가 처음 나오는 시점에서부터, 말단까지 출력
		write(1, "\n", 1);
	}
}
void ft_putnbr(int nb) // 정수를 숫자문자열로 출력하는 함수
{
	char conv[10];
	char start;
	int i;

	if (nb == -2147483648)
		write(1, "-2147483648", 11);
	else
	{
		if (nb < 0)
		{
			write(1, "-", 1);
			nb = -nb;
		}
		i = 10;
		start = 9; // 시작위치를 9로 초기화하면, nb가 0일때 한번도 숫자를 못만나서 0000000000 출력되는 것을 방지
		while (i--)
		{
			conv[i] = nb % 10 + '0';
			nb = nb / 10;
			if (conv[i] != '0') // 수가 몇 자린지 알아내기 (앞에서 어느 인덱스부터 숫자가 등장하는지)
				start = i;
		}
		write(1, conv + start, 10 - start); // 숫자가 처음 나오는 시점에서부터, 말단까지 출력
	}
}
void EXPLAIN_print_comb(int N) ///: 0~9로 이루어진, N자리 순열을, 중복없이 오름차순으로 출력하는 함수
{
	int K = 0;
	char dec[11];
	dec[0] = '0' - 1;

	/// 2중첩 while문 ---> 2자리 조합을 출력
	dec[1] = dec[0] + 1;
	while (dec[1] <= '8')
	{
		dec[2] = dec[1] + 1;
		while (dec[2] <= '9') // 말단 while
		{
			write(1, dec + 1, 2);
			write(1, ", ", 2);
			dec[2]++;
		}
		dec[1]++;
	}

	/// 3중첩 while문 ---> 3자리 조합을 출력
	dec[1] = dec[0] + 1;
	while (dec[1] <= '7')
	{
		dec[2] = dec[1] + 1;
		while (dec[2] <= '8')
		{
			dec[3] = dec[2] + 1;
			while (dec[3] <= '9') // 말단 while
			{
				write(1, dec + 1, 3);
				write(1, ", ", 2);
				dec[3]++;
			}
			dec[2]++;
		}
		dec[1]++;
	}

	/// 4중첩 while문 ---> 4자리 조합을 출력
	dec[1] = dec[0] + 1;
	while (dec[1] <= '6')
	{
		dec[2] = dec[1] + 1;
		while (dec[2] <= '7')
		{
			dec[3] = dec[2] + 1;
			while (dec[3] <= '8')
			{
				dec[4] = dec[3] + 1;
				while (dec[4] <= '9') // 말단 while
				{
					write(1, dec + 1, 4);
					write(1, ", ", 2);
					dec[4]++;
				}
				dec[3]++;
			}
			dec[2]++;
		}
		dec[1]++;
	}

	/// N중첩 while문에서, K번째 while의 구조는?
	dec[K] = dec[K - 1] + 1;					//< (초기화) 왼쪽 자릿수보다 +1 큰 숫자부터 시작해서~
	while (dec[K] <= K + '9' - N)				//< (순열 최종값을 고려할때) 이 자리가 가질 수 있는 최대값까지만
	{
		dec[K + 1] = dec[K] + 1;				//> K+1번째 while문 소환!!
		while ("K+1번째 while문 소환!!");		 //> K+1번째 while문 소환!!
		dec[K]++;								//< while문 카운트 주기적으로 상승
	}

	///: K번째 while블럭은 K+1번째 while블럭을 소환하고, K+1번째는 K+2번째를, K+2번째는 K+3번째를 소환한다
	///: K, K+1, K+2 블럭이 소환되다가, 마지막에는 N번째 while문이 소환된다. (N자리 수니까)

	/// N중첩 while문에서, 마지막 N번째 while의 구조는?
	dec[N] = dec[N - 1] + 1;					//< (초기화) 왼쪽 자릿수보다 +1 큰 숫자부터 시작해서~
	while (dec[N] <= K + '9' - N)				//< (순열 최종값을 고려할때) 이 자리가 가질 수 있는 최대값까지만
	{
		write(1, dec + 1, N);					//> 순열은 N자리의 숫자이므로 N바이트 찍어준다
		write(1, ", ", 2);						//> 새로운 항을 콤마와 띄어쓰기로 구분
		dec[N]++;								//< while문 카운트 주기적으로 상승
	}

	///: 1번째 블럭이 2번째 블럭을, 2번째 블럭이 3번째 블럭을, ..K번째 블럭이 K+1번째 블럭을 소환한다
	///: 마지막 N번째 블럭은, 다음 블럭을 소환하지 않는다. decimal 배열을 통째로 찍어준다.
	///: 함수는 코드 덩어리, 코드 블럭을 복붙해준다
}
void ft_kth_while(int K, int N, char *dec) /// K번째 while문을 생성하는 함수
{
	dec[K] = dec[K - 1] + 1;						  //< (초기화) 왼쪽 자릿수보다 +1 큰 숫자부터 시작해서~
	while (dec[K] <= K + '9' - N)					  //< (최종값을 고려할때) 이 자리가 가질 수 있는 최대값까지만
	{
		if (K != N)
			ft_kth_while(K + 1, N, dec);			  //> K+1번째 while문 소환!! (양식이 동일하므로 함수 재사용)
		if (K == N)
		{											  //> 일반적으로는 다음 while문을 소환하지만, 말단이라면 다르다
			write(1, dec + 1, N);					  //> 순열은 총 N자리 문자열이므로 N바이트 찍어준다
			if (dec[N] + dec[1] != 1 + '9' - N + '9') /// 첫째와 마지막 자리가 최대로 최종값 도달시, 구분기호 출력 중단
				write(1, ", ", 2);					  //> 새로운 항을 콤마와 띄어쓰기로 구분
		}
		dec[K]++;									  //< while문 카운트 주기적으로 상승
	}
}
void ft_print_combn(int n) // ✅0~9로 이루어진, N자리 순열을, 중복없이 오름차순으로 출력하는 함수
{
	char dec[11];
	dec[0] = '0' - 1;

	ft_kth_while(1, n, dec);
	write(1, "\n", 1);
}

//!  C01
void ft_ft(int *nbr) // ✅int 포인터를 매개변수로 받고 해당 int에 값 "42"를 설정하는 함수
{
	*nbr = 42;
}
void ft_ultimate_ft(int *********nbr) // ✅정수의 포인터의 포인터의 포인터의.. 포인터를 매개변수로 받고, 원본 정수에 값 "42"를 설정하는 함수
{
	*********nbr = 142;
}
void ft_swap(int *a, int *b) // ✅주소가 매개변수로 입력된 두 정수의 값을 교환하는 함수
{
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}
void ft_div_mod(int a, int b, int *div, int *mod) // ✅a와 b의 나눗셈. div가 가리키는 int에 몫을 저장, mod가 가리키는 int에 나머지를 저장
{

	// div = a/b; ///  &resA = a/b  주소라는 것은 16진수로 이루어진 어떤 기괴한 숫자일텐데, 그런 숫자가 아닌 a/b라는 평범한 숫자를 넣겠는다는 의미가 됨
	*div = a / b; ///  resA = a/b   주소에는 앞에 *를 붙여줘야지 비로소 그 주소가 가리키는 변수에 값을 할당할 수 있게 됨
	*mod = a % b; ///	 	 	 	선언할때 사용하는 *은 포인터로 선언하겠다는 의미이고, 식에 쓰일 때에는 '주소에 보관된 값' 을 사용하겠다는 의미
}
void ft_ultimate_div_mod(int *a, int *b) // ✅a와 b의 나눗셈. a가 가리키는 int에 몫을 저장, b가 가리키는 int에 나머지를 저장
{
	int div;
	int mod;

	div = *a / *b;
	mod = *a % *b;

	*a = div;
	*b = mod;
}
void ft_putstr(char *str) // ✅표준 출력에 문자열을 표시하는 함수
{
	int i;
	i = 0;

	while (str[i] != '\0')
	{
		write(1, &str[i], 1);
		i++;
	}
}
int ft_strlen(char *str) // ✅문자열의 문자 수를 세고 리턴하는 함수 (문자열 길이) >널문자 제외
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		i++;
	}
	return i;
}
void ft_rev_int_tab(int *tab, int size) // ✅정수의 배열을 거꾸로 뒤집는 함수. int의 포인터와 배열의 사이즈가 주어짐.
{
	int i;
	int tmp;

	i = 0;
	while (i < size / 2)
	{
		tmp = tab[i];
		tab[i] = tab[size - 1 - i];
		tab[size - 1 - i] = tmp;
		i++;
	}
}
void ft_sort_int_tab(int *tab, int size) // ✅정수의 배열을 오름차순으로 정렬하는 함수. 배열의 주소와 사이즈가 주어짐.
{
	//! 정렬 과정 (여러 차례의 비교 웨이브)
	///>	 4	1	0	9	7	2
	/// 	[4	1]	0	9	7	2
	/// 	[1	4]	0	9	7	2
	/// 	 1	[4	0]	9	7	2
	/// 	 1	[0	4]	9	7	2
	/// 	 1	0	[4	9]	7	2
	/// 	 1	0	[4	9]	7	2
	/// 	 1	0	4	[9	7]	2
	///	     1	0	4	[7	9]	2
	/// 	 1	0	4	7	[9	2]
	/// 	 1	0	4	7	[2	9]
	////> 	 1	0	4	7	2	9
	//// 	[1	0]	4	7	2	9
	//// 	[0	1]	4	7	2	9
	//// 	 0	[1	4]	7	2	9
	//// 	 0	[1	4]	7	2	9
	//// 	 0	1	[4	7]	2	9
	//// 	 0	1	[4	7]	2	9
	//// 	 0	1	4	[7	2]	9
	//// 	 0	1	4	[2	7]	9
	//// 	 0	1	4	2	[7	9]
	//// 	 0	1	4	2	[7	9]
	///> 	 0	1	4	2	7	9
	/// 	[0	1]	4	2	7	9
	/// 	[0	1]	4	2	7	9
	/// 	 0	[1	4]	2	7	9
	/// 	 0	[1	4]	2	7	9
	/// 	 0	1	[4	2]	7	9
	/// 	 0	1	[2	4]	7	9
	/// 	 0	1	2	[4	7]	9
	/// 	 0	1	2	[4	7]	9
	/// 	 0	1	2	4	[7	9]
	/// 	 0	1	2	4	[7	9]
	////> 	 0	1	2	4	7	9

	int i;
	int sorted;

	sorted = 0;
	while (!sorted) ///! 버블 정렬은 여러 차례의 비교 웨이브를 갖는다 그런데 몇번?
	{
		sorted = 1; //> 이번이 마지막 웨이브이기를 기도하며 1을 설정함
		i = 0;
		while (i < size - 1) //: 한 차례의 비교 웨이브
		{
			if (tab[i] > tab[i + 1])
			{
				ft_swap(&tab[i], &tab[i + 1]);
				sorted = 0;
				/// 이번 웨이브에서 스왑했다면, 배열이 정렬되지 않았을 수 있다
				/// sorted를 0으로 넘기므로써, 다음 웨이브를 예약
			}
			i++;
		}
	}
}

//!  C02
char *ft_strcpy(char *dest, char *src) // ✅NULL문자만큼 문자열을 복사하는 함수. 복사본의 주소를 리턴.
{
	///: hangyulp님 + hyunjunl님 + 스스로 정리
	/// dest가 src보다 길다면, src의 NULL 문자까지 복사해오기 때문에 dest는 src와 같은 길이가 된다
	/// dest가 src보다 짧으면, src의 NULL 문자까지 복사해오지 못해서 dest는 널문자를 잃어버리고 경계가 사라져 메모리 침범에 취약해진다
	/// dest가 src보다 짧으면, 버퍼 오버플로우가 발생한다. 무조건 실행 오류로 종료되거나 하지는 않는다
	/// src의 부분 문자열을 dest가 다 가져가서 dest는 NULL이 없는 문자열이되고 나머지 데이터는 엉뚱한 참조(메모리)가 가져가는 것으로 strcpy의 실행이 완료된다
	int i;
	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0'; /// 널을 찍기는 찍지만, 정말로 dest에 찍힐지 장담할 수 없다
	return dest;
}
char *ft_strncpy(char *dest, char *src, unsigned int n) // ✅N자리만큼 문자열을 복사하는 함수. 복사본의 주소를 리턴.
{
	///: hangyulp님 + 스스로 정리
	///  src가 n미만이면, 모자란 길이만큼 dest에 NULL 문자를 채운다. dest는 src와 같은 길이가 된다
	///  src가 n이상이면, src의 NULL 문자가 복사되지 않아서 dest는 처음 길이를 그대로 가진다. 복사된 데이터 이후에는 기존의 데이터가 뒤따른다.
	/// dest가 n미만이면, 이번에는 오버 플로우를 예상할 수 있기 때문에 컴파일 오류를 발생시킨다.
	unsigned int i;
	int over;

	over = 0;
	i = 0;
	while (i < n)
	{
		if (over == 0 && src[i] == '\0')
			over = 1;
		if (over)
			dest[i] = '\0';
		else
			dest[i] = src[i];
		i++;
	}
	return dest;
}
int ft_str_is_alpha(char *str) // ✅문자열에 알파벳만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('A' <= str[i] && str[i] <= 'Z') && !('a' <= str[i] && str[i] <= 'z'))
			return 0;
		i++;
	}
	return 1;
}
int ft_str_is_numeric(char *str) // ✅문자열에 숫자만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('0' <= str[i] && str[i] <= '9'))
			return 0;
		i++;
	}
	return 1;
}
int ft_str_is_lowercase(char *str) // ✅문자열에 소문자 알파벳만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('a' <= str[i] && str[i] <= 'z'))
			return 0;
		i++;
	}
	return 1;
}
int ft_str_is_uppercase(char *str) // ✅문자열에 대문자 알파벳만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('A' <= str[i] && str[i] <= 'Z'))
			return 0;
		i++;
	}
	return 1;
}
int ft_str_is_printable(char *str) // ✅문자열에 출력가능 문자만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!(32 <= str[i] && str[i] <= 126))
			return 0;
		i++;
	}
	return 1;
}
char *ft_strupcase(char *str) // ✅모든 소문자를 대문자로 변경하여 리턴하는 함수. 수정된 str을 반환.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if ('a' <= str[i] && str[i] <= 'z')
			str[i] = str[i] - 32;
		i++;
	}
	return str;
}
char *ft_strlowcase(char *str) // ✅모든 대문자를 소문자로 변경하여 리턴하는 함수. 수정된 str을 반환.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if ('A' <= str[i] && str[i] <= 'Z')
			str[i] = str[i] + 32;
		i++;
	}
	return str;
}
int ft_is_word(char c) /// 주어진 문자가 '영숫자' 이면 1을, '영숫자' 가 아니라면 0을 리턴하는 함수.
{
	int d;
	d = ('A' <= c & c <= 'Z') | ('a' <= c & c <= 'z') | ('0' <= c & c <= '9');
	return (d);
}
char *ft_strcapitalize(char *str) // ✅연속된 영숫자를 단어라고 할때, 단어의 첫글자는 대문자로, 나머지는 소문자로 변환하여 리턴하는 함수. 수정된 str을 반환.
{
	// 숫자 또는 알파벳 문자를 '영숫자' 라고 한다
	// 영숫자가 연속되는 것을 '단어' 라고 한다
	// 영숫자 아닌 모든 문자를 '공백' 이라고 한다

	/// "salut, comment tu vas ? 42mots quarante-deux; cinquante+et+un"
	/// "Salut, Comment Tu Vas ? 42mots Quarante-Deux; Cinquante+Et+Un"
	/// 단어의 첫글자는 대문자, 나머지는 소문자로 변환

	// 현재 문자가 영숫자가 아니라면 그대로 자신을 리턴
	// 현재 문자가 영숫자이면서 문자열의 첫번째이면 대문자로 변경
	// 현재 문자가 영숫자이면서 '공백'이 앞에 있으면 대문자로 변경
	// 현재 문자가 영숫자이면서 영숫자가 앞에 있으면 소문자로 변경

	int i;
	char *now;

	i = 0;
	while (str[i] != '\0')
	{
		now = &str[i];
		if (ft_is_word(*now)) /// 현재 문자가 영숫자이면서
		{
			if (i == 0) /// 문자열의 첫번째 ---> 대문자
				ft_strupcase(now);
			else if (!ft_is_word(str[i - 1])) /// 공백이 앞에 있음 ---> 대문자
				ft_strupcase(now);
			else if (ft_is_word(str[i - 1])) /// 영숫자가 앞에 있음 ---> 소문자
				ft_strlowcase(now);
		}
		i++;
	}
	return str;
}
unsigned int ft_strlcpy(char *dest, char *src, unsigned int size) // ✅N자리만큼 문자열을 복사하는 함수. 원본의 사이즈를 리턴.
{
	///: hangyulp님 + 스스로 정리
	/// strncpy와 동일하게 작동하지만, dest의 n번째 자리에 무조건 널 문자를 넣는다
	if (!size)
		return (ft_strlen(src)); // 사이즈가 0이면 바로 리턴
	unsigned int i;
	int over;

	over = 0;
	i = 0;
	while (i < size - 1) /// 다른 strcpy와는 다르게, 일부러 하나 빼먹은 만큼만 복사한다
	{
		if (over == 0 && src[i] == '\0')
			over = 1;
		if (over)
		{
			dest[i] = '\0';
			break;
		}
		else
			dest[i] = src[i];
		i++;
	}
	dest[i] = '\0'; /// 하나를 빼먹은 자리에는 널문자를 넣는다
	return (ft_strlen(src));
}
void ft_putstr_non_printable(char *str) // ✅문자열을 출력하는 함수. 출력불가 문자는 백슬래시와 함께 16진수(소문자) 모양으로 표시함.
{
	// Coucou\ntu vas bien ?	//:   아스키코드 10번은 개행 문자 \n이고, 출력불가 문자
	// Coucou\0atu vas bien ?   //:   10을 두자리 16진수로 바꿔서 \0a 모양으로 출력함
	unsigned char bf;
	char *hex;
	hex = "0123456789abcdef";
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		bf = (unsigned char)str[i];
		if (32 <= bf && bf <= 126) /// 확장아스키도 자신만의 출력 모양이 있지만, printable이 아니라고 정해서 미포함
			write(1, &bf, 1);		 /// printable은 그냥 그대로 출력하고, printable이 아니라면 변형해서 출력
		else
		{
			write(1, "\\", 1);
			write(1, &hex[bf / 16], 1);
			write(1, &hex[bf % 16], 1);
		}
		i++;
	}
}
void ft_put_address(unsigned long long bit64) /// '주소' 라는 64비트 정수를 16진수 16자리로 출력하는 함수
{
	char *dict;
	char conv[16];
	int i;

	dict = "0123456789abcdef";
	i = 16;
	while (i--)
	{
		conv[i] = dict[bit64 % 16];
		bit64 = bit64 / 16;
	}
	write(1, conv, 16);
}
void ft_put_contents_in_hex(unsigned char *str, int size) /// 메모리에 담긴 내용을 16진수로 출력하는 함수
{
	///  "ACCURATE"					"ACCURATE"
	///   ^							  ^
	///  65 / 16 == 4				 67 / 16 == 4
	///  65 % 16 == 1				 67 % 16 == 3
	char *dict;
	char digit[2];
	int i;

	dict = "0123456789abcdef";
	i = 1;
	while (i <= size)
	{
		digit[0] = dict[*str / 16];
		digit[1] = dict[*str % 16];
		write(1, digit, 2);
		if (i % 2 == 0)
			write(1, " ", 1);
		str++;
		i++; /// while문이 종료됐을때, i의 상태는 size+1
	}
	while (i <= 16)
	{
		write(1, "  ", 2); /// 위의 로직에서 digit 두개가 공백이었다고 상상하기
		if (i % 2 == 0)
			write(1, " ", 1);
		i++;
	}
}
void ft_write(char *str, int size) /// 출력불가 문자까지 온점으로 출력하는, 확장 write 함수
{
	int i;
	i = 0;
	while (i < size)
	{
		if (32 <= str[i] && str[i] <= 126)
			write(1, &str[i], 1);
		else
			write(1, ".", 1);
		i++;
	}
}
void *ft_print_memory(void *addr, unsigned int size) // ✅메모리 영역을 출력하는 함수.
{
	//: 각 라인은 세개의 구간으로 나뉘어져 있음.
	//: 1.  메모리 주소. 16진수로 나타냄.
	//: 2.  메모리 내용. 16진수로 나타냄. 내용 두개가 하나로 짝지어져 표시되고, 공백으로 구분.
	//: 3.  메모리 내용. 출력불가 문자는 점으로 대체함. 16글자를 한 줄에 다름.
	//: size가 0이면 아무것도 표시하지 않음
	///< $> ./ft_print_memory | cat -te
	///< 0000000107ff9f40: 426f 6e6a 6f75 7220 6c65 7320 616d 696e Bonjour les amin$
	///< 0000000107ff9f50: 6368 6573 090a 0963 0720 6573 7420 666f ches...c. est fo$
	///< 0000000107ff9f60: 7509 746f 7574 0963 6520 7175 206f 6e20 u.tout.ce qu on $
	///< 0000000107ff9f70: 7065 7574 2066 6169 7265 2061 7665 6309 peut faire avec.$
	///< 0000000107ff9f80: 0a09 7072 696e 745f 6d65 6d6f 7279 0a0a ..print_memory..$
	///< 0000000107ff9f90: 0a09 6c6f 6c2e 6c6f 6c0a 2000           ..lol.lol. .$
	///< $>
	///_ 00007ffee50789f0: 426f 6e6a 6f75 7220 6c65 7320 616d 696e Bonjour les amin
	///_ 00007ffee5078a00: 6368 6573 090a 0963 0720 6573 7420 666f ches...c. est fo
	///_ 00007ffee5078a10: 7509 746f 7574 0963 6520 7175 206f 6e20 u.tout.ce qu on
	///_ 00007ffee5078a20: 7065 7574 2066 6169 7265 2061 7665 6309 peut faire avec.
	///_ 00007ffee5078a30: 0a09 7072 696e 745f 6d65 6d6f 7279 0a0a ..print_memory..
	///_ 00007ffee5078a40: 0a09 6c6f 6c2e 6c6f 6c0a 2000           ..lol.lol. .
	///> 00007ffee50789c0: 4368 756e 6368 656f 6e20 6973 2062 6574 Chuncheon is bet
	///> 00007ffee50789d0: 7465 7220 7468 616e 2053 656f 756c 2120 ter than Seoul!
	///> 00007ffee50789e0: 3a29 203b 2900                          :) ;).
	//// 00007ffee50789c0: 4368 756e 6368 656f 6e20                Chuncheon
	///< 00007ffee50789c0: 4368 756e 6368 656f 6e20 6973 2000 0000 Chuncheon is ...
	///< 00007ffee50789d0: 0000 0000 0000 0000 2053 656f 756c 2120 ........ Seoul!
	///< 00007ffee50789e0: 3a29 203b 29                            :) ;)

	void *rewind;
	int line;

	rewind = addr;
	line = size / 16;
	while (line--)
	{
		ft_put_address((unsigned long long)addr);
		write(1, ": ", 2);
		ft_put_contents_in_hex((unsigned char *)addr, 16);
		ft_write(addr, 16);
		write(1, "\n", 1);
		addr += 16;
	}
	if (size % 16 > 0)
	{
		ft_put_address((unsigned long long)addr);
		write(1, ": ", 2);
		ft_put_contents_in_hex((unsigned char *)addr, size % 16);
		ft_write(addr, size % 16);
		write(1, "\n", 1);
	}
	return rewind;
}

//!	 C03
int ft_strcmp(char *s1, char *s2) // 🌸두 문자열을 비교하는 함수. 문자열이 완전히 일치하면 0을 리턴하고, 어긋나면 사전순으로 앞서는 쪽의 문자열을 통지함.
{
	///		dragonfly0️⃣		dragon0️⃣			dragonfly0️⃣		dragonfly0️⃣	dragonfly0️⃣		dragon0️⃣			0️⃣
	/// 	dragonfly0️⃣		dragonball0️⃣		dragonball0️⃣		dragon0️⃣		ball0️⃣				0️⃣ 				0️⃣
	int i;

	///:  128~255로 지정된 확장-아스키코드까지 비교하려면 255까지 커버가능해야함 (228 > 100 결과가, -28 < 100 되지않도록)
	///:  기존 0~127 vs 0~127의 비교 결과는 변하지 않음
	unsigned char *str1 = (unsigned char *)s1; ///   s1의 규격을, -128~127에서 0~255 으로 변경
	unsigned char *str2 = (unsigned char *)s2; ///   s2의 규격을, -128~127에서 0~255 으로 변경

	i = 0;
	while (str1[i] != 0) /// s1 또는 s2 가 널인 경우가 아니라, s1만이 널인 경우로 한정해도 똑같이 작동
	{
		if (str1[i] != str2[i])
			break;
		i++;
	}

	//!  크기순과 빠른순은 반대이므로 헷갈림을 주의
	//: 아스키 사전에서 왼쪽이 빠르다면 (왼쪽이 작다면) 음수를 리턴
	//: 아스키 사전에서 오른쪽이 빠르면 (오른이 작다면) 양수를 리턴
	//: 문자열이 동일하다면 0을 리턴
	return str1[i] - str2[i];
}
int ft_strncmp(char *s1, char *s2, unsigned int n) // 🌸두 문자열을 비교하는 함수. 일치하면 0 러턴. 사전순으로 앞서는 쪽를 알려줌. 앞에서 N자리 만큼만 비교함.
{
	///		dragonfly0️⃣		dragon0️⃣			dragonfly0️⃣		dragonfly0️⃣	dragonfly0️⃣		dragon0️⃣			0️⃣
	/// 	dragonfly0️⃣		dragonball0️⃣		dragonball0️⃣		dragon0️⃣		ball0️⃣				0️⃣ 				0️⃣
	unsigned int i;

	///:  128~255로 지정된 확장-아스키코드까지 비교하려면 255까지 커버가능해야함 (228 > 100 결과가, -28 < 100 되지않도록)
	///:  기존 0~127 vs 0~127의 비교 결과는 변하지 않음
	unsigned char *str1 = (unsigned char *)s1; ///   s1의 규격을, -128~127에서 0~255 으로 변경
	unsigned char *str2 = (unsigned char *)s2; ///   s2의 규격을, -128~127에서 0~255 으로 변경

	//: N은 강제조항이 아니라, 최대 N까지 비교하는 것을 의미하므로, 그 이전에 우열을 판정할 수 있다면 조기 종료될 수 있음
	i = 0;
	while (str1[i] != 0) /// s1 또는 s2 가 널인 경우가 아니라, s1만이 널인 경우로 한정해도 똑같이 작동
	{
		if (i >= n)
			return 0;
		if (str1[i] != str2[i])
			break;
		i++;
	}

	//!  크기순과 빠른순은 반대이므로 헷갈림을 주의
	//: 아스키 사전에서 왼쪽이 빠르다면 (왼쪽이 작다면) 음수를 리턴
	//: 아스키 사전에서 오른쪽이 빠르면 (오른이 작다면) 양수를 리턴
	//: 문자열이 동일하다면 0을 리턴
	return str1[i] - str2[i];
}
char *ft_strcat(char *dest, char *src) // 🌸두 문자열을 연결하는 함수. 받아주는쪽 문자열의 널문자부터 시작해서 주는쪽을 전부 이어붙이고 널문자로 마무리. 합본을 리턴.
{
	//:  dest에 할당된 capacity는 정해져있다. 받는쪽과 주는쪽 문자열의 length를 합해도 capacity를 넘지않아야한다
	int i;
	int begin_of_null;

	i = 0;
	while (dest[i] != '\0')
		i++;
	begin_of_null = i; ///  dest[ begin_of_null ] 에는 널이 들어있음

	i = 0;
	while (src[i] != '\0')
	{
		dest[begin_of_null + i] = src[i]; /// dest의 널자리부터 src의 모든 원소를 채우기 시작함
		i++;
	}
	dest[begin_of_null + i] = '\0'; // 끝자리에 널문자를 박어주므로써 문자열의 경계를 부여함 (널-터미네이트)

	return dest;
}
char *ft_strncat(char *dest, char *src, unsigned int nb) // 🌸두 문자열을 연결하는 함수. N자리 만큼 복사, 받아주는쪽 널문자 자리부터 붙여넣음. 널문자로 마무리.
{
	//:  cpy함수는 앞에서부터 데이터를 붙여넣고(복사하고), cat함수는 빈공간에서부터 데이터를 붙여넣는다(복사한다)
	int i;
	int begin_of_null;

	i = 0;
	while (dest[i] != '\0')
		i++;
	begin_of_null = i; /// dest[ begin_of_null ] 위치에는 널이 들어있음

	i = 0;
	while (nb && src[i] != '\0')
	{
		dest[begin_of_null + i] = src[i]; /// dest의 널자리부터 src의 모든 원소를 채우기 시작함
		i++;
		nb--;
	}
	dest[begin_of_null + i] = '\0'; // 끝자리에 널문자를 박아주므로써 문자열의 경계를 부여함 (널-터미네이트)

	return dest;
}
unsigned int ft_strlcat(char *dest, char *src, unsigned int size) // 🌸두 문자열을 연결하는 함수.
{
	///!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
	///>  [ ===================================SIZE====================================== ] 기준 size
	///:  [ <-----------len(dst)------------>0=========================================== ]	len(dest) < SIZE - 1
	///   [ <-----------len(dst)------------><-----len_src----->0======================== ]	적재: size한도내에서 dst가 채워진 분량을 제외한만큼 src를 채움
	///   [ <-----------len(dst)------------><------------len_src---------->0============ ]	적재
	///   [ <-----------len(dst)------------><------------len_src---------------------->0 ]	적재: 딱맞는 경우
	///   [ <-----------len(dst)------------><------------------------------------len_sr0 ]	적재: 한도를 초과한다면 src의 일부만 채움 (SIZE - len(dst) - 1 개)
	///<  [ <-----------len(dst)------------><-----len_src----->========================= ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
	///<  [ <-----------len(dst)------------><------------len_src---------->============= ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
	///<  [ <-----------len(dst)------------><------------len_src---------------------->= ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 = 0, 꽉찬 상태)
	///<  [ <-----------len(dst)------------><------------------------------------len_src ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)

	///!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
	///>  [ ===================================SIZE====================================== ] 기준 size
	///:  [ <--------------------------------len(dst)---------------------------------->0 ]	len(dest) = SIZE - 1
	///   [ <--------------------------------len(dst)---------------------------------->0 ]	적재: 한도를 초과하여 src를 채울 수 없음
	///<  [ <--------------------------------len(dst)---------------------------------->0 ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)

	///!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
	///>  [ ==================SIZE=====================---------------------------------- ] 기준 size
	///:  [ <------len(dst)------->0===================---------------------------------> ]	len(dest) < SIZE - 1
	///   [ <------len(dst)-------><--len_src-->0======---------------------------------> ]	적재: size한도내에서 dst가 채워진 분량을 제외한만큼 src를 채움
	///   [ <------len(dst)-------><---len_src--->0====---------------------------------> ]	적재
	///   [ <------len(dst)-------><-----len_src----->0---------------------------------> ]	적재: 딱맞는 경우
	///   [ <------len(dst)-------><------------len_sr0---------------------------------> ]	적재: 한도를 초과한다면 (널문자부터 확보하고) src의 일부만 채움 (SIZE -len(dst) -1 개)
	///<  [ <------len(dst)-------><--len_src-->=======---------------------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
	///<  [ <------len(dst)-------><---len_src--->=====---------------------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
	///<  [ <------len(dst)-------><-----len_src----->=---------------------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 = 0, 꽉찬 상태)
	///<  [ <------len(dst)-------><------------len_src---------->----------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)

	///!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
	///>  [ ==================SIZE=====================---------------------------------- ] 기준 size
	///:  [ <------len(dst)-------------------------->0---------------------------------> ]	len(dest) = SIZE - 1
	///   [ <------len(dst)-------------------------->0---------------------------------> ]	적재: 한도를 초과하여 src를 채울 수 없음 (SIZE -len(dst) -1 == 0개)
	///   [ <------len(dst)-------------------------->0---------------------------------> ]	적재
	///<  [ <------len(dst)--------------------------><--len_src-->---------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
	///<  [ <------len(dst)--------------------------><-----len_src----->---------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)

	///!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
	///>  [ ==================SIZE=====================---------------------------------- ] 기준 size
	///:  [ <------len(dst)---------------------------------->0-------------------------> ]	len(dest) > SIZE - 1     불가능한 사이즈
	///   [ <------len(dst)---------------------------------->0-------------------------> ]	적재: 한도를 초과하여 src를 채울 수 없음
	///   [ <------len(dst)---------------------------------->0-------------------------> ]	적재
	///   [ <------len(dst)---------------------------------->0-------------------------> ]	적재
	///<  [ ==================SIZE=====================<--len_src-->--------------------> ]	리턴값 == SIZE + src길이  (size -리턴값 -1 = src의 길이+1 이 음수로)
	///<  [ ==================SIZE=====================<-----len_src----->--------------> ]	리턴값 == SIZE + src길이  (size -리턴값 -1 = src의 길이+1 이 음수로)
	///&  [ <------len(dst)----------------------------------><--len_src-->-------------> ] 평소면 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
	///&  [ <------len(dst)----------------------------------><-----len_src----->-------> ]	평소면 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)

	///!  리턴값의 해석 (뇌피셜)
	///:  일반적으로, dst길이 + src길이를 리턴한다.
	///:  리턴값의 응용1  [ 리턴값 - src길이 ] == src의 시작 위치
	///   src가 시작하는 위치는 오직 이 순간에만 기록할 수 있다. "abeeebeee" 에서 어느 beee가 src인가? 하는 식으로 판정할 수 없다. 기록하지 않으면 나중에 src만 찾아볼 수 없다.
	///   리턴값을 시작점으로, 보존된 만큼 src를 출력하는데 쓰일 수 있다. 보존된게 있다면 보존된 만큼을, 없다면 ""를 출력할 수 있다.
	///:  리턴값의 응용2  [ size - 리턴값 - 1 ]
	///   0이상이면 남은 공간을 의미하며, src가 잘리지 않았다는 것을 알 수 있다.
	///   0미만이면 남은 공간이 음수로서, 부족한 용량을 의미하며, src가 얼마나 잘렸는지 알 수 있다.
	///:  불가능한 size를 전달받은 경우에는 [ SIZE + src길이 ] 를 리턴한다.
	///	  (src의 길이 + 1) 만큼이 음수로 주어져서, 널문자까지 확보해서 src가 들어가기에 모자란 공간을 알려준다.

	//:  총 size개 만큼을 dest에다가 저장하는데, 그 중의 한 개는 반드시 널 문자.

	unsigned int i;
	unsigned int begin_of_null;

	i = 0;
	while (dest[i] != '\0')
		i++;
	begin_of_null = i; /// dest + begin_of_null 위치에는 널이 들어있음, 널문자를 제외한 dest의 길이이기도 함

	if (size <= begin_of_null)
		return ft_strlen(src) + size; /// 비정상적인 사이즈인 경우, src의 길이 + size를 리턴하라는 주문

	i = 0;
	while (i < size - 1 - begin_of_null && src[i] != '\0') //> 후자로 마쳤으면 몽땅 복사한것이고, 전자로 마쳤으면 한도 만큼 복사한 것
	{
		dest[begin_of_null + i] = src[i]; /// dest의 널자리부터 src의 모든 원소를 채우기 시작함
		i++;
	}
	dest[begin_of_null + i] = '\0'; // 끝자리에 널문자를 박아주므로써 문자열의 경계를 부여함 (널-터미네이트)

	return ft_strlen(src) + begin_of_null; //! dest는 현재 덮어쓰기된 상태이며, 문제가 요구하는 리턴값은 처음 dest의 길이임
}
char *ft_strstr(char *str, char *to_find) // 🌸특정 문자열을 포함하는지 확인하고, 포함한다면 문자열의 시작 위치를 리턴함. 포함하지 않는다면 널 포인터를 리턴함.
{
	int i;
	i = 0;
	if (to_find[0] == '\0') /// If needle is an empty string, haystack is returned; 이라는 구절이 맨에 있기 때문에 일단 넣어줬음
		return str;

	while (str[i] != '\0')
	{
		if (str[i] == to_find[0])
			if (ft_strncmp(str + i, to_find, ft_strlen(to_find)) == 0) // to_find 전체를 읽어서, str의 str + i 이후 문자열과 일치하는지 확인
				return (str + i);
		i++;
	}
	return NULL;
}

//!  C04
int ft_strlen(char *str);  //> 🌸 C01  문자열의 문자 수를 세고 리턴하는 함수 (문자열 길이)
void ft_putstr(char *str); //> 🌸 C01  표준 출력에 문자열을 표시하는 함수
void ft_putnbr_(int nb);   //> 🌸 C00  숫자를 문자로 표시하는 함수
int ft_atoi(char *str)	   // 🌸문자열에서 수를 발굴하여 리턴하는 함수
{
	///: 문제 조건
	/// 문자열은 공백으로 시작할 수 있음. 공백은 isspace(3) 으로 알 수 있음.
	/// 문자열은 +-부호가 등장할 수 있고, 마이너스 부호가 짝수인지 홀수인지에 따라서 부호를 어떻게 출력할지 결정함.
	/// 마지막으로 10진수 숫자들이 등장함.
	/// 문자열이 중단될때까지 숫자를 읽어들이고 반환해야함
	/// 오버플로우나 언더플로우를 신경쓰지 않아야 함
	///  $>./a.out " ---+--+1234ab567"
	///  -1234
	int i;
	int res;
	int sign;

	i = 0;
	res = -1;
	sign = 1;
	while (str[i] != '\0')
	{
		if ('0' <= str[i] && str[i] <= '9') // 지금 숫자인가?
			res = 10 * res * (res != -1) + str[i] - '0';
		/// res = res * (res != -1);   		// res가 -1 이면 0으로 초기화되어 비로소 숫자에 진입을 의미함. 이미 -1이 해제됐다면 아무 일도 일어나지 않음.
		/// res = 10 * res + str[i] - '0';  // 새로운 숫자를 끝자리로 추가함
		else if (res == -1 && str[i] == '-') // 숫자에 진입한적 없으면서, 지금 마이너스 부호인가?
			sign = -sign;
		else if (res != -1) // 지금 숫자가 아닌데, 숫자에 진입한적 있는가? (== 숫자에 있다가 벗어난 상황)
			break;			// 반복문을 빠져나와서 리턴문

		if (str[i] == '+' || str[i] == '-')					   // 지금 부호인가?
			if (str[i + 1] != '+' && str[i + 1] != '-')		   // 부호가 아닌 것이 뒤따르는가? (연속된 부호가 아닌가)
				if (!('0' <= str[i + 1] && str[i + 1] <= '9')) // 숫자가 아닌 것이 뒤따르는가? (연속된 부호 끝에 오는 것은 숫자여야한다)
					return 0;
		i++;
	}
	return res * sign * (res != -1); // 부호를 붙여서 리턴. (단, 숫자에 진입한 적이 없다면 무조건 0을 리턴)
}
int vaild_base(char *base) /// 진법-체계가 정상적인 집합인지 확인하고, 정상이라면 몇 진수인지 리턴하는 함수
{
	int i;
	int exist[256];
	unsigned char bf;

	i = 0;
	while (i < 256)
		exist[i++] = 0;

	i = 0;
	while (base[i] != 0)
	{
		bf = (unsigned char) base[i];
		exist[(int)bf]++;
		i++;
		if (bf == '-' || bf == '+' || bf == ' ' || exist[(int)bf] >= 2)
			return 0;
		if (bf == '\t' || bf == '\n' || bf == '\v' || bf == '\f' || bf == '\r')
			return 0;
	}

	return i;
}
void ft_putnbr_base(int nbr, char *base) // 🌸정수를 주어진 진법-체계로 변환하여 출력하는 함수
{
	/// 진법-체계는 숫자를 묘사하기 위해서 사용될 수 있는 모든 문자를 들고있음
	/// "0123456789" 는 10진수를 표현하는 일반적인 진법-체계이다
	/// "0123456789ABCDEF" 는 16진수를 표현하는 일반적인 진법-체계이다
	/// "poneyvif" 는 8진수를 표현하는 일반적인 진법-체계이다
	/// 함수는 음수를 처리해야함
	/// 진법-체계의 문자가 하나 뿐이거나, 비었거나, 중복되거나, +- 기호가 존재한다면 아무것도 출력하지 않음

	char conv[33];
	char start;
	int i;
	int nary;
	long long n;

	n = (long long)nbr;
	nary = vaild_base(base);
	if (nary < 2)
		return;
	if (n < 0)
	{
		write(1, "-", 1);
		n = -n;
	}
	i = 33;
	start = i - 1; // 시작위치를 마지막 자리로 초기화하면, nb가 0일때 한번도 숫자를 못만나서 0000000000 출력되는 것을 방지
	while (i--)
	{
		conv[i] = base[n % nary];
		n = n / nary;
		if (conv[i] != base[0]) // 수가 몇 자린지 알아내기 (앞에서 어느 인덱스부터 숫자가 등장하는지)
			start = i;
	}
	write(1, conv + start, 33 - start); // 숫자가 처음 나오는 시점에서부터, 말단까지 출력
}
int is_custom_number(char ch, char *base) /// 특정한 문자가 base에서 정의하는 커스텀 숫자에 해당하는지 확인하고, 해당한다면 그 연번을 리턴하는 함수
{
	int i;

	i = 0;
	while (base[i] != '\0' && ch != base[i])
		i++;
	return i;
}
int ft_atoi_base(char *str, char *base) // 🌸문자열에서 '진법-체계'를 기준으로 수를 발굴하여, 10진법으로 변환하고 리턴하는 함수.
{
	int i;
	int res;
	int sign;
	int nary;

	i = -1;
	res = -1;
	sign = 1;
	nary = vaild_base(base);
	if (nary < 2)
		return 0;
	while (str[++i] != '\0')
	{
		if (is_custom_number(str[i], base) < ft_strlen(base)) 						// 지금 '커스텀' 숫자인가? 그렇다면 몇번째 수인가?
			res = nary * res * (res != -1) + is_custom_number(str[i], base);
		else if (res == -1 && str[i] == '-') 										// 숫자에 진입한적 없으면서, 지금 마이너스 부호인가?
			sign = -sign;
		else if (res != -1) 														// 지금 숫자가 아닌데, 숫자에 진입한적 있는가? (== 숫자에 있다가 벗어난 상황)
			break;																	// 반복문을 빠져나와서 리턴문
		if (str[i] == '+' || str[i] == '-')					 						// 지금 부호인가?
			if (str[i + 1] != '+' && str[i + 1] != '-')		 						// 부호가 아닌 것이 뒤따르는가? (부호의 연속이 끝난다)
				if (!(is_custom_number(str[i + 1], base) < ft_strlen(base)))		// 숫자가 아닌 것이 뒤따르는가? (연속된 부호 끝에 오는 것은 숫자여야한다)
					return 0;
	}
	return res * sign * (res != -1); // 부호를 붙여서 리턴. (단, 숫자에 진입한 적이 없다면 무조건 0을 리턴)
}

//!  C05
int ft_iterative_factorial(int nb) // 🌸팩토리얼을 리턴하는 반복문 함수. 0의 계승은 1을 리턴.
{
	int ret;

	if (nb == 0 || nb == 1)
		return 1;
	if (nb < 0)
		return 0;
	ret = 1;
	while (nb)
	{
		ret = ret * nb; /// nb * (nb-1) * (nb-2) * (nb-3) *  ~~~  * 2 * 1
		nb--;
	}
	return ret;
	///: 인자가 유효하지 않다면 0을 리턴함, 오버플로를 처리해서는 안 되며, 리턴값은 정의되지 않습니다
	/// 인자가 유효하지 않다는 것이 무슨 뜻일까..?
	/// 함수 입장에서는 형변환된 값만 받지, 원래 값이 어땠는지는 흔적이 남지않는다.
	/// 원본의 성질이 아니라, 지금 손에 들고있는 것의 성질만을 알 수 있다. 외관적인 판단만이 가능하고 최선이 된다.
	/// 따라서 인자가 유효하지 않다는 것은, 현실적으로, 지금 손에 들고있는 것이 유효하지 않다는 것이다
	/// (정의되지 않은) 음수 팩토리얼을 구해야하거나, 리턴값이 오버플로우를 일으킬 것으로 예상되는 경우이다
	/// 그런데 오버플로를 처리하지 말라고 했으니까 유일하게 이상한 것은 음수인 경우이다
}
int ft_recursive_factorial(int nb) // 🌸팩토리얼을 리턴하는 재귀 함수. 0의 계승은 1을 리턴.
{
	if (nb == 0 || nb == 1)
		return 1;
	if (nb < 0)
		return 0;
	if (nb > 1)
		return nb * ft_recursive_factorial(nb - 1);
	return 0;
	/// 인자가 유효하지 않다면 0을 리턴함, 오버플로를 처리해서는 안 되며, 리턴값은 정의되지 않습니다
}
int ft_iterative_power(int nb, int power) // 🌸거듭제곱을 리턴하는 반복문 함수. 0보다 작은 제곱은 0을, 0의 0승은 1을 반환하기로 함
{
	int ret;

	if (power < 0)
		return 0;
	if (power == 0)
		return 1;
	ret = 1;
	while (power) // power가 카운트 다운되는 횟수만큼, nb를 누적해서 곱함 (5를 집어넣으면 5,4,3,2,1 일때 통과되어 5번 실행됨)
	{
		ret = ret * nb; /// nb * nb * nb *  ~~~  * nb * nb
		power--;
	}
	return ret;
}
int ft_recursive_power(int nb, int power) // 🌸거듭제곱을 리턴하는 재귀 함수. 0보다 작은 제곱은 0을, 0의 0승은 1을 반환하기로 함
{
	if (power > 0)
		return ft_recursive_power(nb, power - 1) * nb;
	if (power == 0)
		return 1;
	return 0;
}
int ft_fibonacci(int index) // 🌸index번째 피보나치수를 리턴하는 재귀 함수
{
	/// 피보나치 수열의 첫번째 항은 0번 인덱스에 있음
	/// 피보나치 수열은 0, 1, 1, 2 으로 시작하기로 함
	/// index가 0보다 작다면 -1을 리턴함
	///		i		0	1	2	3	4	5	6	7	8	9	10	11	12		13		14
	///		F(i)	0	1	1	2	3	5	8	13	21	34	55	89	144		233		377

	if (index < 0)
		return -1;
	if (index == 0)
		return 0;
	if (index == 1)
		return 1;

	return ft_fibonacci(index - 2) + ft_fibonacci(index - 1);
}
int ft_sqrt(int nb) // 🌸제곱근이 존재한다면 리턴하는 함수. 허수는 0을 리턴.
{
	int i;
	i = 0;
	while (i++ < nb)
		if (i * i == nb)
			return i;
	return 0;
}
int ft_is_prime(int nb) // 🌸소수이면 1을 리턴하고, 아니면 0을 리턴. (0과 1은 소수 아님)
{
	long long int i;

	if (nb < 2)
		return 0;
	if (nb == 2)
		return 1;
	i = 2;
	while (i * i <= nb)
	{
		if (nb % i == 0)
			return 0;
		i++;
	}

	/// N = A*B 에서, A가 점점 커지면  B는 점점 작아진다
	/// A가 점점 커지면서 N의 약수인지 검사한다
	/// A가 루트N 근처에 이르었을때, B도 루트N 근처에 이른다
	/// A가 루트N 을 넘어서면, B는 루트N 보다 작아진다
	/// 루트N 보다 작은 수에 대해서는 A를 통해서 이미 검사하였으므로 중복 검사가 된다
	/// 1부터 루트N 만큼만 i를 증가시켜서 나누어 떨어지는지만 검사하면 모든 약수를 다 검사할 수 있다
	/// 루트 연산을 쓸 수 없으므로 i * i <= nb 으로 대체한다

	return 1;
}
int ft_find_next_prime(int nb) // 🌸주어진 수 이상의, 가장 가까운 소수를 리턴하는 함수
{
	while (!ft_is_prime(nb))
		nb++;
	return nb;
}
int ft_ten_queens_puzzle(void) // 🔴10x10 체스판에서, 퀸 10개를 안전하게 배치할 수 있는 모든 방법을 출력 (재귀 사용)
{
	return 0;
	/// 열 번호는 0부터 시작함
	/// 첫번째 숫자는 첫번째 퀸이 놓일 수 있는 열 좌표를 출력하고, N번째 숫자는 N번째 퀸이 놓일 수 있는 열 좌표를 출력함
	/// 출력 이외에도, 퀸을 배치하는 방법의 총 갯수를 리턴함
	/// $>./a.out | cat -e|
	/// 0257948136$
	/// 0258693147$
	/// ...
	/// 4605713829$
	/// 4609582731$
	/// ...
	/// 9742051863$
	/// $>
}
void kth_while(int K, int N, char *dec, char *exist)
{
	dec[K] = '0';
	while (dec[K] <= '9')
	{
		if (K != N)
			kth_while(K + 1, N, dec, exist);
		if (K == N)
		{
			write(1, dec + 1, N);
			write(1, ", ", 2);
		}
		dec[K]++;
	}
}
void print_combn(int n)
{
	char dec[11];
	char exist[11];
	dec[0] = '0';

	kth_while(1, n, dec, exist);
	write(1, "\n", 1);
}

//!  C06 ( main함수 필수 )
///: ft_print_program_name.c	---	🌸자신의 이름을 출력하는 프로그램
///			$>./a.out | cat -e ./a.out$
///			$>
////: ft_print_params			---	🌸주어진 인자를 출력하는 프로그램
//// command line과 같은 순서로 한줄에 하나씩 출력
//// argv[0]를 제외한 모든 인자를 출력
////		$>./a.out test1 test2 test3 | cat -e
////		test1$
////		test2$
////		test3$
////		$>
///: ft_rev_params				---	🌸주어진 인자를 역순으로 출력하는 프로그램
/// command line의 역순으로 한줄에 하나씩 출력
/// argv[0]를 제외한 모든 인자를 출력
///			$>./a.out test1 test2 test3 | cat -e
///			test3$
///			test2$
///			test1$
///			$>
////: ft_sort_params			---	🌸주어진 인자를 아스키 순서로 출력하는 프로그램
//// (중의적) ⭕️ 인자들 사이에 아스키 우선순위가 높은 것부터 출력?
//// (중의적) ❌ 인자로 받은 문자열 하나하나를 아스키순으로 정렬해서 출력?
//// argv[0]를 제외한 모든 인수를, 한줄에 하나씩 출력
////		$>./a.out abcd z123 0ddas Bcde
////		0ddas
////		Bcde
////		abcd
////		z123
////		$>				새 명령줄이 z123 뒤에 따라붙지 않는 것을 볼때, 인자 하나하나 마다 개행 문자가 따라 붙을 것

//!  C07
char *ft_strdup(char *src) // 🔴strdup의 동작을 재현하는 함수
{
	src = "";
	return NULL;
}
int *ft_range(int min, int max) // 🔴min이상 max미만의 모든 정수를 포함하는 배열을 리턴하는 함수
{
	min = 0;
	max = 0;
	return NULL;
	///  (max <= min) 이라면 널포인터를 리턴
}
int ft_ultimate_range(int **range, int min, int max) // 🔴min이상 max미만의 모든 정수를 포함하는 배열 ...... 하는 함수
{
	min = 0;
	max = 0;
	return **range;
	//&  Create a function ft_ultimate_range which allocates and assigns an array of ints.
	///  (max <= min) 이라면 범위는 NULL을 가리키고, 리턴값은 0이어야함.
	/// 범위의 크기를 리턴함. 오류시 -1을 리턴함.
}
char *ft_strjoin(int size, char **strs, char *sep) // 🔴문자열들을 sep를 기준으로 연결하여 리턴하는 함수
{
	size = 0;
	**strs = 0;
	*sep = 0;
	return NULL;
	/// size는 strs의 "문자열" 갯수
	/// size가 0이라면, free() 할 수 있는 빈 문자열을 리턴
}
char *ft_convert_base(char *nbr, char *base_from, char *base_to) // 🔴특정한 진법 표현으로 주어진 숫자를 또다른 진법 표현으로 변환하는 함수
{
	*nbr = 0;
	*base_from = 0;
	*base_to = 0;
	return 0;
	/// nbr, base_from, base_to 는 수정할 수 없을 수도 있음
	/// nbr은 ft_atoi_base 에서 사용되는 진법-체계의 문자와 같은 방식임
	/// + - 부호와 공백 문자를 유의하시오
	//& The number represented by nbr must fit inside an int.
	/// 진법이 잘못되었다면 NULL을 리턴
	/// 반환된 숫자는 (진법화된 숫자 문자열) 공백이나 +가 없으며, 필요한 경우 -를 하나만 붙일 수 있음
}
char **ft_split(char *str, char *charset) // 🔴구분자를 기준으로 문자열을 분할하고, 분할된 문자열을 인덱싱할 수 있는 모음을 리턴하는 함수
{
	*str = 0;
	*charset = 0;
	return NULL;
	/// charset의 문자 하나하나를 구분자로 사용
	/// 구분 기호로 둘러쌓여있던 문자열의 주소가 포함된 모음을 리턴
	/// 모음의 마지막 원소는 0으로 모음의 끝을 나타냄
	/// 모음에는 빈 문자열이 없음, 연속된 구분자는 하나의 구분자랑 같은 결과를 만듦
	/// 인자는 수정할 수 없음
}

//!  C08 ( 헤더 파일 .h 을 만드시오,  orminette -R CheckDefine 옵션으로 실행함 )
#ifndef FT_H /// 🔴아래 프로토타입을 모두 포함하는 ft.h
#define FT_H
void ft_putchar(char c);
void ft_swap(int *a, int *b);
void ft_putstr(char *str);
int ft_strlen(char *str);
int ft_strcmp(char *s1, char *s2);
#endif

///: 아래 프로그램이 적절하게 컴파일되고 실행될 수 있게하는 ft_boolean.h 🔴
#ifndef FT_BOOLEAN_H
#define FT_BOOLEAN_H
//#include <unistd.h>
#define TRUE 1
#define FALSE 0
#define SUCCESS 0
#define EVEN(i) i % 2 == 0
#define EVEN_MSG "I have an even number of arguments.\n"
#define ODD_MSG "I have an odd number of arguments.\n"
typedef int t_bool;
void ft_putstr(char *str);
t_bool ft_is_even(int nbr);
#endif
/// void ft_putstr(char *str)
/// {
/// 	while (*str)
/// 	write(1, str++, 1);
/// }
t_bool ft_is_even(int nbr)
{
	return ((EVEN(nbr)) ? TRUE : FALSE);
}
int Main(int argc, char **argv)
{
	(void)argv;
	if (ft_is_even(argc - 1) == TRUE)
		ft_putstr(EVEN_MSG);
	else
		ft_putstr(ODD_MSG);
	return (SUCCESS);
}

///: 인자를 절대값으로 변환하는 ABS라는 매크로를 포함하는 ft_abs.h 🔴
#ifndef FT_ABS_H
#define FT_ABS_H
#define ABS(Value) Value < 0 ? -Value : Value
#endif

///: 아래 프로그램이 적절하게 컴파일되고 실행될 수 있게하는 ft_point.h 🔴
#ifndef FT_POINT_H
#define FT_POINT_H
//#include <unistd.h>
typedef struct s_point
{
	int x;
	int y;
} t_point;
void set_point(t_point *point);
#endif
// #include "ft_point.h"
void set_point(t_point *point)
{
	point->x = 42;
	point->y = 21;
}
int MaIn(void)
{
	t_point point;
	set_point(&point);
	return (0);
}

struct s_stock_str *ft_strs_to_tab(int ac, char **av) // 🔴av의 데이터를 이용해서 s_stock_str 구조체를 생성하는 함수
{
	/// 구조체가 정의되어있는 ft_stock_str.h 파일이 제공됨
	///		typedef struct s_stock_str {
	///			int size; // 문자열의 길이
	///			char *str; // 문자열
	///			char *copy; // 문자열의 사본?
	///		} t_stock_str;
	/// av의 order을 따라야한다
	/// • The returned array should allocated in memory and its last element’s str set to 0, this will mark the end of the array.
	/// 에러가 발생한다면 NULL 포인터를 리턴한다
	ac = 0;
	av = NULL;
	return NULL;
}
void ft_show_tab(struct s_stock_str *par) // 🔴stock_str 구조체의 내용을 출력하는 함수
{
	par = NULL;
	/// • For each element, we’ll display:
	/// ◦ the string followed by a ’\n’
	/// ◦ the size followed by a ’\n’
	/// ◦ the copy of the string (that could have been modified) followed by a ’\n’
	/// • We’ll test your function with our ft_strs_to_tab (previous exercise). Make it work according to this !
}

///!  C09
////: libft 🔴실행하면 컴파일이 수행되고 libft.a라는 라이브러리가 만들어지는, libft_creator.sh라는 쉘 스크립트 만들기
//// 라이브러리에 아래 함수들이 모두 포함되어야 함
////> 		void ft_putchar(char c);
////> 		void ft_swap(int *a, int *b);
////> 		void ft_putstr(char *str);
////> 		int ft_strlen(char *str);
////> 		int ft_strcmp(char *s1, char *s2);
////		gcc -Wall -Werror -Wextra -c
////		gcc -Wall -Werror -Wextra -c ft_putchar.c ft_putstr.c ft_strcmp.c ft_strlen.c ft_swap.c
//// 		ar -rc
//// 		ar -rc libft.a ft_putchar.o ft_putstr.o ft_strcmp.o ft_strlen.o ft_swap.o
///: Makefile 🔴libft.a 라이브러리를 컴파일하는 Makefile 만들기
/// file 명령어가 Magicfile 을 매개로 파일의 타입을 판정하듯이
///	make 명령어는 Makefile  을 매개로 커스텀 명령어를 실행한다
/// make 명령어는 Makefile  의 명세를 기반으로 명령어를 실행한다
///			file  magicfile  파일명		---->	 파일의 타입을 판정
///			make  Makefile   명령어		---->	 커스텀 명령어를 실행
/// Makefile 명령어는 주로 파일을 생성하는 목적으로 정의된다
/// 쉘 스크립트가 미리 저장해둔 여러 줄의 명렁어를 실행하듯이
/// 메이크 파일도 미리 설정해둔 흐름에 따라서, 사용자가 정의한 명령어를 실행한다
///			sh		libft.sh
///			make	Makefile	all
///			make	Makefile	clean
/// Makefile 은 다음을 만족한다
///> 		실행되는 모든 명령어를 출력함
///> 		불필요한 명령어를 작동시키지 않음
///> 		srcs 폴더에서 다음 파일을 얻음: ft_putchar.c, ft_swap.c, ft_putstr.c, ft_strlen.c, ft_strcmp.c
///> 		includes 폴더에서 헤더 파일을 얻음: ft.h
///> 		.c 파일을 cc 명령어와 -Wall -Wextra -Werror 옵션으로 컴파일함
///> 		lib는 과제의 루트 폴더에 있어야함
///> 		.o 파일들은 .c 파일들과 같은 폴더에 있어야함
///> 		메이크파일은 다음과 같은 룰을 포함해야함: clean, fclean, re, all, libft.a
///> 		make의 실행은 make all의 실행과 같아야함
///> 		all 룰은 make libft.a와 같아야함
///> 		clean 룰은 모든 임시 파일을 삭제해야함
///> 		fclean 룰은 make clean의 실행과 더불어서 make all로 만들어진 모든 바이너리 파일을 삭제해야함
///> 		re 룰은 fclean에 이어서 make all을 실행해야함
///> 		쓸데없는 컴파일을 하지 않아야함
/// 		CC = gcc
/// 		FLAGS = -Wall -Wextra -Werror
/// 		DEPS = includes
/// 		OBJDIR = srcs
///
/// 		TARGET =  ft_putchar.o ft_putstr.o ft_strcmp.o ft_strlen.o ft_swap.o
/// 		OBJS = ${addprefix $(OBJDIR)/, $(TARGET)}
///
/// 		%.o : %.c
/// 			$(CC) $(FLAGS) -c $< -o $@ -I $(DEPS)
///
/// 		all: libft.a
///
/// 		clean:
/// 			rm -f $(OBJS)
///
/// 		fclean: clean
/// 			rm -f libft.a
///
/// 		re: fclean all
///
/// 		libft.a: $(OBJS)
/// 			ar -rc libft.a $^

char **ft_split(char *str, char *charset); //> 🔴 C07  구분자를 기준으로 문자열을 분할하고, 분할된 문자열을 인덱싱할 수 있는 모음을 리턴하는 함수

///!  C10
////: display_file		--- 00🔴
//// 인자로 지정된 파일의 내용만 표준 출력에 표시하는 ft_display_file이라는 프로그램을 만듭니다.
//// 제출 디렉터리에는 다음과 같은 규칙이 있는 Makefile이 있어야 합니다: all, clean, fclean
//// malloc 함수는 금지되어 있습니다. 고정 크기 배열만 사용해야합니다.
//// 인자로 제공되는 모든 파일은 유효합니다.
////> 인자가 없으면 File name missing 을 출력합니다.
////> 인자가 둘 이상이면 Too many arguments 을 출력합니다.
////> 파일을 읽을 수 없으면 Cannot read file 을 출력합니다.
///: ft_cat				--- 01🔴cat 명령어와 동일한 기능을 수행하는 프로그램
/// 옵션을 처리하지 않아도 됩니다.
/// 제출 디렉터리에는 다음과 같은 규칙이 있는 Makefile이 있어야 합니다: all, clean, fclean
/// 변수 errno를 사용할 수 있습니다.
/// 승인된 모든 함수의 man을 읽어야 합니다.
/// 고정 크기 배열만 사용해야합니다.
/// 이 배열의 크기는 30ko 미만으로 제한됩니다. 이 크기 제한을 테스트하려면 셸에서 ulimit 명령줄을 사용하세요.
////: tail				--- 02🔴tail 명령어와 동일한 기능을 수행하는 프로그램
//// 명령어 tail과 동일한 기능을 수행하는 ft_tail 프로그램을 작성하세요
//// 처리해야 하는 옵션은 -c뿐이며, '+' 또는 '-' 기호를 처리할 필요는 없습니다.
//// 제출 디렉터리에는 다음과 같은 규칙이 있는 Makefile이 있어야 합니다: all, clean, fclean
//// 변수 errno를 사용할 수 있습니다.
///: hexdump			--- 03🔴hexdump 명령어와 동일한 기능을 수행하는 프로그램
/// 명령어 hexdump와 동일한 기능을 수행하는 ft_hexdump 프로그램을 작성하세요
/// 처리해야할 유일한 옵션은 -C 입니다.
/// 제출 디렉터리에는 다음과 같은 규칙이 있는 Makefile이 있어야 합니다: all, clean, fclean
/// 변수 errno를 사용할 수 있습니다.

//!  C11
void ft_foreach(int *tab, int length, void (*f)(int)) // 🔴
{
	tab = NULL;
	length = 0;
	f = NULL;
	// • Create the function ft_foreach which, for a given ints array, applies a function on all elements of the array.
	// This function will be applied following the array’s order
	//  For example, the function ft_foreach could be called as follows in order to display all ints of the array :
	/// ft_foreach(tab, 1337, &ft_putnbr);
}
int *ft_map(int *tab, int length, int (*f)(int)) // 🔴
{
	//  • Create the function ft_map which, for a given ints array, applies a function on all elements of the array (in order) and returns a array of all the return values.
	// • This function will be applied following the array’s order. • Here’s how the function should be prototyped :
	tab = NULL;
	length = 0;
	f = NULL;
	return 0;
}
int ft_any(char **tab, int (*f)(char *)) // 🔴
{
	//  • Create a function ft_any which will return 1 if, passed to the function f, at least one element of the array returns something else than 0. Else, it should return 0.
	// • This function will be applied following the array’s order.
	// • Here’s how the function should be prototyped :
	// • The array will be delimited with a null pointer.
	tab = NULL;
	f = NULL;

	return 0;
}
int ft_count_if(char **tab, int length, int (*f)(char *)) // 🔴
{
	//  • Create a function ft_count_if which will return the number of elements of the array
	//  that return does not return 0 when passed to the function f.
	// • This function will be applied following the array’s order. • Here’s how the function should be prototyped :
	tab = NULL;
	length = 0;
	f = NULL;
	return 0;
}
int ft_is_sort(int *tab, int length, int (*f)(int, int)) // 🔴
{
	//  • Create a function ft_is_sort which returns 1 if the array is sorted and 0 if it isn’t.
	// • The function given as argument should return a negative integer if the first argument
	// is lower than the second, 0 if they’re equal or a positive integer for anything else.
	// • Here’s how the function should be prototyped :
	tab = NULL;
	length = 0;
	f = NULL;
	return 0;
}
////: do-op 🔴
//// • Create a program called do-op.
//// • The progam will be executed with three arguments: do-op value1 operateur
//// value2
//// • Example :
////> $>./do-op 42 "+" 21
////> 63
////> $>
//// • You should use an array of pointers to function to take care of the operator.
//// • In case of an invalid operator your program should print 0.
//// • If the number of arguments is invalid, do-op doesn’t display anything.
//// • Your program should accept and print the result for the following operators: ’+’ ’-’ ’/’ ’*’ and ’%’
//// • Your program should treat value as int.
//// • In case of a division by 0, it should print:
////>  Stop : division by zero
//// • In case of a modulo by 0, it should print:
////>  Stop : modulo by zero
//// Here’s an example of tests the Moulinette will run :
//// $> make clean
//// $> make
//// $> ./do-op
//// $> ./do-op 1 + 1
//// 2
//// $> ./do-op 42amis - --+-20toto12
//// 62
//// $> ./do-op 1 p 1
//// 0
//// $> ./do-op 1 + toto3
//// 1 $>
//// $> ./do-op toto3 + 4 4
//// $> ./do-op foo plus bar 0
//// $> ./do-op 25 / 0
//// Stop : division by zero
//// $> ./do-op 25 % 0 Stop : modulo by zero
//// $>
void ft_sort_string_tab(char **tab) // 🔴
{
	//  • Create the function ft_sort_string_tab, by ascii order the strings in tab. • tab will be null terminated
	// • The sorting will be performed by exchanging the array’s pointers.
	// • Here’s how it should be prototyped :
	tab = NULL;
}
void ft_advanced_sort_string_tab(char **tab, int (*cmp)(char *, char *)) // 🔴
{
	//  • Create the function ft_advanced_sort_string_tab which sorts, depending on the return of the function given as argument
	// • The sorting will be performed by exchanging the array’s pointers. • tab will be null terminated
	// • Here’s how it should be prototyped :
	// Calling ft_advanced_sort_string_tab() with ft_strcmp as a second argument will return the same result as ft_sort_string_tab().
	tab = NULL;
	cmp = NULL;
}

//!  RUSH00
void rush0X(int x, int y) // 1주차 러쉬, 더 나은 버전
{
	int i;
	int put;
	i = 0;

	while (i++ < x * y)
	{
		put = 4;
		put += ((i - 1) % x > 0) + ((i - 1) % x == x - 1);
		put += -3 * ((i - 1) / x == 0) + 3 * ((i - 1) / x == y - 1);
		put += -(x == 1) - 3 * (y == 1);
		write(1, &"07894 6123"[put], 1); // numpad
		//ㅡ write(1, &"0o-o| |o-o"[put], 1); // RUSH 00			oooo
		//ㅡ write(1, &"0/*\\* *\\*/"[put], 1); // RUSH 01		hamburger
		//ㅡ write(1, &"0ABAB BCBC"[put], 1); // RUSH 02		AACC
		//ㅡ write(1, &"0ABCB BABC"[put], 1); // RUSH 03		ACAC
		//ㅡ write(1, &"0ABCB BCBA"[put], 1); // RUSH 04		ACCA
		if (i % x == 0)
			write(1, "\n", 1);
	}
}