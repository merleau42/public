<style>.mjx-copytext {font-size: 0;}</style>
<style>.title-column { width: 45px; text-align: center;}</style>
<style>table { width: 100%; }</style>
<style>td { height: 40px; }</style>
<style>table, th, td { border-collapse: collapse; border: 1px solid black; }</style>
<style>pre {color:white; font-family:Courier New; padding:5px; line-height:1.36;}</style>
<table class="problem-table"><tr><td class="title-column">정보</td><td align="center">24447번,한국어</td></tr><tr><td class="title-column">문제</td><td><div class="problem-text" id="problem_description">
 <p>
  오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.
 </p>
 <p>
  <em>
   N
  </em>
  개의 정점과
  <em>
   M
  </em>
  개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터
  <em>
   N
  </em>
  번이고 모든 간선의 가중치는 1이다. 정점
  <em>
   R
  </em>
  에서 시작하여 너비 우선 탐색으로 만들어 지는 트리를 너비 우선 탐색 트리라고 하자. 너비 우선 탐색 트리에 있는
  <em>
   i
  </em>
  번 노드의 깊이(depth)를
  <em>
   d
   <sub>
    i
   </sub>
  </em>
  라고 하자. 시작 정점
  <em>
   R
  </em>
  의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1이다. 정점
  <em>
   R
  </em>
  에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우
  <em>
   i
  </em>
  번 노드의 방문 순서를
  <em>
   t
   <sub>
    i
   </sub>
  </em>
  라고 하자. 시작 정점의 방문 순서는 1이고 시작 정점에서 방문할 수 없는 노드는 0이다. 모든 노드에 대한
  <em>
   d
   <sub>
    i
   </sub>
  </em>
  ×
  <em>
   t
   <sub>
    i
   </sub>
  </em>
  값의 합을 구해보자.
 </p>
 <p>
  너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은
  <strong>
   오름차순
  </strong>
  으로 방문한다.
 </p>
 <pre>bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
    for each v ∈ V - {R}
        visited[v] &lt;- NO;
    visited[R] &lt;- YES;  # 시작 정점 R을 방문 했다고 표시한다.
    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.
    while (Q ≠ ∅) {
u &lt;- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.
        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를 <strong>오름차순</strong>으로 방문한다)
            if (visited[v] = NO) then {
        visited[v] &lt;- YES;  # 정점 v를 방문 했다고 표시한다.
                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.
            }
    }
}</pre>
</div>
</td></tr>
<tr><td class="title-column">입력</td><td><div class="problem-text" id="problem_input">
 <p>
  첫째 줄에 정점의 수
  <em>
   N
  </em>
  (5 ≤
  <em>
   N
  </em>
  ≤ 100,000), 간선의 수
  <em>
   M
  </em>
  (1 ≤
  <em>
   M
  </em>
  ≤ 200,000), 시작 정점
  <em>
   R
  </em>
  (1 ≤
  <em>
   R
  </em>
  ≤
  <em>
   N
  </em>
  )이 주어진다.
 </p>
 <p>
  다음
  <em>
   M
  </em>
  개 줄에 간선 정보
  <code>
   <em>
    u
   </em>
   <em>
    v
   </em>
  </code>
  가 주어지며 정점
  <em>
   u
  </em>
  와 정점
  <em>
   v
  </em>
  의 가중치 1인 양방향 간선을 나타낸다. (1 ≤
  <em>
   u
  </em>
  &lt;
  <em>
   v
  </em>
  ≤
  <em>
   N
  </em>
  ,
  <em>
   u
  </em>
  ≠
  <em>
   v
  </em>
  ) 모든 간선의 (
  <em>
   u
  </em>
  ,
  <em>
   v
  </em>
  ) 쌍의 값은 서로 다르다.
 </p>
</div>
</td></tr>
<tr><td class="title-column">출력</td><td><div class="problem-text" id="problem_output">
 <p>
  첫째 줄에 모든 노드에 대한
  <em>
   d
   <sub>
    i
   </sub>
  </em>
  ×
  <em>
   t
   <sub>
    i
   </sub>
  </em>
  값의 합을 출력한다.
 </p>
</div>
</td></tr>
<tr><td class="title-column">제한</td><td><div class="problem-text" id="problem_limit">
</div>
</td></tr>
<tr><td class="title-column">힌트</td><td><div class="problem-text" id="problem_hint">
</div>
</td></tr>
</table><br><br>

<table><tr><th>입력</th><th>출력</th><th>참고</th></tr><tr><td><pre>5 5 1
1 4
1 2
2 3
2 4
3 4</pre></td><td><pre>13</pre></td><td><div class="problem-text" id="problem_sample_explain_1">
 <p>
  정점 1번에서 정점 2번, 정점 4번을 순서대로 방문한다. 정점 2번에서 정점 3번을 방문한다. 정점 5번은 정점 1번에서 방문할 수 없다. 따라서,
  <em>
   t
   <sub>
    i
   </sub>
  </em>
  값은 1번 정점부터 1, 2, 4, 3, 0이다.
 </p>
 <p>
  너비 우선 탐색 트리는 1, 2, 3, 4번 노드로 구성된다. 1번 노드가 루트이다. 1번 노드의 자식은 2, 4번 노드이다. 3번 노드는 2번 또는 4번 노드의 자식이다. 5번 노드는 1번 노드에서 방문 될 수 없다. 따라서,
  <em>
   d
   <sub>
    i
   </sub>
  </em>
  값은 1번 정점부터 0, 1, 2, 1, -1이다.
 </p>
 <p>
  <em>
   t
   <sub>
    i
   </sub>
  </em>
  ×
  <em>
   d
   <sub>
    i
   </sub>
  </em>
  값의 합은 1×0 + 2×1 + 4×2 + 3×1 + 0×(-1) = 13이다.
 </p>
</div></td></tr></table>