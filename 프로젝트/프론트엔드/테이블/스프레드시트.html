<html>
<head>
	<style>
		body {
			margin: 0;
			font-family: Arial, Helvetica, sans-serif;
		}
		.slot {
			margin: auto;
			margin-top: 25;
			min-height: 10%;
			width: 99%;
			text-align: center;
		}
		table {
			max-height: 0;
			height: 100%;
			width: 100%;
			border: 1;
			border-collapse: collapse;
		}
		th, td {
			padding: 2px;
			font-size: 15;
		}
		.Cell {
			height: 100%;
			width: 100%;
			border: 0;
			text-align: center;
			background-color: inherit;
		}
		.P0 {background-color: rgb(192, 192, 192);}
		.P1 {background-color: rgb(255, 192, 0);}
		.P2 {background-color: rgb(255, 255, 0);}
		.P3 {background-color: rgb(255, 255, 170);}
		.P4 {background-color: rgb(0, 204, 0);}
		.P5 {background-color: rgb(0, 255, 0);}
		.P6 {background-color: rgb(187, 255, 187);}
		.P7 {background-color: rgb(255, 136, 255);}
		.P8 {background-color: rgb(136, 136, 255);}
		.P9 {background-color: rgb(192, 192, 255);}
		.index, .roof, .edge {
			background-color: rgb(210, 210, 210);
		}
		.dragging{
			background-color: rgb(160, 160, 160);
		}
		.dropable{
			border-top: 3px dotted;
			background-color: rgb(240, 240, 240);
		}
		.index {
			width: 5vw;
			text-align: center;
		}
		.index.mousedown {
			background-color: rgb(160, 160, 160);
		}

	</style>
	<script>
		let xhttp = new XMLHttpRequest();
		let files = {};
		let vecs = {};
		let tabs = {};
		let Q = (x, y=document) => y.querySelector(x);
		let QQ = (x, y=document) => y.querySelectorAll(x);
		function load_file(fd, path)
		{
			xhttp.open("GET", path, false);
			xhttp.send();
			if (xhttp.readyState == 4 && xhttp.status == 200)
				files[fd] = xhttp.response;
		}
		function swap_key_value(map)
		{
			return JSON.parse(`{${keys(map).map(x=>`"${map[x]}":"${x}"`).join(',')}}`);
		}
		function parse(category, keyword)
		{
			parsed = {};
			category = `\x00${category}\x7F`;
			keyword = `\x00${keyword}\x7F`;

			[...category]
			.map((x,i,a) => [keyword.indexOf(x), x])
			.toSorted((x,y) => x[0] - y[0])
			.forEach((x,i,a) =>{
				if (i < a.length - 1) parsed[a[i][1]] = keyword.substring(a[i][0] + 1, a[i+1][0])
			});

			return parsed;
		}
		function debug(msg)
		{
			if (!document.querySelector('debug'))
				document.querySelector('body').appendChild(document.createElement('debug'));
			document.querySelector('debug').innerText += `${msg}\n\n`;
		}
		function free_class(classNames)
		{
			let dummy = document.createElement('dummy');
			classNames.forEach(x => (document.querySelector(`.${x}`)??dummy).classList.remove(x))
		}
	</script>
	<script>
		let alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		window.addEventListener('DOMContentLoaded',	main)
		function main()
		{
			body = document.body;

			load_file(1, '저장.json');
			vecs[1] = map_to_vec( JSON.parse( files[1] ) );
			tabs[1] = vec_to_table( vecs[1], 1 );
			slot1.innerText = '';
			slot1.appendChild(tabs[1]);

			load_file(2, '저장.txt')
			vecs[2] = (files[2].split('\n').map(x=>x.split(',')));
			tabs[2] = vec_to_table( vecs[2], 2 );
			slot2.innerText = '';
			slot2.appendChild( tabs[2] );

			mouse_listner();
			// debug(vecs[1])
			// debug(vecs[2])
		}
		function mouse_listner()
		{
			document.addEventListener('contextmenu', e => {
				event.preventDefault();
			})
			document.addEventListener('mousedown', e => {
				e.target.classList.add('mousedown');
				Q('tr:has(.mousedown.index)').classList.add('dropable');
			})
			document.addEventListener('mouseup', e => {
				free_class(['dropable','mousedown'])
			})
			document.addEventListener('dragstart', e => e.target.classList.add('dragging'))
			document.addEventListener('dragend', e => {
				free_class(['enter','dropable','dragging','to_drop','mousedown'])
			})
			document.addEventListener('dragover', e => e.preventDefault()) // 'over' 있어야 'drop' 가능
			document.addEventListener('dragenter', e => {
				free_class(['enter', 'dropable']);
				e.target.classList.add('enter');
				if (Q('.dragging.index'))
					Q('tr:has(.enter)').classList.add('dropable');
			})
			document.addEventListener('drop', e => {
				e.target.classList.add('to_drop')
				if (Q('.dragging.index') && Q('tbody tr:has(.to_drop)'))
					swap_table_row(Q('.dragging').parentNode, Q('tbody tr:has(.to_drop)'));
			})
		}
		// 테이블 <==> 벡터 <==> 맵
		function vec_to_table(arr, fd=null)
		{
			table = document.createElement('table');
			thead = document.createElement('thead');
			tbody = document.createElement('tbody');
			arr.forEach((row, i) => {
				tr = document.createElement('tr');
				row.forEach((col, j) => {
					parsed = parse('ㅷ', col);
					td = i > 0 ? document.createElement('td') : document.createElement('th');
					if (i > 0 && j > 0){
						input = document.createElement('input');
						input.classList.add( "Cell" );
						input.value = parsed['\x00'];
						td.appendChild(input);
						if (parsed['ㅷ']) td.classList.add (parsed['ㅷ']);
					}
					else if (i != 0 && j == 0){
						td.classList.add ("index");
						td.innerText = i
					}
					else if (i == 0 && j != 0){
						td.classList.add ("roof");
						td.innerText=`${alpha[Math.floor((j-27)/26)]??""}${alpha[(j-1)%26]}`;
					}
					else if (i == 0 && j == 0)
						td.classList.add ("edge");
					// td.setAttribute('row', i);
					// td.setAttribute('col', j);
					td.setAttribute("draggable", true)
					tr.appendChild(td);
					tr.setAttribute('row', i);
				})
				i > 0 ? tbody.appendChild(tr) : thead.appendChild(tr)
			})
			table.appendChild(thead);
			table.appendChild(tbody);
			table.border = 1;
			if (fd) table.id = `table${fd}`;
			return table;
		}
		function table_to_vec(table)
		{
			return [...table.querySelectorAll('tr')].map((tr,i) => {
				return [...tr.querySelectorAll('th, td')].map((td,j) => {
					if (i==0 || j==0)
						return '';
					text = td.querySelector('.Cell').value;
					bg = [...td.classList].filter(x=>x[0]=='P')[0];
					bg = bg ? `ㅷ${bg}` : ''
					return text + bg;
				})
			})
		}
		// map['행,열'] = '셀정보' <===> vec[행][열] = '셀정보'
		function vec_to_map(arr, map={})
		{
			arr.forEach((row,i) => {
				row.forEach((col,j) => {
					if (col)
						map[`${i},${j}`] = col;
				})
			});
			return map;
		}
		function map_to_vec(map)
		{
			points = Object.keys(map).map(x=>x.split(',').map(e=>e*1))
			max_row = points.toSorted((a,b)=>b[0] - a[0])[0][0] + 1;
			max_col = points.toSorted((a,b)=>b[1] - a[1])[0][1] + 1;
			arr = Array.from({length:max_row}, x => Array.from({length:max_col}))
			arr.forEach((row,i)=>{
				row.forEach((col,j)=>{
					arr[i][j] = map[`${i},${j}`]??'';
				})
			});
			return arr;
		}
		function table_to_map(table, map={})
		{
			return vec_to_map(table_to_vec(table), map);
		}
		function map_to_table(map, fd=null)
		{
			return vec_to_table(map_to_vec(map), fd);
		}
		function swap_table_row(tr1, tr2)
		{
			if (tr1.rowIndex > tr2.rowIndex)
				tr2.before(tr1);
			else if (tr1.rowIndex < tr2.rowIndex)
				tr2.after(tr1);
			[...document.querySelectorAll('tbody tr')].forEach(tr => {
				tr.setAttribute('row', tr.rowIndex);
				tr.querySelector('.index').innerText = tr.rowIndex;
			})
		}
		// exam.map(x=>x.toSpliced(2,0,'added')) // 열 추가
		// exam.toSpliced(2,0,['added']) // 행 추가
	</script>
</head>
<body>
<div class="slot" id="slot1">1</div>
<div class="slot" id="slot2">2</div>
<div class="slot" id="slot3">3</div>
</body>
</html>