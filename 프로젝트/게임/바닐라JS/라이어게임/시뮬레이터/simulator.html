<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>ë¼ì´ì–´ê²Œì„ ì‹œë®¬ë ˆì´í„°</title>
	<link rel="stylesheet" href="simulator.css" />
	<script type="module">
		import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
		import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";

		const firebaseConfig = {
			apiKey: "AIzaSyDVVAx9XRziu8IZ9CLczaG20QEOwyY4uLs",
			authDomain: "liarwords-af033.firebaseapp.com",
			databaseURL: "https://liarwords-af033-default-rtdb.firebaseio.com",
			projectId: "liarwords-af033",
			storageBucket: "liarwords-af033.appspot.com",
			messagingSenderId: "171671976030",
			appId: "1:171671976030:web:59371970ec6b2a70035ccf"
		};

		const app = initializeApp(firebaseConfig);
		const db = getDatabase(app);

		async function getFirebaseData(path) {
			try {
				const snapshot = await get(ref(db, path));
				if (snapshot.exists()) {
					return snapshot.val();
				} else {
					console.log("No data available at path:", path);
					return null;
				}
			} catch (error) {
				console.error("Error loading data from Firebase:", error);
				return null;
			}
		}

		window.getFirebaseData = getFirebaseData;
	</script>
</head>
<body>
	<div class="top-bar">
		<span id="gameTypeDisplay" class="setting-value-display menu"></span>
		<span id="gameModeDisplay" class="setting-value-display menu"></span>
		<span id="playerCountDisplay" class="setting-value-display menu"></span>
		<span id="liarCountDisplay" class="setting-value-display menu"></span>
		<span id="missionInfoDisplay" class="setting-value-display menu">ë‚˜ì˜ ë‹¨ì–´</span>
	</div>
	
	<div class="grid-container" id="grid"></div>
	
	<div class="bottom-bar">
		<span id="refreshBtn" class="setting-value-display menu">ìƒˆë¡œê³ ì¹¨</span>
		<span id="startGameBtn" class="setting-value-display menu">ê²Œì„ ì‹œì‘</span>
		<span id="nextRoundBtn" class="menu">ë‹¤ìŒ ë¼ìš´ë“œ</span>
		<span class="menu">íˆ¬í‘œ ì‹œì‘</span>	
		<span class="menu">ë°œì–¸ ì‹œì‘</span>
	</div>

	<script>
		const Q = sel => document.querySelector(sel);
		const QQ = sel => Array.from(document.querySelectorAll(sel));
		const Elem = (tag, cls) => {
			const el = document.createElement(tag);
			if (cls) el.className = cls;
			return el;
		};
		const vector = (n, fn) => Array.from({ length: n }, (_, i) => fn(i));
		const randz = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

		const container = Q('#grid');

		const ë™ë¬¼ = ['ì›ìˆ­ì´','ì—¬ìš°','ë¶€ì—‰ì´','ê³°','í† ë¼','ë¼ì§€','ê°•ì•„ì§€','ê³ ì–‘ì´','í–„ìŠ¤í„°','í­ê·„','ì‚¬ì','í˜¸ë‘ì´','íŒë‹¤','ë„ˆêµ¬ë¦¬','ë‹¤ëŒì¥','ì–¼ë£©ë§','ê³ ìŠ´ë„ì¹˜','ì½”ë¼ë¦¬','ì•…ì–´','ìº¥ê±°ë£¨'];
		const íŒ»ë§ = ['ë…¸ë§', 'ì†Œì‹ ì¢Œ', 'ë¼ê²°ì', 'ì–‘ë°œ', 'êº¾ê¸°', 'í˜¼ë€ì¢Œ', 'í¬ê´„', 'ë‹µì½ê¸°', 'ë¹ŒëŸ°', '???'];
		const ì´ëª¨ì§€ì„ íƒì§€ = ['ğŸš«','â­•','âŒ','ğŸ˜ˆ','ğŸ”´','ğŸŸ ','ğŸ¤”','ğŸŸ¡','ğŸŸ£','ğŸ˜‡','ğŸŸ¢','ğŸ”µ'];
		const ì´ëª¨ì§€ê°ë„ = [26, 58, 91];
		const ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ = 45;
		
		const gameTypes = ['ë¼ì´ì–´ê²Œì„', 'ì–´ëª½ì–´ìŠ¤', 'ë§ˆí”¼ì•„', 'ê¸°ì‚¬ì™€ ê±´ë‹¬'];
		let currentGameType = gameTypes[0];
		const gameModes = ['ëœë¤ ëª¨ë“œ', 'ì—í”¼ì†Œë“œ'];
		let currentGameMode = gameModes[0];
		let playerCountState = 8;
		let liarCountState = 1;
		const minPlayerCount = 4, maxPlayerCount = 12;
		const maxLiarCount = 2; // ë¼ì´ì–´ ìµœëŒ€ ì¸ì›ìˆ˜
		let ë™ë¬¼ì¸ë±ìŠ¤ = []; // ì¤‘ë³µ ë°©ì§€ìš©
		let currentRound = 0; // í˜„ì¬ ë¼ìš´ë“œ (0: ê²Œì„ ì‹œì‘ ì „, 1: opening, 2: elaborate1, 3: elaborate2)

		function shuffleArray(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
			return array;
		}

		async function gameStart() {
			currentRound = 0; // ê²Œì„ ì‹œì‘ ì‹œ ë¼ìš´ë“œ ì´ˆê¸°í™”

			// 1. ë¼ì´ì–´ ë¶€ì—¬
			const liarIndices = randzSet(playerCountState, liarCountState);

			// 2. íŒŒì´ì–´ë² ì´ìŠ¤ DBì—ì„œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
			const dbData = await window.getFirebaseData('liar_groups/0096');
			if (!dbData) {
				alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
				return;
			}
			const allStatements = dbData.statements;

			// 3. ê³ ìœ í•œ unique ID ëª©ë¡ ìƒì„± ë° í• ë‹¹
			let distinctUniqueIds = [...new Set(allStatements.map(s => s.unique))];
			if (distinctUniqueIds.length < playerCountState) {
				alert('í”Œë ˆì´ì–´ì—ê²Œ í• ë‹¹í•  ê³ ìœ í•œ ë°œì–¸ IDê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.');
				return;
			}
			distinctUniqueIds = shuffleArray(distinctUniqueIds);
			const assignedUniqueIds = distinctUniqueIds.slice(0, playerCountState);

			// 4. ì£¼ì œì–´ 2ê°œ ëœë¤ ì„ íƒ
			const wordIndices = randzSet(dbData.words.length, 2);
			const citizenWord = dbData.words[wordIndices[0]];
			const liarWord = dbData.words[wordIndices[1]];
			
			// 5. ë°œì–¸ì„ ì‰½ê²Œ ì°¾ê¸° ìœ„í•œ ë§µ ìƒì„±
			const statementMap = new Map();
			allStatements.forEach(stmt => {
				if (!statementMap.has(stmt.unique)) {
					statementMap.set(stmt.unique, {});
				}
				statementMap.get(stmt.unique)[stmt.subject] = stmt;
			});

			// 6. ê° í”Œë ˆì´ì–´ì—ê²Œ ë°œì–¸ í• ë‹¹
			const players = QQ('.statement-container');
			players.forEach((player, i) => {
				const bubble = player.querySelector('.bubble');
				const uniqueId = assignedUniqueIds[i];
				let assignedStatement;
				let role, word;

				if (liarIndices.includes(i)) {
					role = 'liar';
					player.classList.add('liar'); // ë¼ì´ì–´ì—ê²Œ 'liar' í´ë˜ìŠ¤ ì¶”ê°€
					word = liarWord;
				} else {
					role = 'citizen';
					player.classList.remove('liar'); // ë¼ì´ì–´ í´ë˜ìŠ¤ ì œê±° (í˜¹ì‹œ ëª¨ë¥¼ ì´ˆê¸°í™”)
					word = citizenWord;
				}

				const possibleStatements = statementMap.get(uniqueId);
				if (possibleStatements && possibleStatements[word]) {
					assignedStatement = possibleStatements[word];
				} else {
					// í•´ë‹¹ uniqueIdì™€ subjectì— ë§ëŠ” ë°œì–¸ì´ ì—†ëŠ” ê²½ìš°, ë‹¤ë¥¸ ë°œì–¸ìœ¼ë¡œ ëŒ€ì²´ (ì˜¤ë¥˜ ë°©ì§€)
					const fallbackStatements = allStatements.filter(s => s.subject === word && !assignedUniqueIds.includes(s.unique));
					assignedStatement = fallbackStatements[randz(0, fallbackStatements.length - 1)] || { opening: "ë°œì–¸ ì—†ìŒ", elaborate1: "ë°œì–¸ ì—†ìŒ", elaborate2: "ë°œì–¸ ì—†ìŒ", unique: "N/A" };
					console.warn(`ëŒ€ì²´ ë°œì–¸ í• ë‹¹: player ${i}, uniqueId ${uniqueId}, word ${word}`);
				}
				
				player.dataset.role = role;
				player.dataset.word = word;
				player.dataset.statements = JSON.stringify([assignedStatement.opening, assignedStatement.elaborate1, assignedStatement.elaborate2].filter(Boolean));
				player.dataset.unique = assignedStatement.unique;

				bubble.textContent = JSON.parse(player.dataset.statements)[0]; // 1ë¼ìš´ë“œ(opening) ë°œì–¸
			});
			currentRound = 1; // ê²Œì„ ì‹œì‘ê³¼ í•¨ê»˜ 1ë¼ìš´ë“œë¡œ ì„¤ì •
		}
		
		function nextRound() {
			currentRound++;
			const players = QQ('.statement-container');
			players.forEach(player => {
				const bubble = player.querySelector('.bubble');
				const statements = JSON.parse(player.dataset.statements);
				if (currentRound -1 < statements.length) {
					bubble.textContent = statements[currentRound -1];
				} else {
					bubble.textContent = "ë” ì´ìƒ ë°œì–¸ì´ ì—†ìŠµë‹ˆë‹¤.";
				}
			});
		}

		function setupEmojiInterface(profileEl) {
			const ìƒíƒœ = { ì´ëª¨ì§€ë“¤: [] };
			const ê°±ì‹  = () => {
				profileEl.querySelectorAll('.emoji-button').forEach(el => el.remove());
				ìƒíƒœ.ì´ëª¨ì§€ë“¤.forEach((emj, i) => {
					const rad = Math.PI * ì´ëª¨ì§€ê°ë„[i] / 180;
					const btn = Elem('div', 'emoji-button');
					btn.textContent = emj;
					btn.style.left = `${50 + ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.sin(rad)}%`;
					btn.style.top = `${50 - ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.cos(rad)}%`;
					btn.addEventListener('click', e => ì—´ê¸°(i, e));
					profileEl.appendChild(btn);
				});
				if (ìƒíƒœ.ì´ëª¨ì§€ë“¤.length < ì´ëª¨ì§€ê°ë„.length) {
					const i = ìƒíƒœ.ì´ëª¨ì§€ë“¤.length;
					const rad = Math.PI * ì´ëª¨ì§€ê°ë„[i] / 180;
					const plus = Elem('div', 'emoji-button');
					plus.textContent = 'â•';
					plus.style.left = `${50 + ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.sin(rad)}%`;
					plus.style.top = `${50 - ì´ëª¨ì§€ë°˜ì§€ë¦„ë¹„ìœ¨ * Math.cos(rad)}%`;
					plus.addEventListener('click', e => ì—´ê¸°(i, e));
					profileEl.appendChild(plus);
				}
			};
			const ì—´ê¸° = (idx, ev) => {
				ev.stopPropagation();
				QQ('.emoji-picker').forEach(p => p.remove());
				const picker = Elem('div', 'emoji-picker');
				ì´ëª¨ì§€ì„ íƒì§€.forEach(emj => {
					const span = Elem('span');
					span.textContent = emj;
					span.addEventListener('click', e => {
						e.stopPropagation();
						if (emj === 'ğŸš«') ìƒíƒœ.ì´ëª¨ì§€ë“¤.splice(idx, 1);
						else ìƒíƒœ.ì´ëª¨ì§€ë“¤[idx] = emj;
						ê°±ì‹ ();
						picker.remove();
					});
					picker.appendChild(span);
				});
				picker.style.left = ev.clientX + 'px';
				picker.style.top = ev.clientY + 'px';
				document.body.appendChild(picker);
			};
			ê°±ì‹ ();
			profileEl._emojiUpdater = ê°±ì‹ ;
		}

		function createCard(index, animalIndex) {
			const wrapper = Elem('div', 'statement-container');
			const profile = Elem('div', 'profile');
			const circle = Elem('div', 'circle');
			const img = Elem('img');
			img.src = `../ë¦¬ì†ŒìŠ¤/ë™ë¬¼${animalIndex}.png`;
			circle.appendChild(img);
			profile.appendChild(circle);

			setupEmojiInterface(profile);

			const demo = íŒ»ë§[randz(0, íŒ»ë§.length - 1)];
			const placard = Elem('div', 'placard');
			placard.textContent = demo;
			placard.dataset.selected = demo;
			profile.appendChild(placard);

			const bubble = Elem('div', 'bubble');
			bubble.textContent = ë™ë¬¼[animalIndex];

			wrapper.appendChild(profile);
			wrapper.appendChild(bubble);
			container.appendChild(wrapper);

			placard.addEventListener('click', e => {
				e.stopPropagation();
				QQ('.placard.expanded').forEach(p => {
					p.classList.remove('expanded');
					p.removeAttribute('style');
					p.textContent = p.dataset.selected;
				});
				const rect = placard.getBoundingClientRect();
				const centerX = rect.left + rect.width / 2;
				const centerY = rect.top + rect.height / 2;
				placard.classList.add('expanded');
				placard.style.left = `${centerX - 125}px`;
				placard.style.top = `${centerY - 30}px`;
				placard.innerHTML = '';
				for (let row = 0; row < 2; row++) {
					const rowDiv = Elem('div', 'choice-row');
					íŒ»ë§.slice(row * 5, (row + 1) * 5).forEach(text => {
						const span = Elem('span', 'choice');
						span.innerHTML = (text === placard.dataset.selected) ? `<strong>${text}</strong>` : text;
						span.addEventListener('click', e => {
							e.stopPropagation();
							placard.textContent = text;
							placard.dataset.selected = text;
							placard.classList.remove('expanded');
							placard.removeAttribute('style');
							adjustPlacardPosition(); // íŒ»ë§ ìœ„ì¹˜ ì¬ì¡°ì •
						});
						rowDiv.appendChild(span);
					});
					placard.appendChild(rowDiv);
				}
				QQ('.placard.expanded, .emoji-picker').forEach(expanded => {
				const offset = expanded.getBoundingClientRect();
				const shiftX = Math.min(0, offset.left - 10);
				const shiftY = Math.min(0, offset.top - 10);
				const overX = offset.right - window.innerWidth + 10;
				const overY = offset.bottom - window.innerHeight + 10;
				if (shiftX < 0 || overX > 0)
					expanded.style.left = `calc(${expanded.style.left} - ${shiftX || overX}px)`;
				if (shiftY < 0 || overY > 0)
					expanded.style.top = `calc(${expanded.style.top} - ${shiftY || overY}px)`;
				})
				adjustPlacardPosition();
			});
		}

		function fillGrid() {
			container.innerHTML = '';
			ë™ë¬¼ì¸ë±ìŠ¤ = randzSet(ë™ë¬¼.length, playerCountState);
			for (let i = 0; i < playerCountState; i++) {
				createCard(i, ë™ë¬¼ì¸ë±ìŠ¤[i]);
			}
			updateLayoutBasedOnColumn();
			adjustPlacardPosition(); // íŒ»ë§ ìœ„ì¹˜ ì¡°ì • í•¨ìˆ˜ í˜¸ì¶œ
		}

		function randzSet(max, count) {
			const pool = Array.from({ length: max }, (_, i) => i);
			const result = [];
			while (result.length < count) {
				const idx = randz(0, pool.length - 1);
				result.push(pool.splice(idx, 1)[0]);
			}
			return result;
		}

		function closeAllCustomDropdowns() {
			QQ('.custom-dropdown-options').forEach(dropdown => dropdown.remove());
		}

		function openCustomDropdown(displayElement, type) {
			closeAllCustomDropdowns();

			const optionsDiv = Elem('div', 'custom-dropdown-options');
			let options;

			if (type === 'player') {
				const min = minPlayerCount;
				const max = maxPlayerCount;
				options = Array.from({ length: max - min + 1 }, (_, i) => min + i);
			} else if (type === 'liar') {
				const min = 1;
				const max = Math.min(Math.floor((playerCountState - 1) / 2), maxLiarCount);
				options = Array.from({ length: max - min + 1 }, (_, i) => min + i);
			} else if (type === 'gameType') {
				options = gameTypes;
			} else if (type === 'gameMode') {
				options = gameModes;
			}

			if (type === 'gameType' || type === 'gameMode') {
				optionsDiv.classList.add('full-width-options');
			}

			options.forEach(option => {
				const optionSpan = Elem('span', 'custom-dropdown-option');
				optionSpan.textContent = option;
				optionSpan.dataset.value = option;
				optionSpan.addEventListener('click', (e) => {
					e.stopPropagation();
					const newValue = e.target.dataset.value;

					if (type === 'player') {
						playerCountState = parseInt(newValue, 10);
						populatePlayerDisplay();
						populateLiarDisplay();
						fillGrid();
					} else if (type === 'liar') {
						liarCountState = parseInt(newValue, 10);
						populateLiarDisplay();
					} else if (type === 'gameType') {
						currentGameType = newValue;
						populateGameTypeDisplay();
					} else if (type === 'gameMode') {
						currentGameMode = newValue;
						populateGameModeDisplay();
					}
					closeAllCustomDropdowns();
				});
				optionsDiv.appendChild(optionSpan);
			});

			const rect = displayElement.getBoundingClientRect();
			optionsDiv.style.top = `${rect.bottom}px`;
			optionsDiv.style.left = `${rect.left}px`;
			optionsDiv.style.width = `${rect.width}px`;
			document.body.appendChild(optionsDiv);
		}

		function populateGameTypeDisplay() {
			Q('#gameTypeDisplay').textContent = `${currentGameType}`;
		}
		
		function populateGameModeDisplay() {
			Q('#gameModeDisplay').textContent = `${currentGameMode}`;
		}

		function populatePlayerDisplay() {
			Q('#playerCountDisplay').textContent = `ì¸ì›ìˆ˜: ${playerCountState}`;
		}

		function populateLiarDisplay() {
			const maxLiars = Math.min(Math.floor((playerCountState - 1) / 2), maxLiarCount);
			if (liarCountState < 1 || liarCountState > maxLiars) {
				liarCountState = 1;
			}	
			Q('#liarCountDisplay').textContent = `ë¼ì´ì–´: ${liarCountState}`;
		}

		Q('#refreshBtn').addEventListener('click', fillGrid);	
		Q('#startGameBtn').addEventListener('click', gameStart);
		Q('#nextRoundBtn').addEventListener('click', nextRound); // ë‹¤ìŒ ë¼ìš´ë“œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
		Q('#gameTypeDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'gameType'));
		Q('#gameModeDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'gameMode'));
		Q('#playerCountDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'player'));
		Q('#liarCountDisplay').addEventListener('click', (e) => openCustomDropdown(e.target, 'liar'));

		document.addEventListener('click', (e) => {
			if (!e.target.closest('.custom-dropdown-options') && !e.target.closest('.setting-value-display')) {
				closeAllCustomDropdowns();
			}
			// íŒ»ë§ í™•ì¥ ë‹«ê¸°
			const expandedPlacard = Q('.placard.expanded');
			if (expandedPlacard && !e.target.closest('.placard.expanded')) {
				expandedPlacard.classList.remove('expanded');
				expandedPlacard.removeAttribute('style');
				expandedPlacard.textContent = expandedPlacard.dataset.selected;
				adjustPlacardPosition();
			}
		});

		function getColumnCount() {
			const items = QQ('.statement-container');
			if (items.length === 0) return 0;
			const left = items.map(x => x.offsetLeft);
			let cols = 0;
			while (cols < left.length && left.indexOf(left[cols]) === cols) {
				cols++;
			}
			return cols;
		}

		function updateLayoutBasedOnColumn() {
			QQ('.reverse').forEach(x => x.classList.remove('reverse'));
			const count = getColumnCount();
			if (count === 0) return;
			QQ('.statement-container').forEach((el, i) => {
				if (count === 2 && i % 2 === 1) { // ì§ìˆ˜ ì—´ì¼ ë•Œ ì§ìˆ˜ ë²ˆì§¸ ìì‹ë“¤ reverse
					el.classList.add('reverse');
				}
			});
		}
		
		function adjustPlacardPosition() {
			const columnCount = getColumnCount();
			const statements = QQ('.statement-container');

			statements.forEach((statement, index) => {
				const placard = statement.querySelector('.placard');
				if (!placard || placard.classList.contains('expanded')) return;

				// 2ì—´ ë ˆì´ì•„ì›ƒì´ê³  í™€ìˆ˜ë²ˆì§¸(index 0, 2, ...) ìš”ì†Œì¸ ê²½ìš°
				if (columnCount === 2 && index % 2 === 1) {
					placard.classList.add('placard-shifted-left');
				} else {
					// ê·¸ ì™¸ì˜ ê²½ìš°ëŠ” í´ë˜ìŠ¤ë¥¼ ì œê±°í•˜ì—¬ ê¸°ë³¸ ìœ„ì¹˜ë¡œ ë˜ëŒë¦½ë‹ˆë‹¤.
					placard.classList.remove('placard-shifted-left');
				}
			});
		}

		window.addEventListener('resize', () => {
			QQ('.profile').forEach(p => p._emojiUpdater && p._emojiUpdater());
			updateLayoutBasedOnColumn();
			adjustPlacardPosition(); // íŒ»ë§ ìœ„ì¹˜ ì¡°ì • í•¨ìˆ˜ í˜¸ì¶œ
		});
		
		populateGameTypeDisplay();
		populateGameModeDisplay();
		populatePlayerDisplay();
		populateLiarDisplay();
		fillGrid();
	</script>
</body>
</html>