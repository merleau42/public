<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ë‹¨ì–´ìˆ˜ì§‘ê¸°</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- ì…ë ¥ì°½ -->
<div id="div1" class="flex-container"></div>

<!-- ë‹¨ì¼ ì…ë ¥ + ë²„íŠ¼ -->
<div id="div2" class="flex-container">
  <textarea id="singleInput" maxlength="50" tabindex="9"></textarea>
  <button onclick="addSingle()">ì¶”ê°€</button>
  <button onclick="clearInputs()">ë¹„ìš°ê¸°</button>
  <button onclick="loadFromDB()">ë¦¬ìŠ¤íŠ¸</button>
</div>

<!-- ì¶œë ¥ -->
<div id="div3"><div id="output"></div></div>

<!-- ì´ëª¨ì§€ ì„ íƒ ëª¨ë‹¬ -->
<div class="modal-backdrop" id="modal-backdrop"></div>
<div class="modal" id="emoji-modal">
  <div style="text-align: center; font-weight: bold;">ë°›ì€ íˆ¬í‘œ</div>
  <div id="emoji-buttons"></div>
  <hr>
  
  <!-- í˜ì´ì¦ˆ ë²„íŠ¼ ì˜ì—­ -->
  <div id="phase-buttons" class="phase-buttons-container"></div>
  <div class="modal-footer">
    <button id="clear-current-button">ë¹„ìš°ê¸°</button>
    <button id="reset-all-button">ì´ˆê¸°í™”</button>
    <button id="confirm-button">í™•ì¸</button>
    <button id="cancel-button">ì·¨ì†Œ</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
import { getDatabase, ref, get, set, update } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";

// Firebase ì´ˆê¸°í™”
const app = initializeApp({
  apiKey: "AIzaSyDVVAx9XRziu8IZ9CLczaG20QEOwyY4uLs",
  authDomain: "liarwords-af033.firebaseapp.com",
  databaseURL: "https://liarwords-af033-default-rtdb.firebaseio.com",
  projectId: "liarwords-af033",
  storageBucket: "liarwords-af033.appspot.com",
  messagingSenderId: "171671976030",
  appId: "1:171671976030:web:59371970ec6b2a70035ccf"
});
const db = getDatabase(app);

// --- ìƒíƒœ ë³€ìˆ˜ (State Variables) ---
let groupList = [];
let visibleCount = 7;
let currentEmojiTarget = null;
let tempEmojiSelection = [];
const emojiList = ['1','2','3','4','5','6','7','8'];

// í˜ì´ì¦ˆ ì‹œìŠ¤í…œ ìƒíƒœ ë³€ìˆ˜
let phaseEmojiMaps = {
  phase1: {},
  phase2: {},
  phase3: {},
  phase4: {}
};
let currentActivePhase = 'phase1';
const phaseConfig = {
    'phase1': { name: 'í˜ì´ì¦ˆ1', colorClass: 'phase-1', emojiColorClass: 'phase-1-color' },
    'phase2': { name: 'í˜ì´ì¦ˆ2', colorClass: 'phase-2', emojiColorClass: 'phase-2-color' },
    'phase3': { name: 'í˜ì´ì¦ˆ3', colorClass: 'phase-3', emojiColorClass: 'phase-3-color' },
    'phase4': { name: 'í˜ì´ì¦ˆ4', colorClass: 'phase-4', emojiColorClass: 'phase-4-color' }
};


// --- ì´ˆê¸°í™” (Initialization) ---
document.addEventListener('DOMContentLoaded', () => {
  localStorage.setItem('ìŠ¹ì¸', 'false');
  generateInputs();
  restoreState(); // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ëª¨ë“  ìƒíƒœ ë³µì›
  attachInputListeners();
  // attachFocusListenersëŠ” generateInputsì—ì„œ í˜¸ì¶œë˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì œê±°
  setupEmojiButtons();
  setupPhaseButtons();

  // ëª¨ë‹¬ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  document.getElementById('clear-current-button').addEventListener('click', handleClearCurrentVote);
  document.getElementById('reset-all-button').addEventListener('click', handleResetAllVotes);
  document.getElementById('confirm-button').addEventListener('click', confirmEmojiSelection);
  document.getElementById('cancel-button').addEventListener('click', cancelEmojiSelection);
  document.getElementById('modal-backdrop').addEventListener('click', cancelEmojiSelection);
});

// --- ì…ë ¥ì°½ ë° ë²„íŠ¼ ìƒì„± (Input & Button Generation) ---
function generateInputs() {
  const div1 = document.getElementById('div1');
  div1.innerHTML = ''; // ê¸°ì¡´ ì…ë ¥ì°½ ì œê±°

  // 1~8ë²ˆ ì…ë ¥ì°½ ìƒì„±
  for (let i = 1; i <= 8; i++) {
    const wrapper = document.createElement('div');
    wrapper.className = 'textarea-wrapper';
    wrapper.id = `wrapper-input${i}`;

    const textarea = document.createElement('textarea');
    textarea.id = `input${i}`;
    textarea.tabIndex = i;

    const emojiOverlay = document.createElement('div');
    emojiOverlay.className = 'emoji-overlay';
    emojiOverlay.id = `emoji-overlay-input${i}`;

    const emojiButton = document.createElement('button');
    emojiButton.className = 'emoji-button';
    emojiButton.innerText = 'ğŸ¹';
    emojiButton.onclick = () => openEmojiModal(`input${i}`);

    wrapper.appendChild(textarea);
    wrapper.appendChild(emojiOverlay);
    wrapper.appendChild(emojiButton);

    div1.appendChild(wrapper);
  }

  // Add/Remove ë²„íŠ¼ ì»¨í…Œì´ë„ˆ ìƒì„±
  const iconContainer = document.createElement('div');
  iconContainer.id = 'icon-container';
  // CSSì—ì„œ ì´ ìŠ¤íƒ€ì¼ì„ ê´€ë¦¬í•˜ë„ë¡ ë³€ê²½
  // iconContainer.style.display = 'inline-flex';
  // iconContainer.style.flexDirection = 'column';
  // iconContainer.style.justifyContent = 'center';
  // iconContainer.style.marginLeft = '5px';
  
  const addBtn = document.createElement('span');
  addBtn.id = 'addBtn';
  addBtn.className = 'icon-btn';
  addBtn.innerText = 'â•';
  addBtn.onclick = addInput;

  const removeBtn = document.createElement('span');
  removeBtn.id = 'removeBtn';
  removeBtn.className = 'icon-btn';
  removeBtn.innerText = 'â–';
  removeBtn.onclick = removeInput;

  iconContainer.appendChild(addBtn);
  iconContainer.appendChild(removeBtn);
  div1.appendChild(iconContainer);
  
  updateInputVisibility(); // ì´ˆê¸° ê°€ì‹œì„± ì„¤ì •
  attachFocusListeners(); // ì…ë ¥ì°½ ìƒì„± í›„ í¬ì»¤ìŠ¤ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
}

// â•â– ë²„íŠ¼ ë¡œì§ (Add/Remove Button Logic)
function addInput() {
    if (visibleCount < 8) {
        visibleCount++;
        saveState(); 
        updateInputVisibility();
        attachFocusListeners(); 
    }
}

function removeInput() {
    if (visibleCount > 3) {
        // ì‚¬ë¼ì§€ëŠ” inputì˜ íˆ¬í‘œ ë‚´ì—­ì„ ëª¨ë“  í˜ì´ì¦ˆì—ì„œ ì´ˆê¸°í™”
        const inputToRemoveId = `input${visibleCount}`;
        Object.keys(phaseEmojiMaps).forEach(phaseId => {
            if (phaseEmojiMaps[phaseId][inputToRemoveId]) {
                delete phaseEmojiMaps[phaseId][inputToRemoveId];
            }
        });

        visibleCount--;
        saveState(); 
        updateInputVisibility();
        updateDiv1Visuals(); // ë¹„ì£¼ì–¼ ì—…ë°ì´íŠ¸ (ì‚¬ë¼ì§„ inputì˜ íˆ¬í‘œ í‘œì‹œë„ ì§€ì›Œì§€ë„ë¡)
        attachFocusListeners(); 
    }
}

function updateInputVisibility() {
    for (let i = 1; i <= 8; i++) {
        const wrapper = document.getElementById(`wrapper-input${i}`);
        if (wrapper) {
            wrapper.style.display = i <= visibleCount ? 'inline-block' : 'none';
        }
    }
    // + - ë²„íŠ¼ì˜ ê°€ì‹œì„± ì¡°ì ˆ
    document.getElementById('addBtn').style.display = visibleCount === 8 ? 'none' : 'inline-block';
    document.getElementById('removeBtn').style.display = visibleCount === 3 ? 'none' : 'inline-block';
}


// --- ì´ëª¨ì§€ ë° í˜ì´ì¦ˆ ëª¨ë‹¬ (Emoji & Phase Modal) ---

function setupEmojiButtons() {
  const container = document.getElementById('emoji-buttons');
  container.innerHTML = '';
  emojiList.forEach(emoji => {
    const btn = document.createElement('button');
    btn.innerText = emoji;
    btn.onclick = () => toggleTempEmoji(emoji);
    container.appendChild(btn);
  });
}

function setupPhaseButtons() {
    const container = document.getElementById('phase-buttons');
    container.innerHTML = '';
    Object.keys(phaseConfig).forEach(phaseId => {
        const config = phaseConfig[phaseId];
        const btn = document.createElement('div'); // divë¡œ ìƒì„±í•˜ì—¬ CSS ê·œê²©ì— ë§ì¶¤
        btn.className = `phase-button ${config.colorClass}`;
        btn.dataset.phaseId = phaseId;
        btn.innerText = config.name;
        btn.onclick = () => switchPhase(phaseId);
        container.appendChild(btn);
    });
    updatePhaseButtonStates(); // ì´ˆê¸° í™œì„±í™” í˜ì´ì¦ˆ í‘œì‹œ
}

function openEmojiModal(targetId) {
  currentEmojiTarget = targetId;
  const currentPhaseVotes = phaseEmojiMaps[currentActivePhase];
  tempEmojiSelection = [...(currentPhaseVotes[currentEmojiTarget] || [])];
  
  updateModalButtonStates();
  document.getElementById('emoji-modal').style.display = 'block';
  document.getElementById('modal-backdrop').style.display = 'block';
}

function switchPhase(phaseId) {
    currentActivePhase = phaseId;
    updatePhaseButtonStates();
    updateDiv1Visuals(); // í˜ì´ì¦ˆ ì „í™˜ ì‹œ div1 ë¹„ì£¼ì–¼ ì—…ë°ì´íŠ¸

    // ëª¨ë‹¬ì´ ì—´ë ¤ìˆì„ ë•Œ í˜ì´ì¦ˆë¥¼ ë°”ê¾¸ë©´, ì„ì‹œ ì„ íƒ ìƒíƒœë¥¼ ìƒˆ í˜ì´ì¦ˆ ê¸°ì¤€ìœ¼ë¡œ ì—…ë°ì´íŠ¸
    if (document.getElementById('emoji-modal').style.display === 'block') {
        const currentPhaseVotes = phaseEmojiMaps[currentActivePhase];
        tempEmojiSelection = [...(currentPhaseVotes[currentEmojiTarget] || [])];
        updateModalButtonStates(); // ìˆ«ì ë²„íŠ¼ ìƒ‰ìƒ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ë‹¤ì‹œ í˜¸ì¶œ
    }
    saveState(); 
}

function toggleTempEmoji(emoji) {
  const index = tempEmojiSelection.indexOf(emoji);
  if (index > -1) {
    tempEmojiSelection.splice(index, 1);
  } else {
    tempEmojiSelection.push(emoji);
  }
  updateModalButtonStates();
}

function updateModalButtonStates() {
  const buttons = document.querySelectorAll('#emoji-buttons button');
  const activePhaseColorClass = phaseConfig[currentActivePhase].emojiColorClass;

  buttons.forEach(btn => {
    // ì´ì „ í˜ì´ì¦ˆ ìƒ‰ìƒ í´ë˜ìŠ¤ ì œê±°
    Object.values(phaseConfig).forEach(config => {
        btn.classList.remove(config.emojiColorClass);
    });

    if (tempEmojiSelection.includes(btn.innerText)) {
      btn.classList.add('active');
      btn.classList.add(activePhaseColorClass); // í˜„ì¬ í˜ì´ì¦ˆ ìƒ‰ìƒ í´ë˜ìŠ¤ ì¶”ê°€
    } else {
      btn.classList.remove('active');
    }
  });
}

function updatePhaseButtonStates() {
    const buttons = document.querySelectorAll('.phase-button');
    buttons.forEach(btn => {
        if (btn.dataset.phaseId === currentActivePhase) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
}

function confirmEmojiSelection() {
  if (currentEmojiTarget) {
    // í˜„ì¬ í™œì„±í™”ëœ í˜ì´ì¦ˆì˜ íˆ¬í‘œ ë‚´ì—­ì— ë°˜ì˜
    phaseEmojiMaps[currentActivePhase][currentEmojiTarget] = [...tempEmojiSelection];
    updateDiv1Visuals();
    saveState(); 
  }
  closeEmojiModal();
}

function cancelEmojiSelection() {
  closeEmojiModal();
}

// 'ì´ˆê¸°í™”' ëŒ€ì‹  'ë¹„ìš°ê¸°' ë²„íŠ¼ì´ ì´ ì—­í• ì„ ëŒ€ì‹ í•¨
function resetEmojiSelection() {
    // ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ 'ì´ˆê¸°í™”' ë²„íŠ¼ì— ì§ì ‘ ì—°ê²°ë˜ì§€ ì•ŠìŒ.
    // 'ë¹„ìš°ê¸°' ë˜ëŠ” 'ì´ˆê¸°í™”' í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ í•„ìš” ì‹œ í˜¸ì¶œë  ìˆ˜ ìˆìŒ.
    tempEmojiSelection = [];
    updateModalButtonStates();
}

function closeEmojiModal() {
  document.getElementById('emoji-modal').style.display = 'none';
  document.getElementById('modal-backdrop').style.display = 'none';
  currentEmojiTarget = null;
}

// ìƒˆë¡œìš´ í•¨ìˆ˜: í˜„ì¬ í˜ì´ì¦ˆ íˆ¬í‘œ ë‚´ì—­ ë¹„ìš°ê¸° (ëª¨ë‹¬ì˜ 'ë¹„ìš°ê¸°' ë²„íŠ¼ê³¼ ì—°ê²°)
function handleClearCurrentVote() {
    if (currentEmojiTarget) { // íŠ¹ì • inputì— ëŒ€í•œ ëª¨ë‹¬ì´ ì—´ë ¤ìˆì„ ë•Œë§Œ ë™ì‘
        phaseEmojiMaps[currentActivePhase][currentEmojiTarget] = []; // í˜„ì¬ í˜ì´ì¦ˆì˜ í•´ë‹¹ input íˆ¬í‘œ ì´ˆê¸°í™”
        updateDiv1Visuals(); // UI ì—…ë°ì´íŠ¸
        saveState(); // ìƒíƒœ ì €ì¥
        tempEmojiSelection = []; // ëª¨ë‹¬ ë‚´ë¶€ ì„ì‹œ ì„ íƒë„ ì´ˆê¸°í™”
        updateModalButtonStates();
    }
    // ëª¨ë‹¬ì´ ë‹«í˜€ìˆì„ ë•Œ 'ë¹„ìš°ê¸°' ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì „ì²´ currentActivePhaseì˜ íˆ¬í‘œë¥¼ ë¹„ìš¸ ìˆ˜ë„ ìˆì§€ë§Œ,
    // í˜„ì¬ ìš”ì²­ì‚¬í•­ì€ ëª¨ë‹¬ ë‚´ë¶€ ë²„íŠ¼ì´ë¯€ë¡œ íŠ¹ì • inputì— ëŒ€í•œ ë™ì‘ìœ¼ë¡œ ì œí•œ
}

// ìƒˆë¡œìš´ í•¨ìˆ˜: ëª¨ë“  í˜ì´ì¦ˆ íˆ¬í‘œ ë‚´ì—­ ì´ˆê¸°í™” (ëª¨ë‹¬ì˜ 'ì´ˆê¸°í™”' ë²„íŠ¼ê³¼ ì—°ê²°)
function handleResetAllVotes() {
    // ëª¨ë“  í˜ì´ì¦ˆì˜ ëª¨ë“  íˆ¬í‘œ ë‚´ì—­ ì´ˆê¸°í™”
    phaseEmojiMaps = { 
        phase1: {}, 
        phase2: {}, 
        phase3: {}, 
        phase4: {} 
    }; 
    currentActivePhase = 'phase1'; // ì´ˆê¸° í˜ì´ì¦ˆë¡œ ë˜ëŒë¦¬ê¸°

    updateDiv1Visuals(); // UI ì—…ë°ì´íŠ¸
    updatePhaseButtonStates(); // í˜ì´ì¦ˆ ë²„íŠ¼ UI ì—…ë°ì´íŠ¸
    saveState(); // ìƒíƒœ ì €ì¥
    
    // ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ì„ì‹œ ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
    if (document.getElementById('emoji-modal').style.display === 'block') {
        tempEmojiSelection = [];
        updateModalButtonStates();
    }
}

// --- UI ì—…ë°ì´íŠ¸ (UI Updates) ---

function updateDiv1Visuals() {
    for (let i = 1; i <= 8; i++) {
        const inputId = `input${i}`;
        const overlay = document.getElementById(`emoji-overlay-${inputId}`);
        if (!overlay) continue;
        
        overlay.innerHTML = ''; // ê¸°ì¡´ íˆ¬í‘œ ì•„ì´ì½˜ ì´ˆê¸°í™”
        
        Object.keys(phaseConfig).forEach(phaseId => {
            const votesInPhase = phaseEmojiMaps[phaseId];
            if (votesInPhase[inputId] && votesInPhase[inputId].length > 0) {
                votesInPhase[inputId].forEach(voter => {
                    const indicator = document.createElement('div');
                    indicator.className = `vote-indicator ${phaseConfig[phaseId].colorClass}`;
                    indicator.textContent = voter;
                    overlay.appendChild(indicator);
                });
            }
        });
    }
}


// --- ë°ì´í„° ì²˜ë¦¬ (Data Handling) ---

function parseStatement(text) {
    const stmt = {};
    if (!text) return stmt;

    let remaining = text.trim();

    // 1. Respond (//)
    let parts = remaining.split('//');
    if (parts.length > 1) {
        const respond = parts.pop().trim();
        if (respond) stmt.respond = respond;
        remaining = parts.join('//').trim();
    }

    // 2. Elaborate2 (>>)
    parts = remaining.split('>>');
    if (parts.length > 1) {
        const elaborate2 = parts.pop().trim();
        if (elaborate2) stmt.elaborate2 = elaborate2;
        remaining = parts.join('>>').trim();
    }

    // 3. Elaborate1 (ã…¡)
    parts = remaining.split('ã…¡');
    if (parts.length > 1) {
        const elaborate1 = parts.pop().trim();
        if (elaborate1) stmt.elaborate1 = elaborate1;
        remaining = parts.join('ã…¡').trim();
    }

    // 4. Subject and Opening (:)
    parts = remaining.split(':');
    if (parts.length > 1) {
        const subject = parts.shift().trim();
        if (subject) stmt.subject = subject;
        const opening = parts.join(':').trim();
        if (opening) stmt.opening = opening;
    } else {
        const opening = remaining.trim();
        if (opening) stmt.opening = opening;
    }

    return stmt;
}

function getStmtSignature(stmt) {
    if (!stmt) return '';
    const parts = [
        stmt.subject,
        stmt.opening,
        stmt.elaborate1,
        stmt.elaborate2
    ];
    return parts.join('').replace(/\s+/g, '');
}

async function checkPassword() {
  const pwRef = ref(db, "pw");
  const snapshot = await get(pwRef);
  if (!snapshot.exists()) {
    alert("ì„œë²„ì— ë¹„ë°€ë²ˆí˜¸ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return false;
  }
  const correctPw = snapshot.val();
  const inputPw = prompt("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”");
  if (inputPw === null) return false;
  if (inputPw === correctPw) {
    localStorage.setItem('ìŠ¹ì¸', 'true');
    alert("ì¸ì¦ë˜ì—ˆìŠµë‹ˆë‹¤.");
    return true;
  } else {
    alert("ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return false;
  }
}

window.addSingle = async function () {
  const isApproved = localStorage.getItem('ìŠ¹ì¸') === 'true';
  if (!isApproved) {
    const success = await checkPassword();
    if (!success) return;
  }

  const singleVal = document.getElementById("singleInput").value.trim();
  const words = singleVal.split(',').map(w => w.trim().replace(/\s+/g, '')).filter(Boolean);
  if (!words.length) {
    alert("ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
    return;
  }

  const newStatements = [];
  for (let i = 1; i <= visibleCount; i++) {
    const input = document.getElementById(`input${i}`);
    const rawText = input.value.trim();
    if (input && rawText) {
      const items = rawText.split(',').map(v => v.trim()).filter(Boolean);
      const parsedItems = items.map(parseStatement);
      newStatements.push(...parsedItems);
    }
  }

  const snapshot = await get(ref(db, "liar_groups"));
  const groupsData = snapshot.exists() ? snapshot.val() : {};

  const wordToGroup = {};
  const groupMap = {};

  Object.entries(groupsData).forEach(([groupId, group]) => {
    groupMap[groupId] = group;
    group.words.forEach(word => {
      wordToGroup[word] = groupId;
    });
  });

  const matchedGroupIds = [...new Set(
    words.map(word => wordToGroup[word]).filter(Boolean)
  )];

  if (matchedGroupIds.length === 0) {
    const allIds = new Set(Object.keys(groupsData));
    let newGroupId = null;
    for (let i = 0; i <= 9999; i++) {
      const candidate = i.toString().padStart(4, '0');
      if (!allIds.has(candidate)) {
        newGroupId = candidate;
        break;
      }
    }

    if (!newGroupId) {
      alert("ë” ì´ìƒ ìƒì„± ê°€ëŠ¥í•œ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    const latestTimestamp = Date.now();
    const newGroupData = {
      words: [...new Set(words)],
      statements: newStatements,
      timestamp: latestTimestamp
    };

    await set(ref(db, `liar_groups/${newGroupId}`), newGroupData);
    loadFromDB();
    return;
  }


  let mergedWords = [];
  let mergedStatements = [];
  matchedGroupIds.forEach(groupId => {
    const group = groupMap[groupId];
    mergedWords.push(...group.words);
    mergedStatements.push(...(group.statements || []));
  });

  mergedWords.push(...words);
  mergedWords = [...new Set(mergedWords)];

  const existingSignatures = new Set(mergedStatements.map(getStmtSignature));
  const uniqueNewStatements = newStatements.filter(stmt => {
      const signature = getStmtSignature(stmt);
      return signature && !existingSignatures.has(signature);
  });
  
  mergedStatements.push(...uniqueNewStatements);

  const latestTimestamp = Date.now();
  const primaryGroupId = matchedGroupIds[0];

  const updates = {};
  updates[`liar_groups/${primaryGroupId}`] = {
    words: mergedWords,
    statements: mergedStatements,
    timestamp: latestTimestamp
  };

  matchedGroupIds.slice(1).forEach(groupId => {
    updates[`liar_groups/${groupId}`] = null;
  });

  await update(ref(db), updates);
  loadFromDB();
};

// ì´ í•¨ìˆ˜ëŠ” ì´ì œ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëª¨ë‹¬ ë‚´ì˜ 'ë¹„ìš°ê¸°'ì™€ 'ì´ˆê¸°í™”' ë²„íŠ¼ì´ ì´ ì—­í• ì„ ëŒ€ì²´í•©ë‹ˆë‹¤.
// ë©”ì¸ í™”ë©´ì˜ 'ë¹„ìš°ê¸°' ë²„íŠ¼ì€ ê·¸ëŒ€ë¡œ clearInputs í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
window.clearInputs = function () {
  // ëª¨ë“  ì…ë ¥ì°½ ë¹„ìš°ê¸°
  for (let i = 1; i <= 8; i++) {
    const input = document.getElementById(`input${i}`);
    if (input) input.value = '';
  }
  document.getElementById("singleInput").value = '';

  // ëª¨ë“  í˜ì´ì¦ˆ ë°ì´í„° ì´ˆê¸°í™” (ëª¨ë“  íˆ¬í‘œ ì´ˆê¸°í™”ì™€ ë™ì¼í•œ ê¸°ëŠ¥)
  phaseEmojiMaps = { phase1: {}, phase2: {}, phase3: {}, phase4: {} };
  currentActivePhase = 'phase1';
  
  // UI ì—…ë°ì´íŠ¸
  updateDiv1Visuals();
  updatePhaseButtonStates();
  updateHighlights();
  
  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í´ë¦¬ì–´
  localStorage.removeItem('ìƒíƒœë°±ì—…');
};

window.loadFromDB = async function () {
  const output = document.getElementById("output");
  output.innerHTML = "ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...";
  try {
    const snapshot = await get(ref(db, "liar_groups"));
    output.innerHTML = "";
    if (snapshot.exists()) {
      const rawData = snapshot.val();
      const entries = Object.entries(rawData)
        .sort((a, b) => b[1].timestamp - a[1].timestamp);
      groupList = entries.map(entry => entry[1].words);
      updateHighlights();
    } else {
      output.innerHTML = "ğŸ”¥ ë°ì´í„° ì—†ìŒ";
    }
  } catch(e) {
    output.innerHTML = `âŒ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${e.message}`;
  }
};

function updateHighlights() {
  const value = document.getElementById("singleInput").value.trim();
  const keywords = value.split(',').map(v => v.trim()).filter(Boolean);
  renderGroups(keywords);
}

function renderGroups(highlightWords = []) {
  const output = document.getElementById("output");
  output.innerHTML = "";
  const highlighted = [], rest = [];
  for (const group of groupList) {
    const text = group.join(", ");
    const div = document.createElement("div");
    div.className = "group";
    div.innerText = text;
    div.onclick = () => {
      document.getElementById("singleInput").value = text;
      updateHighlights();
    };
    if (highlightWords.length > 0 && highlightWords.some(w => group.includes(w))) {
      div.classList.add("highlight");
      highlighted.push(div);
    } else {
      rest.push(div);
    }
  }
  [...highlighted, ...rest].forEach(div => output.appendChild(div));
}


// --- ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ (Local Storage) ---

function saveState() {
  const data = {
      inputs: {},
      phaseMaps: phaseEmojiMaps,
      activePhase: currentActivePhase,
      visible: visibleCount
  };
  for (let i = 1; i <= 8; i++) {
    const input = document.getElementById(`input${i}`);
    if (input) data.inputs[`input${i}`] = input.value;
  }
  data.inputs['singleInput'] = document.getElementById('singleInput').value;
  localStorage.setItem('ìƒíƒœë°±ì—…', JSON.stringify(data));
}

function restoreState() {
  const saved = localStorage.getItem('ìƒíƒœë°±ì—…');
  if (!saved) return;
  try {
    const data = JSON.parse(saved);
    
    // ì…ë ¥ê°’ ë³µì›
    if (data.inputs) {
      for (let key in data.inputs) {
        const el = document.getElementById(key);
        if (el) el.value = data.inputs[key];
      }
    }
    
    // í˜ì´ì¦ˆ ë°ì´í„° ë³µì›
    if (data.phaseMaps) phaseEmojiMaps = data.phaseMaps;
    if (data.activePhase) currentActivePhase = data.activePhase;
    if (data.visible) visibleCount = data.visible;

    // UI ë³µì›
    updateInputVisibility();
    updateDiv1Visuals();
    updatePhaseButtonStates();
    updateHighlights();
  } catch (e) {
    console.error("ìƒíƒœ ë³µì› ì‹¤íŒ¨:", e);
    // ë³µì› ì‹¤íŒ¨ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì´ˆê¸°í™”
    localStorage.removeItem('ìƒíƒœë°±ì—…');
  }
}

// --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (Event Listeners) ---

function attachFocusListeners() {
  // í˜„ì¬ ê°€ì‹œì ì¸ ë°•ìŠ¤ë§Œ ëŒ€ìƒìœ¼ë¡œ í¬ì»¤ìŠ¤ ì´ë™
  const getVisibleBoxes = () => {
    const ids = [];
    for(let i=1; i<=visibleCount; i++) ids.push(`input${i}`);
    ids.push("singleInput");
    return ids.map(id => document.getElementById(id));
  };

  const boxes = getVisibleBoxes();
  boxes.forEach((box, idx) => {
    box.onkeydown = (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        const nextBoxes = getVisibleBoxes(); 
        const next = nextBoxes[idx + 1] || nextBoxes[0];
        next.focus();
      }
    };
  });
}

function attachInputListeners() {
  // ëª¨ë“  input ì—˜ë¦¬ë¨¼íŠ¸ì— ëŒ€í•œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (input1-8, singleInput)
  const ids = ["input1", "input2", "input3", "input4", "input5", "input6", "input7", "input8", "singleInput"];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input', saveState); // ê°’ ë³€ê²½ ì‹œ ìƒíƒœ ì €ì¥
    }
  });
  // singleInputì˜ ê²½ìš°, í•˜ì´ë¼ì´íŠ¸ ì—…ë°ì´íŠ¸ë„ ì—°ê²°
  document.getElementById("singleInput").addEventListener("input", updateHighlights);
}

// ì „ì—­ ìŠ¤ì½”í”„ì— í•¨ìˆ˜ ë…¸ì¶œ (HTMLì—ì„œ ì§ì ‘ í˜¸ì¶œ ê°€ëŠ¥í•˜ë„ë¡)
window.addSingle = addSingle;
window.clearInputs = clearInputs; // ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ë©”ì¸ 'ë¹„ìš°ê¸°' ë²„íŠ¼ì— ì—°ê²°ë˜ì§€ ì•ŠìŒ. í•„ìš” ì‹œ ìˆ˜ë™ í˜¸ì¶œ.
window.loadFromDB = loadFromDB;
window.openEmojiModal = openEmojiModal;
window.addInput = addInput; 
window.removeInput = removeInput; 
window.handleClearCurrentVote = handleClearCurrentVote;
window.handleResetAllVotes = handleResetAllVotes;
</script>

</body>
</html>
