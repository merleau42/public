<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>비즈니스 배틀 시뮬레이터 — Responsive Refactor</title>
  <style>
    :root{
      --accent:#4caf50;
      --accent-dark:#2e7d32;
      --muted:#f7f7f7;
      --ink:#222;
      --ink-2:#555;
      --ink-3:#888;
      --bg:#f3f4f6;
      --tab:#e9ecef;
      --tab-active:#ffffff;
      /* mobile viewport fix (set via JS) */
      --svh: 100vh;
      --space: clamp(10px, 2.2vmin, 16px);
      --radius: 12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", Arial, sans-serif;
      margin:0; padding:var(--space);
      background:var(--bg);
      color:var(--ink);
      -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
    }

    /* App shell */
    .app{ 
      max-width: min(960px, 100%);
      margin-inline: auto;
      display: grid;
      gap: var(--space);
    }

    /* Tabs */
    .tabs{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }
    .tab-btn{
      background: var(--tab);
      border:1px solid #d0d0d0;
      color: var(--ink-2);
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      font-weight:700;
      line-height: 1.2;
      transition: transform .08s ease, background .2s ease, color .2s ease;
      min-height: 42px; /* touch target */
    }
    .tab-btn:hover{ transform: translateY(-1px); }
    .tab-btn.active{
      background: var(--tab-active);
      color:#111;
      border-color:#cfcfcf;
      box-shadow: 0 2px 10px rgba(0,0,0,.06);
    }

    /* Panels */
    .panel{
      background: #fff;
      padding: clamp(12px, 2.2vmin, 18px);
      border-radius: var(--radius);
      box-shadow: 0 1px 6px rgba(0,0,0,.06);
      display:none;
    }
    .panel.active{ display:block; }

    /* Layout inside a panel */
    .game-container-inner{
      display:grid;
      gap: clamp(8px, 2vmin, 14px);
    }

    .stage-header{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      flex-wrap: wrap;
    }
    .stage-title-nav{ display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
    .stage-title-nav h1{ margin:0; font-size: clamp(18px, 3.2vmin, 24px); }

    .nav-button{ background:none; border:none; font-size: 1.4em; cursor:pointer; color:var(--ink-2); user-select:none; padding: 2px 6px; border-radius: 8px; }
    .nav-button:hover{ background:#f1f3f5; color:#111; }

    #randomStageButton, #stageOneButton{
      background:#e53935;
      color:#fff;
      border:none;
      border-radius:10px;
      padding:8px 12px;
      font-size: 0.95rem;
      font-weight:700;
      cursor:pointer;
    }
    #randomStageButton:hover, #stageOneButton:hover{ filter: brightness(.95); }

    /* Style for button group */
    .stage-buttons {
      display: flex;
      gap: 5px; /* Added gap here */
    }

    .seed-display{ font-size: 1rem; color:var(--ink); min-height: 1.6em; display:flex; flex-wrap:wrap; align-items:center; gap:6px; }
    .seed-span{ color: var(--ink-3); font-size:.95em; cursor:pointer; text-decoration: underline; }
    .seed-span:hover{ color:#444; }
    .seed-span.active{ color:#111; font-weight:700; text-decoration: underline; }
    .seed-sep{ color:#999; user-select:none; }

    .game-status-display{ font-size:1.1em; color:var(--ink-2); min-height:1.6em; }

    /* Grid sizing — responsive without fixed heights */
    .grid-zone{ display:grid; place-items:center; }
    .grid-wrap{
      width: min(92vw, 560px);
      /* keep it inside available vertical space on short screens */
      max-height: calc(var(--svh) - 280px);
      aspect-ratio: 1 / 1;
    }

    .grid-container{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: clamp(4px, 1.2vmin, 8px);
      width:100%; height:100%;
    }

    .grid-cell{
      background: var(--accent);
      border: 2px solid var(--accent-dark);
      border-radius: 10px;
      display:flex; align-items:center; justify-content:center;
      --base-fs: clamp(1.2rem, 12vmin, 2.2rem);
      font-size: var(--base-fs);
      font-weight: 800;
      color:#fff; text-align:center; user-select:none;
      cursor: pointer;
      transition: background-color .2s, transform .08s, font-size .15s ease;
      min-height: 0; /* fix flex/grid min-content on Safari */
    }
    .grid-cell:not(.revealed):hover{ background:#66bb6a; transform: translateY(-1px); }
    .grid-cell.revealed{ background: var(--muted); color: var(--ink); cursor: default; }
    .grid-cell.winner{ font-size: calc(var(--base-fs) * 1.8); background:aquamarine; }

    /* Creator */
    .creator-controls{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; width:100%; }
    .creator-controls button, .creator-controls input{
      padding:10px; border-radius:10px; border:1px solid #d0d0d0; font-weight:700; background:#fff; cursor:pointer; color:#222; min-height: 42px;
    }
    .creator-controls button:hover{ background:#fafafa; }
    .note{ font-size:.92em; color:#666; }
    .legend{ display:flex; gap:8px; align-items:center; margin:4px 0 8px; }
    .legend span{ display:inline-flex; align-items:center; gap:4px; font-size:.95em; }
    .pill{ display:inline-block; min-width:22px; text-align:center; padding:2px 8px; border-radius:999px; background:#eef1f4; border:1px solid #dfe3e7; font-weight:700; }
    .row{ width:100%; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .grow{ flex:1; min-width: 200px; }

    /* Small screens adjustments */
    @media (max-width: 480px){
      .seed-display{ gap:4px; font-size: 0.98rem; }
      #randomStageButton, #stageOneButton{ padding:6px 10px; }
      .creator-controls{ grid-template-columns: 1fr; }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .tab-btn, .grid-cell{ transition: none; }
    }

    /* Confetti styles */
    .confetti-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 1000;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #f00; /* Default color, will be randomized */
      opacity: 0;
      animation: confetti-fall 2s forwards;
    }

    @keyframes confetti-fall {
      0% {
        opacity: 0;
        transform: translateY(-100px) rotate(0deg);
      }
      10% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translateY(100vh) rotate(720deg);
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="tabs" role="tablist">
      <button class="tab-btn active" data-tab="play" role="tab" aria-controls="panel-play" aria-selected="true">▶ 플레이</button>
      <button class="tab-btn" data-tab="make" role="tab" aria-controls="panel-make" aria-selected="false">🛠 만들기</button>
    </div>

    <!-- 플레이 패널 -->
    <section id="panel-play" class="panel active" role="tabpanel" aria-labelledby="tab-play">
      <div class="game-container-inner">
        <div class="stage-header">
          <div class="stage-title-nav">
            <button id="prevStageButton" class="nav-button" title="이전 스테이지" aria-label="이전 스테이지">◀</button>
            <h1 id="stageTitle">스테이지 000</h1>
            <button id="nextStageButton" class="nav-button" title="다음 스테이지" aria-label="다음 스테이지">▶</button>
          </div>
          <div class="stage-buttons">
            <button id="stageOneButton" title="1번 스테이지" aria-label="1번 스테이지">1</button>
            <button id="randomStageButton" title="무작위 스테이지" aria-label="무작위 스테이지">R</button>
          </div>
        </div>
        <div class="seed-display" id="seedDisplay"></div>
        <div class="game-status-display" id="gameStatusDisplay"></div>
        <div class="grid-zone">
          <div class="grid-wrap"><div class="grid-container" id="gameGrid"></div></div>
        </div>
      </div>
    </section>

    <!-- 만들기 패널 -->
    <section id="panel-make" class="panel" role="tabpanel" aria-labelledby="tab-make">
      <div class="game-container-inner" id="creator">
        <div class="row" style="justify-content:space-between">
          <h2 style="margin:0">맵 만들기</h2>
        </div>
        <div class="note">셀을 클릭하여 💩→🙂→💎 순서로 바꿉니다.</div>
        <div class="grid-zone">
          <div class="grid-wrap"><div class="grid-container" id="makerGrid"></div></div>
        </div>
        <div class="row" id="makerSeedContainer">
          <div class="grow"><strong>현재 시드(HEX):</strong> <span id="makerSeed">-</span></div>
        </div>
        <div class="creator-controls">
          <button id="clearMaker">초기화</button>
          <button id="randomizeMaker">무작위</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Confetti container -->
  <div class="confetti-container" id="confettiContainer"></div>

  <script>
    // ---------- Viewport-safe height CSS var ----------
    const setSVH = () => {
      // Use innerHeight to avoid mobile URL bar issues
      document.documentElement.style.setProperty('--svh', window.innerHeight + 'px');
    };
    setSVH();
    window.addEventListener('resize', setSVH, { passive: true });

    // ---------- DOM helpers ----------
    const Q = (x, y = document) => y.querySelector(x);
    const QQ = (x, y = document) => [...y.querySelectorAll(x)];
    const Elem = (config) => {
      const { tag = "div", text = "", class: className = "", ...attrs } = config;
      const el = document.createElement(tag);
      el.innerText = text;
      el.className = className;
      Object.keys(attrs).forEach((attr) => el.setAttribute(attr, attrs[attr]));
      return el;
    };

    // ---------- Tabs ----------
    function setupTabs(){
      QQ('.tab-btn').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          QQ('.tab-btn').forEach(b=>{ b.classList.remove('active'); b.setAttribute('aria-selected','false'); });
          QQ('.panel').forEach(p=>p.classList.remove('active'));
          btn.classList.add('active');
          btn.setAttribute('aria-selected','true');
          const key = btn.dataset.tab;
          Q('#panel-'+key).classList.add('active');
        })
      })
    }

    // ---------- Game constants ----------
    const GRID_SIZE = 3;
    const NUM_GEMS_PER_TYPE = 3;
    const GEM_TYPES = ["0", "1", "2"]; // semantic order
    const NUM_MAPS_PER_STAGE = 3;

    const RANDOM_TIPS = [
      "[팁] 숨겨진 보석을 찾아보세요!",
      "[팁] 세 가지 맵이 랜덤한 순서로 출제돼요~",
	    "[팁] 나만의 전략을 탐구해보세요!"
    ];

    // ---------- State ----------
    let allStagesData = [];
    let hexmapData = []; // hexmap.csv 데이터를 저장할 변수
    let currentStage = 0;
    let currentMapIndex = 0;           // 위치(0,1,2)
    let currentMapOrder = [];          // 예: [2,0,1]
    let revealedCells = [];
    let gemCounts = [0,0,0];
    let isGameOver = false;
    let currentMapGrid = [];
    let winningGemType = null;

    // ---------- Seed enc/dec ----------
    function hexToTernaryGrid(hexSeed){
      const decimalValue = parseInt(hexSeed, 16);
      let ternaryString = "";
      let tempValue = decimalValue;
      for(let i=0;i<9;i++){
        ternaryString = (tempValue % 3) + ternaryString;
        tempValue = Math.floor(tempValue / 3);
      }
      const grid = [];
      for(let r=0;r<GRID_SIZE;r++){
        const row=[];
        for(let c=0;c<GRID_SIZE;c++){
          const value = parseInt(ternaryString[r*GRID_SIZE + c], 10);
          row.push(GEM_TYPES[value]);
        }
        grid.push(row);
      }
      return grid;
    }

    function ternaryGridToHex(grid){
      let ternaryString = "";
      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          ternaryString += grid[r][c];
        }
      }
      let dec = 0;
      for(let i=0;i<ternaryString.length;i++){
        dec = dec*3 + parseInt(ternaryString[i],10);
      }
      return dec.toString(16);
    }

    // ---------- CSV parsing ----------
    function parseCSV(csvText){
      const lines = csvText.trim().split(/\r?\n/);
      const headers = lines[0].split(",").map(h=>h.trim());
      const data=[];
      for(let i=1;i<lines.length;i++){
        const values = lines[i].split(",").map(v=>v.trim());
        const stage = { seed: [] };
        headers.forEach((header, idx)=>{
          if(header.startsWith("seed")) stage.seed.push(values[idx]);
          else if(header === "index") stage.index = parseInt(values[idx],10);
          else stage[header] = values[idx];
        })
        data.push(stage);
      }
      return data;
    }
    
    // hexmap.csv 파싱 함수 추가
    function parseHexmapCSV(csvText) {
      return csvText.trim().split(/\r?\n/).filter(line => line.length > 0);
    }

    // ---------- Game (Play) ----------
    async function initGame(){
      setupTabs();
      try{
        const resStages = await fetch('stages.csv');
        if(resStages.ok){
          const csvText = await resStages.text();
          allStagesData = parseCSV(csvText);
        } else {
          allStagesData = [];
        }

        // hexmap.csv 로드
        const resHexmap = await fetch('hexmap.csv');
        if(resHexmap.ok){
          const hexmapText = await resHexmap.text();
          hexmapData = parseHexmapCSV(hexmapText);
        } else {
          hexmapData = [];
        }

      }catch(e){ 
        allStagesData = []; 
        hexmapData = [];
      }

      if(allStagesData.length===0){
        allStagesData = [{ index:0, seed:["0","1","2"] }];
      }

      loadStage(0, false);

      Q('#randomStageButton').addEventListener('click', ()=> loadRandomStage(true));
      Q('#stageOneButton').addEventListener('click', ()=> loadStage(0, true)); // 1번 스테이지로 이동
      Q('#prevStageButton').addEventListener('click', ()=> changeStage(-1));
      Q('#nextStageButton').addEventListener('click', ()=> changeStage(1));

      updateGameStatusDisplay(getRandomTip());

      // Creator 초기화
      initCreator();
    }

    function loadRandomStage(updateStatus=true){
      const randomIndex = Math.floor(Math.random()*allStagesData.length);
      loadStage(randomIndex, updateStatus);
    }

    function changeStage(direction){
      let newStage = currentStage + direction;
      if(newStage < 0) newStage = allStagesData.length-1;
      else if(newStage >= allStagesData.length) newStage = 0;
      loadStage(newStage, true);
    }

    function loadStage(stageIndex, updateStatus=true){
      currentStage = stageIndex;
      currentMapIndex = 0;
      isGameOver = false;
      gemCounts=[0,0,0];
      winningGemType = null;

      currentMapOrder = Array.from({length: NUM_MAPS_PER_STAGE}, (_,i)=>i).sort(()=>Math.random()-0.5);

      updateStageUI();
      loadCurrentMap();
      if(updateStatus) updateGameStatusDisplay(getRandomTip());
    }

    function updateStageUI(){
      const stageData = allStagesData[currentStage];
      Q('#stageTitle').textContent = `스테이지 ${String(currentStage+1).padStart(3,'0')}`;
      const seedDisplayDiv = Q('#seedDisplay');
      seedDisplayDiv.innerHTML = '';

      currentMapOrder.forEach((actualIdx, orderPos)=>{
        const seedHex = stageData.seed[actualIdx];
        const span = Elem({ tag:'span', text: seedHex, class: 'seed-span' + (orderPos===currentMapIndex? ' active':''), 'data-order-pos': orderPos });
        span.addEventListener('click', ()=> loadMapByOrderPos(orderPos));
        seedDisplayDiv.appendChild(span);
        if(orderPos < currentMapOrder.length-1){ seedDisplayDiv.appendChild(Elem({tag:'span', text:'→', class:'seed-sep'})); }
      })
    }

    function loadMapByOrderPos(orderPos){ currentMapIndex = orderPos; loadCurrentMap(); }

    function loadCurrentMap(){
      const stageData = allStagesData[currentStage];
      const actualMapIndex = currentMapOrder[currentMapIndex];
      const currentSeed = stageData.seed[actualMapIndex];

      currentMapGrid = hexToTernaryGrid(currentSeed);

      revealedCells = Array(GRID_SIZE).fill(0).map(()=>Array(GRID_SIZE).fill(false));
      gemCounts = [0,0,0];
      isGameOver = false; winningGemType = null;

      createGridUI();
      updateStageUI();
      updateGameStatusDisplay(getRandomTip());
    }

    function createGridUI(){
      const gridEl = Q('#gameGrid');
      gridEl.innerHTML = '';
      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          const cell = Elem({ tag:'div', class:'grid-cell', 'data-row':r, 'data-col':c });
          cell.addEventListener('click', ()=> handleCellClick(r,c));
          gridEl.appendChild(cell);
        }
      }
      updateUI();
    }

    function handleCellClick(row,col){
      if(isGameOver){ // If game is over, reset the map
        loadCurrentMap();
        return;
      }
      if(revealedCells[row][col]) return; // If cell is already revealed, do nothing
      revealedCells[row][col] = true;
      const gemType = currentMapGrid[row][col];
      const gemIndex = GEM_TYPES.indexOf(gemType);
      if(gemIndex!==-1) gemCounts[gemIndex]++;

      updateUI();

      if(gemCounts[gemIndex] === NUM_GEMS_PER_TYPE){
        isGameOver = true; winningGemType = gemType; highlightWinningCells(gemType);
        if(gemType==="0") {updateGameStatusDisplay('꽝! 아쉬워요...😢'); };
        if(gemType==="1") {updateGameStatusDisplay('좋아요~ 🙂'); triggerConfetti(55)};
        if(gemType==="2") {updateGameStatusDisplay('대박! 🥰'); triggerConfetti(80)};
        return;
      }
      updateGameStatusDisplay(getRandomTip());
      checkLossCondition();
    }

    function updateUI(){
      const cells = QQ('.grid-cell', Q('#gameGrid'));
      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          const idx = r*GRID_SIZE + c;
          const cell = cells[idx];
          if(revealedCells[r][c]){
            cell.classList.add('revealed');
            const v = currentMapGrid[r][c];
            cell.textContent = ["💩","🙂","💎"][v];
            if(winningGemType!==null && v===winningGemType) cell.classList.add('winner'); else cell.classList.remove('winner');
          } else {
            cell.classList.remove('revealed','winner');
            cell.textContent = '?';
          }
        }
      }
    }

    function highlightWinningCells(targetGemType){
      const cells = QQ('.grid-cell', Q('#gameGrid'));
      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          if(revealedCells[r][c] && currentMapGrid[r][c]===targetGemType){
            cells[r*GRID_SIZE+c].classList.add('winner');
          }
        }
      }
    }

    function updateGameStatusDisplay(message){ Q('#gameStatusDisplay').textContent = message; }
    function getRandomTip(){ return RANDOM_TIPS[Math.floor(Math.random()*RANDOM_TIPS.length)]; }
    function checkLossCondition(){ /* 확장 여지 */ }

    // ---------- Confetti animation ----------
    function triggerConfetti(numConfetti) {
      const confettiContainer = Q('#confettiContainer');
      const colors = ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f'];

      for (let i = 0; i < numConfetti; i++) {
        const confetti = Elem({ tag: 'div', class: 'confetti' });
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.animationDelay = Math.random() * 1 + 's';
        confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
        confettiContainer.appendChild(confetti);

        // Remove confetti after animation to prevent DOM bloat
        confetti.addEventListener('animationend', () => {
          confetti.remove();
        });
      }
    }

    // ---------- Creator ----------
    let makerGrid = Array(GRID_SIZE).fill(0).map(()=>Array(GRID_SIZE).fill("0"));

    function initCreator(){
      const host = Q('#makerGrid');
      host.innerHTML = '';
      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          const cell = Elem({ tag:'div', class:'grid-cell revealed', 'data-r':r, 'data-c':c });
          cell.addEventListener('click', ()=> toggleMakerCell(r,c));
          host.appendChild(cell);
        }
      }
      updateMakerUI();

      Q('#clearMaker').addEventListener('click', ()=>{ makerGrid = makerGrid.map(row=>row.map(()=>"0")); updateMakerUI(); });
      
      Q('#randomizeMaker').addEventListener('click', ()=>{
        if (hexmapData.length > 0) {
          const randomIndices = [];
          while(randomIndices.length < GRID_SIZE) { // Get 3 unique random indices
            const randomIndex = Math.floor(Math.random() * hexmapData.length);
            if (!randomIndices.includes(randomIndex)) {
              randomIndices.push(randomIndex);
            }
          }
          // Choose one of the 3 random seeds to set as makerGrid
          const selectedHexSeed = hexmapData[randomIndices[0]]; 
          makerGrid = hexToTernaryGrid(selectedHexSeed);
        } else {
          // Fallback to current random logic if hexmapData is empty
          makerGrid = makerGrid.map(row=>row.map(()=> String(Math.floor(Math.random()*3)) )); 
        }
        updateMakerUI();
      });
      
      const makerSeedContainer = Q('#makerSeedContainer');
      makerSeedContainer.style.cursor = 'pointer'; // Make it visually clickable
      makerSeedContainer.style.textDecoration = 'underline'; // Add underline for emphasis
      makerSeedContainer.addEventListener('click', async ()=>{
        const seedSpan = Q('#makerSeed');
        const seed = seedSpan.textContent.trim();
        if(!seed || seed==='-') return;
        try{ 
          await navigator.clipboard.writeText(seed); 
          const originalText = seedSpan.textContent;
          seedSpan.textContent='복사됨'; 
          setTimeout(()=>seedSpan.textContent=originalText, 1200); 
        }catch(e){ 
          alert('클립보드 복사 실패'); 
        }
      });
    }

    function toggleMakerCell(r,c){
      const cur = makerGrid[r][c];
      const next = cur==='0'? '1' : cur==='1'? '2' : '0';
      makerGrid[r][c] = next;
      updateMakerUI();
    }

    function updateMakerUI(){
      const cells = QQ('#makerGrid .grid-cell');
      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          const idx = r*GRID_SIZE + c;
          const v = makerGrid[r][c];
          cells[idx].textContent = ["💩","🙂","💎"][v];
        }
      }
      const seed = ternaryGridToHex(makerGrid);
      Q('#makerSeed').textContent = seed;
    }

    // ---------- boot ----------
    window.addEventListener('load', initGame);
  </script>
  <div align="center">[버전 0.7] 25.08.20</div>
</body>
</html>