<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>단어수집기</title>
  <link rel="stylesheet" href="liarwords.css">
</head>
<body>

<!-- 입력창 -->
<div id="div1" class="flex-container"></div>

<!-- 단일 입력 + 버튼 -->
<div id="div2" class="flex-container">
  <textarea id="singleInput" maxlength="50" tabindex="9"></textarea>
  <!-- ▶ 버튼: 초기 텍스트 '로그인' -->
  <button id="add-button">로그인</button>
  <button onclick="clearInputs()">비우기</button>
  <button onclick="showHintModal()">힌트</button>
</div>

<!-- 출력 -->
<div id="div3"><div id="output"></div></div>

<!-- 이모지 선택 모달 -->
<div class="modal-backdrop" id="modal-backdrop"></div>
<div class="modal" id="emoji-modal">
  <div style="text-align: center; font-weight: bold;">받은 투표</div>
  <div id="emoji-buttons"></div>
  <hr>
  
  <!-- 페이즈 버튼 영역 -->
  <div id="phase-buttons" class="phase-buttons-container"></div>
  <div class="modal-footer">
    <button id="clear-current-button">비우기</button>
    <button id="reset-all-button">초기화</button>
    <button id="confirm-button">확인</button>
    <button id="cancel-button">취소</button>
  </div>
</div>

<!-- 힌트 모달 -->
<div class="modal-backdrop" id="hint-backdrop" style="display:none;"></div>
<div class="modal" id="hint-modal" style="display:none;">
  <div id="hint-content"></div>
  <div class="modal-footer">
    <button onclick="closeHintModal()">닫기</button>
  </div>
</div>


<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
import { getDatabase, ref, get, set, update } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";
import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";

// Firebase 초기화
const app = initializeApp({
  apiKey: "AIzaSyDVVAx9XRziu8IZ9CLczaG20QEOwyY4uLs",
  authDomain: "liarwords-af033.firebaseapp.com",
  databaseURL: "https://liarwords-af033-default-rtdb.firebaseio.com",
  projectId: "liarwords-af033",
  storageBucket: "liarwords-af033.appspot.com",
  messagingSenderId: "171671976030",
  appId: "1:171671976030:web:59371970ec6b2a70035ccf"
});
const db = getDatabase(app);

// ▶ Auth
const auth = getAuth(app);
const provider = new GoogleAuthProvider();

// --- 상태 변수 (State Variables) ---
let groupList = [];
let visibleCount = 8;
let currentEmojiTarget = null;
let tempEmojiSelection = [];
const emojiList = ['1','2','3','4','5','6','7','8'];

// 페이즈 시스템 상태 변수
let phaseEmojiMaps = {
  phase1: {},
  phase2: {},
  phase3: {},
  phase4: {}
};
let currentActivePhase = 'phase1';
const phaseConfig = {
  'phase1': { name: '페이즈1', colorClass: 'phase-1', emojiColorClass: 'phase-1-color' },
  'phase2': { name: '페이즈2', colorClass: 'phase-2', emojiColorClass: 'phase-2-color' },
  'phase3': { name: '페이즈3', colorClass: 'phase-3', emojiColorClass: 'phase-3-color' },
  'phase4': { name: '페이즈4', colorClass: 'phase-4', emojiColorClass: 'phase-4-color' }
};

// ▶ 추가 버튼 참조
const addButton = document.getElementById('add-button');

// --- 초기화 (Initialization) ---
document.addEventListener('DOMContentLoaded', () => {
  generateInputs();
  restoreState(); // 로컬 스토리지에서 모든 상태 복원
  attachInputListeners();
  attachFocusListeners();
  setupEmojiButtons();
  setupPhaseButtons();
  loadFromDB();

  // 모달 버튼 이벤트 리스너
  document.getElementById('clear-current-button').addEventListener('click', handleClearCurrentVote);
  document.getElementById('reset-all-button').addEventListener('click', handleResetAllVotes);
  document.getElementById('confirm-button').addEventListener('click', confirmEmojiSelection);
  document.getElementById('cancel-button').addEventListener('click', cancelEmojiSelection);
  document.getElementById('modal-backdrop').addEventListener('click', cancelEmojiSelection);
});

// ▶ 로그인 상태에 따라 '로그인'↔'추가' 텍스트/동작 전환
onAuthStateChanged(auth, (user) => {
  if (user) {
    // 로그인 상태: 버튼은 '추가' 동작
    addButton.textContent = '추가';
    addButton.onclick = addSingle;
  } else {
    // 비로그인 상태: 버튼은 로그인 유도
    addButton.textContent = '로그인';
    addButton.onclick = async () => {
      try {
        await signInWithPopup(auth, provider);
        // Rules가 쓰기 권한을 통제하므로, 여기선 UI 전환만 처리
      } catch (e) {
        alert('로그인 중 오류가 발생했습니다: ' + (e?.message || e));
        console.error(e);
      }
    };
  }
});

// --- 입력창 및 버튼 생성 (Input & Button Generation) ---
function generateInputs() {
  const div1 = document.getElementById('div1');
  div1.innerHTML = ''; // 기존 입력창 제거

  // 1~8번 입력창 생성
  for (let i = 1; i <= 8; i++) {
    const wrapper = document.createElement('div');
    wrapper.className = 'textarea-wrapper';
    wrapper.id = `wrapper-input${i}`;

    const textarea = document.createElement('textarea');
    textarea.id = `input${i}`;
    textarea.tabIndex = i;

    const emojiOverlay = document.createElement('div');
    emojiOverlay.className = 'emoji-overlay';
    emojiOverlay.id = `emoji-overlay-input${i}`;

    const emojiButton = document.createElement('button');
    emojiButton.className = 'emoji-button';
    emojiButton.innerText = '🏹';
    emojiButton.onclick = () => openEmojiModal(`input${i}`);

    wrapper.appendChild(textarea);
    wrapper.appendChild(emojiOverlay);
    wrapper.appendChild(emojiButton);

    div1.appendChild(wrapper);
  }

  // + - 버튼 컨테이너
  const iconContainer = document.createElement('div');
  iconContainer.id = 'icon-container';
  
  const addBtn = document.createElement('span');
  addBtn.id = 'addBtn';
  addBtn.className = 'icon-btn';
  addBtn.innerText = '➕';
  addBtn.onclick = addInput;

  const removeBtn = document.createElement('span');
  removeBtn.id = 'removeBtn';
  removeBtn.className = 'icon-btn';
  removeBtn.innerText = '➖';
  removeBtn.onclick = removeInput;

  iconContainer.appendChild(removeBtn);
  iconContainer.appendChild(addBtn);
  div1.appendChild(iconContainer);
  
  updateInputVisibility(); // 초기 가시성 설정
  attachFocusListeners();
}

// ➕➖ 버튼 로직
function addInput() {
  if (visibleCount < 8) {
    visibleCount++;
    saveState(); 
    updateInputVisibility();
    attachFocusListeners(); 
  }
}
function removeInput() {
  if (visibleCount > 3) {
    const inputToRemoveId = `input${visibleCount}`;
    Object.keys(phaseEmojiMaps).forEach(phaseId => {
      if (phaseEmojiMaps[phaseId][inputToRemoveId]) {
        delete phaseEmojiMaps[phaseId][inputToRemoveId];
      }
    });
    visibleCount--;
    saveState(); 
    updateInputVisibility();
    updateDiv1Visuals();
    attachFocusListeners(); 
  }
}
function updateInputVisibility() {
  for (let i = 1; i <= 8; i++) {
    const wrapper = document.getElementById(`wrapper-input${i}`);
    if (wrapper) {
      wrapper.style.display = i <= visibleCount ? 'inline-block' : 'none';
    }
  }
  [...document.querySelectorAll('.textarea-wrapper')]
    .filter(wr => wr.style.display!='none')
    .at(-1).appendChild(document.querySelector('#icon-container'))

  document.getElementById('addBtn').style.display = visibleCount === 8 ? 'none' : 'inline-block';
  document.getElementById('removeBtn').style.display = visibleCount === 3 ? 'none' : 'inline-block';
}

// --- 이모지 및 페이즈 모달 ---
function setupEmojiButtons() {
  const container = document.getElementById('emoji-buttons');
  container.innerHTML = '';
  emojiList.forEach(emoji => {
    const btn = document.createElement('button');
    btn.innerText = emoji;
    btn.onclick = () => toggleTempEmoji(emoji);
    container.appendChild(btn);
  });
}
function setupPhaseButtons() {
  const container = document.getElementById('phase-buttons');
  container.innerHTML = '';
  Object.keys(phaseConfig).forEach(phaseId => {
    const config = phaseConfig[phaseId];
    const btn = document.createElement('div');
    btn.className = `phase-button ${config.colorClass}`;
    btn.dataset.phaseId = phaseId;
    btn.innerText = config.name;
    btn.onclick = () => switchPhase(phaseId);
    container.appendChild(btn);
  });
  updatePhaseButtonStates();
}
function openEmojiModal(targetId) {
  currentEmojiTarget = targetId;
  const currentPhaseVotes = phaseEmojiMaps[currentActivePhase];
  tempEmojiSelection = [...(currentPhaseVotes[currentEmojiTarget] || [])];
  updateModalButtonStates();
  document.getElementById('emoji-modal').style.display = 'block';
  document.getElementById('modal-backdrop').style.display = 'block';
}
function switchPhase(phaseId) {
  currentActivePhase = phaseId;
  updatePhaseButtonStates();
  updateDiv1Visuals();
  if (document.getElementById('emoji-modal').style.display === 'block') {
    const currentPhaseVotes = phaseEmojiMaps[currentActivePhase];
    tempEmojiSelection = [...(currentPhaseVotes[currentEmojiTarget] || [])];
    updateModalButtonStates();
  }
  saveState(); 
}
function toggleTempEmoji(emoji) {
  const index = tempEmojiSelection.indexOf(emoji);
  if (index > -1) tempEmojiSelection.splice(index, 1);
  else tempEmojiSelection.push(emoji);
  updateModalButtonStates();
}
function updateModalButtonStates() {
  const buttons = document.querySelectorAll('#emoji-buttons button');
  const activePhaseColorClass = phaseConfig[currentActivePhase].emojiColorClass;

  buttons.forEach(btn => {
    Object.values(phaseConfig).forEach(config => {
      btn.classList.remove(config.emojiColorClass);
    });
    if (tempEmojiSelection.includes(btn.innerText)) {
      btn.classList.add('active');
      btn.classList.add(activePhaseColorClass);
    } else {
      btn.classList.remove('active');
    }
  });
}
function updatePhaseButtonStates() {
  const buttons = document.querySelectorAll('.phase-button');
  buttons.forEach(btn => {
    if (btn.dataset.phaseId === currentActivePhase) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}
function confirmEmojiSelection() {
  if (currentEmojiTarget) {
    phaseEmojiMaps[currentActivePhase][currentEmojiTarget] = [...tempEmojiSelection];
    updateDiv1Visuals();
    saveState(); 
  }
  closeEmojiModal();
}
function cancelEmojiSelection() { closeEmojiModal(); }
function closeEmojiModal() {
  document.getElementById('emoji-modal').style.display = 'none';
  document.getElementById('modal-backdrop').style.display = 'none';
  currentEmojiTarget = null;
}
function handleClearCurrentVote() {
  if (currentEmojiTarget) {
    phaseEmojiMaps[currentActivePhase][currentEmojiTarget] = [];
    updateDiv1Visuals();
    saveState();
    tempEmojiSelection = [];
    updateModalButtonStates();
  }
}
function handleResetAllVotes() {
  phaseEmojiMaps = { phase1: {}, phase2: {}, phase3: {}, phase4: {} }; 
  currentActivePhase = 'phase1';
  updateDiv1Visuals();
  updatePhaseButtonStates();
  saveState();
  if (document.getElementById('emoji-modal').style.display === 'block') {
    tempEmojiSelection = [];
    updateModalButtonStates();
  }
}

async function showHintModal() {
  const query = document.getElementById("singleInput").value.trim();
  if (!query) { alert("단어를 입력하세요."); return; }
  const keywords = query.split(',').map(w => w.trim()).filter(Boolean);
  if (!keywords.length) return;

  const snapshot = await get(ref(db, "liar_groups"));
  if (!snapshot.exists()) { alert("DB에 그룹이 없습니다."); return; }

  const data = snapshot.val();
  const matchingGroups = Object.values(data).filter(group =>
    group.words.some(word => keywords.includes(word))
  );

  const hintContent = document.getElementById("hint-content");
  hintContent.innerHTML = '';

  if (matchingGroups.length === 0) {
    hintContent.innerText = '❌ 관련된 단어 그룹이 없습니다.';
  } else {
    matchingGroups.forEach(group => {
      const wordsLine = `🧩 ${group.words.join(', ')}`;
      const summaryLines = (group.statements || []).map(stmt =>
        `${stmt.subject ? stmt.subject + ': ' : ''}` +
        `${stmt.opening ? stmt.opening + ' ㅡ ' : ''}` +
        `${stmt.elaborate1 ? stmt.elaborate1 + ' ' : ''}` +
        `${stmt.elaborate2 ? ' >> ' + stmt.elaborate2 + ' ' : ''}`
      );
      hintContent.innerText += `${wordsLine}\n\n${summaryLines.join('\n')}\n\n`;
    });
  }
  document.getElementById("hint-modal").style.display = 'block';
  document.getElementById("hint-backdrop").style.display = 'block';
}
function closeHintModal() {
  document.getElementById("hint-modal").style.display = 'none';
  document.getElementById("hint-backdrop").style.display = 'none';
}

// --- UI 업데이트 ---
function updateDiv1Visuals() {
  for (let i = 1; i <= 8; i++) {
    const inputId = `input${i}`;
    const overlay = document.getElementById(`emoji-overlay-${inputId}`);
    if (!overlay) continue;
    overlay.innerHTML = '';
    Object.keys(phaseConfig).forEach(phaseId => {
      const votesInPhase = phaseEmojiMaps[phaseId];
      if (votesInPhase[inputId] && votesInPhase[inputId].length > 0) {
        votesInPhase[inputId].forEach(voter => {
          const indicator = document.createElement('div');
          indicator.className = `vote-indicator ${phaseConfig[phaseId].colorClass}`;
          indicator.textContent = voter;
          overlay.appendChild(indicator);
        });
      }
    });
  }
}

// --- 데이터 처리 ---
function parseStatement(text) {
  const stmt = {};
  if (!text) return stmt;
  let remaining = text.trim();

  let parts = remaining.split('!!');
  if (parts.length > 1) {
    const author = parts.pop().trim();
    if (author) stmt.author = author;
    remaining = parts.join('!!').trim();
  }
  parts = remaining.split('//');
  if (parts.length > 1) {
    const respond = parts.pop().trim();
    if (respond) stmt.respond = respond;
    remaining = parts.join('//').trim();
  }
  parts = remaining.split('>>');
  if (parts.length > 1) {
    const elaborate2 = parts.pop().trim();
    if (elaborate2) stmt.elaborate2 = elaborate2;
    remaining = parts.join('>>').trim();
  }
  parts = remaining.split('ㅡ');
  if (parts.length > 1) {
    const elaborate1 = parts.pop().trim();
    if (elaborate1) stmt.elaborate1 = elaborate1;
    remaining = parts.join('ㅡ').trim();
  }
  parts = remaining.split(':');
  if (parts.length > 1) {
    const subject = parts.shift().trim();
    if (subject) stmt.subject = subject;
    const opening = parts.join(':').trim();
    if (opening) stmt.opening = opening;
  } else {
    const opening = remaining.trim();
    if (opening) stmt.opening = opening;
  }
  return stmt;
}
function getStmtSignature(stmt) {
  if (!stmt) return '';
  const parts = [stmt.subject, stmt.opening, stmt.elaborate1, stmt.elaborate2];
  return parts.join('').replace(/\s+/g, '');
}

// ▶ 추가(쓰기) 로직: 로그인 필요. 로그인은 onAuthStateChanged에 따라 버튼이 처리.
async function addSingle () {
  if (!auth.currentUser) {
    // 일반적으로 여기까지 오지 않지만, 상태 경합 대비
    try {
      await signInWithPopup(auth, provider);
    } catch (e) {
      alert('로그인이 필요합니다: ' + (e?.message || e));
      return;
    }
  }

  const singleVal = document.getElementById("singleInput").value.trim();
  const words = singleVal.split(',').map(w => w.trim().replace(/\s+/g, '')).filter(Boolean);
  if (!words.length) { alert("단어를 입력하세요."); return; }

  const newStatements = [];
  for (let i = 1; i <= visibleCount; i++) {
    const input = document.getElementById(`input${i}`);
    const rawText = input.value.trim();
    if (input && rawText) {
      const items = rawText.split(',').map(v => v.trim()).filter(Boolean);
      const parsedItems = items.map(parseStatement);
      newStatements.push(...parsedItems);
    }
  }

  const snapshot = await get(ref(db, "liar_groups"));
  const groupsData = snapshot.exists() ? snapshot.val() : {};

  const wordToGroup = {};
  const groupMap = {};

  Object.entries(groupsData).forEach(([groupId, group]) => {
    groupMap[groupId] = group;
    (group.words || []).forEach(word => {
      wordToGroup[word] = groupId;
    });
  });

  const matchedGroupIds = [...new Set(
    words.map(word => wordToGroup[word]).filter(Boolean)
  )];

  if (matchedGroupIds.length === 0) {
    const allIds = new Set(Object.keys(groupsData));
    let newGroupId = null;
    for (let i = 0; i <= 9999; i++) {
      const candidate = i.toString().padStart(4, '0');
      if (!allIds.has(candidate)) { newGroupId = candidate; break; }
    }
    if (!newGroupId) { alert("더 이상 생성 가능한 그룹이 없습니다."); return; }

    const latestTimestamp = Date.now();
    const newGroupData = {
      words: [...new Set(words)],
      statements: newStatements,
      timestamp: latestTimestamp
    };

    await set(ref(db, `liar_groups/${newGroupId}`), newGroupData);
    loadFromDB();
    return;
  }

  let mergedWords = [];
  let mergedStatements = [];
  matchedGroupIds.forEach(groupId => {
    const group = groupMap[groupId];
    mergedWords.push(...(group.words || []));
    mergedStatements.push(...(group.statements || []));
  });

  mergedWords.push(...words);
  mergedWords = [...new Set(mergedWords)];

  const existingSignatures = new Set(mergedStatements.map(getStmtSignature));
  const uniqueNewStatements = newStatements.filter(stmt => {
    const signature = getStmtSignature(stmt);
    return signature && !existingSignatures.has(signature);
  });
  mergedStatements.push(...uniqueNewStatements);

  const latestTimestamp = Date.now();
  const primaryGroupId = matchedGroupIds[0];

  const updates = {};
  updates[`liar_groups/${primaryGroupId}`] = {
    words: mergedWords,
    statements: mergedStatements,
    timestamp: latestTimestamp
  };
  matchedGroupIds.slice(1).forEach(groupId => { updates[`liar_groups/${groupId}`] = null; });

  await update(ref(db), updates);
  loadFromDB();
};

// 메인 화면 '비우기'
window.clearInputs = function () {
  for (let i = 1; i <= 8; i++) {
    const input = document.getElementById(`input${i}`);
    if (input) input.value = '';
  }
  document.getElementById("singleInput").value = '';

  phaseEmojiMaps = { phase1: {}, phase2: {}, phase3: {}, phase4: {} };
  currentActivePhase = 'phase1';
  updateDiv1Visuals();
  updatePhaseButtonStates();
  updateHighlights();
  localStorage.removeItem('상태백업');
};

window.loadFromDB = async function () {
  const output = document.getElementById("output");
  output.innerHTML = "불러오는 중...";
  try {
    const snapshot = await get(ref(db, "liar_groups"));
    output.innerHTML = "";
    if (snapshot.exists()) {
      const rawData = snapshot.val();
      const entries = Object.entries(rawData)
        .sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0));
      groupList = entries.map(entry => (entry[1].words || []));
      updateHighlights();
    } else {
      output.innerHTML = "🔥 데이터 없음";
    }
  } catch(e) {
    output.innerHTML = `❌ 불러오기 실패: ${e.message}`;
  }
};

function updateHighlights() {
  const value = document.getElementById("singleInput").value.trim();
  const keywords = value.split(',').map(v => v.trim()).filter(Boolean);
  renderGroups(keywords);
}
function renderGroups(highlightWords = []) {
  const output = document.getElementById("output");
  output.innerHTML = "";
  const highlighted = [], rest = [];
  for (const group of groupList) {
    const text = group.join(", ");
    const div = document.createElement("div");
    div.className = "group";
    div.innerText = text;
    div.onclick = () => {
      document.getElementById("singleInput").value = text;
      updateHighlights();
    };
    if (highlightWords.length > 0 && highlightWords.some(w => group.includes(w))) {
      div.classList.add("highlight");
      highlighted.push(div);
    } else rest.push(div);
  }
  [...highlighted, ...rest].forEach(div => output.appendChild(div));
}

// --- 로컬 스토리지 (Local Storage) ---
function saveState() {
  const data = {
    inputs: {},
    phaseMaps: phaseEmojiMaps,
    activePhase: currentActivePhase,
    visible: visibleCount
  };
  for (let i = 1; i <= 8; i++) {
    const input = document.getElementById(`input${i}`);
    if (input) data.inputs[`input${i}`] = input.value;
  }
  data.inputs['singleInput'] = document.getElementById('singleInput').value;
  localStorage.setItem('상태백업', JSON.stringify(data));
}
function restoreState() {
  const saved = localStorage.getItem('상태백업');
  if (!saved) return;
  try {
    const data = JSON.parse(saved);
    if (data.inputs) {
      for (let key in data.inputs) {
        const el = document.getElementById(key);
        if (el) el.value = data.inputs[key];
      }
    }
    if (data.phaseMaps) phaseEmojiMaps = data.phaseMaps;
    if (data.activePhase) currentActivePhase = data.activePhase;
    if (data.visible) visibleCount = data.visible;

    updateInputVisibility();
    updateDiv1Visuals();
    updatePhaseButtonStates();
    updateHighlights();
  } catch (e) {
    console.error("상태 복원 실패:", e);
    localStorage.removeItem('상태백업');
  }
}

// --- 이벤트 리스너 (Event Listeners) ---
function attachFocusListeners() {
  [..."13572468"]
    .map(id => document.querySelector(`#wrapper-input${id}`))
    .filter(wr => wr.style.display!='none')
    .map(wr => wr.querySelector("textarea"))
    .forEach((box, idx, arr) => {
      box.onkeydown = (e) => {
        if (e.key === "Enter" || e.key === "Tab") {
          e.preventDefault();
          if (e.target.id.startsWith("input")) {
            const currentValue = e.target.value.trim();
            if (currentValue !== '' && !currentValue.includes('ㅡ')) {
              e.target.value = e.target.value.trim() + ' ㅡ ';
            }
          }
          const next = arr[(idx + 1) % (arr.length)];
          next.focus();
        }
      };
    });
}
function attachInputListeners() {
  const ids = ["input1", "input2", "input3", "input4", "input5", "input6", "input7", "input8", "singleInput"];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', saveState);
  });
  document.getElementById("singleInput").addEventListener("input", updateHighlights);
}

// 전역 노출
window.addSingle = addSingle;
window.clearInputs = clearInputs;
window.loadFromDB = loadFromDB;
window.openEmojiModal = openEmojiModal;
window.addInput = addInput; 
window.removeInput = removeInput; 
window.handleClearCurrentVote = handleClearCurrentVote;
window.handleResetAllVotes = handleResetAllVotes;
window.showHintModal = showHintModal;
window.closeHintModal = closeHintModal;
</script>

</body>
</html>
