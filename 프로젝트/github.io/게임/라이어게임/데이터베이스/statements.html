<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ë‹¨ì–´ ê·¸ë£¹ ê´€ë¦¬ì</title>
  <link rel="stylesheet" href="statements.css">
  <style>
    .auth-area { display:flex; align-items:center; gap:8px; margin-left:8px; }
    .user-chip{
      display:flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid var(--chip, #ddd);
      font-size:12px;
    }
    .user-chip img{ width:20px; height:20px; border-radius:50%; }
    .hidden{ display:none !important; }
    .bottom-bar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>

<div class="bottom-bar">
  <button onclick="loadGroups()">ë¶ˆëŸ¬ì˜¤ê¸°</button>
  <button onclick="saveGroups()">ì €ì¥</button>
  <button onclick="backupToJson()">JSON ë°±ì—…</button>
  <select id="theme-selector" onchange="changeTheme(this.value)">
    <option value="light">ë¼ì´íŠ¸ í…Œë§ˆ</option>
    <option value="dark">ë‹¤í¬ í…Œë§ˆ</option>
    <option value="crimson">í¬ë¦¼ìŠ¨ í…Œë§ˆ</option>
    <option value="ocean">ì˜¤ì…˜ í…Œë§ˆ</option>
    <option value="forest">í¬ë ˆìŠ¤íŠ¸ í…Œë§ˆ</option>
  </select>
  <select id="sort-selector" onchange="changeSort(this.value)">
    <option value="timestamp">ìµœì‹ ìˆœ</option>
    <option value="length_desc">ë¶„ëŸ‰ ë§ì€ ìˆœ</option>
    <option value="length_asc">ë¶„ëŸ‰ ì ì€ ìˆœ</option>
  </select>

  <!-- â–¶ ê´€ë¦¬ì ë¡œê·¸ì¸ UI -->
  <div class="auth-area">
    <span id="auth-status" class="user-chip hidden">
      <img id="auth-photo" alt="í”„ë¡œí•„">
      <span id="auth-name"></span>
    </span>
    <button id="signin-btn">ê´€ë¦¬ì</button>
    <button id="signout-btn" class="hidden">ë¡œê·¸ì•„ì›ƒ</button>
  </div>
</div>

<div id="group-container"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
import { getDatabase, ref, get, set, remove } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";
import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";

const app = initializeApp({
  apiKey: "AIzaSyDVVAx9XRziu8IZ9CLczaG20QEOwyY4uLs",
  authDomain: "liarwords-af033.firebaseapp.com",
  databaseURL: "https://liarwords-af033-default-rtdb.firebaseio.com",
  projectId: "liarwords-af033",
  storageBucket: "liarwords-af033.appspot.com",
  messagingSenderId: "171671976030",
  appId: "1:171671976030:web:59371970ec6b2a70035ccf"
});
const db = getDatabase(app);

/* â–¶ Auth ì´ˆê¸°í™” */
const auth = getAuth(app);
const provider = new GoogleAuthProvider();

/* â–¶ ë¡œê·¸ì¸ UI ì°¸ì¡° */
const signinBtn = document.getElementById('signin-btn');
const signoutBtn = document.getElementById('signout-btn');
const authStatus = document.getElementById('auth-status');
const authName = document.getElementById('auth-name');
const authPhoto = document.getElementById('auth-photo');

/* â–¶ ë¡œê·¸ì¸/ë¡œê·¸ì•„ì›ƒ ë²„íŠ¼ í•¸ë“¤ëŸ¬ */
signinBtn.onclick = async () => {
  try {
    await signInWithPopup(auth, provider);
  } catch (e) {
    alert('ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + (e?.message || e));
    console.error(e);
  }
};
signoutBtn.onclick = async () => {
  try {
    await signOut(auth);
  } catch (e) {
    alert('ë¡œê·¸ì•„ì›ƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + (e?.message || e));
    console.error(e);
  }
};

/* â–¶ ë¡œê·¸ì¸ ìƒíƒœ ë³€í™”ì— ë”°ë¼ UI ê°±ì‹  */
onAuthStateChanged(auth, (user) => {
  if (user) {
    authStatus.classList.remove('hidden');
    signoutBtn.classList.remove('hidden');
    signinBtn.classList.add('hidden');

    authName.textContent = user.displayName || user.email || 'ë¡œê·¸ì¸ë¨';
    if (user.photoURL) {
      authPhoto.src = user.photoURL;
      authPhoto.classList.remove('hidden');
    } else {
      authPhoto.src = '';
      authPhoto.classList.add('hidden');
    }
  } else {
    authStatus.classList.add('hidden');
    signoutBtn.classList.add('hidden');
    signinBtn.classList.remove('hidden');
    authName.textContent = '';
    authPhoto.src = '';
  }
});

let groupData = {};
let modifiedItems = new Set();
let currentSortMethod = 'timestamp';

function formatStatement(stmt) {
  if (!stmt) return '';
  if (typeof stmt === 'string') return stmt;

  let text = '';
  if (stmt.subject) {
    text += stmt.subject;
    if (stmt.opening) text += ': ';
  }
  if (stmt.opening) text += stmt.opening;
  if (stmt.elaborate1) {
    if (text) text += ' ã…¡ ';
    text += stmt.elaborate1;
  }
  if (stmt.elaborate2) {
    if (text) text += ' >> ';
    text += stmt.elaborate2;
  }
  return text.trim();
}

function parseStatement(text) {
  const stmt = {};
  if (!text) return stmt;
  let remaining = text.trim();

  let parts = remaining.split(' >> ');
  if (parts.length > 1) {
    const elaborate2 = parts.pop().trim();
    if (elaborate2) stmt.elaborate2 = elaborate2;
    remaining = parts.join(' >> ').trim();
  }
  parts = remaining.split(' ã…¡ ');
  if (parts.length > 1) {
    const elaborate1 = parts.pop().trim();
    if (elaborate1) stmt.elaborate1 = elaborate1;
    remaining = parts.join(' ã…¡ ').trim();
  }
  parts = remaining.split(': ');
  if (parts.length > 1) {
    const subject = parts.shift().trim();
    if (subject) stmt.subject = subject;
    const opening = parts.join(': ').trim();
    if (opening) stmt.opening = opening;
  } else {
    const opening = remaining.trim();
    if (opening) stmt.opening = opening;
  }
  return stmt;
}

function toggleModified(isModified) {
  document.body.classList.toggle('modified', isModified);
}

/* â–¶ ë¡œê·¸ì¸ í™•ì¸(ë¹„ë°€ë²ˆí˜¸/ì„¸ì…˜ ìŠ¤í† ë¦¬ì§€ ì—†ì´) */
async function requireSignedIn() {
  if (auth.currentUser) return true;
  const doLogin = confirm("ì´ ì‘ì—…ì€ ë¡œê·¸ì¸í•œ ì‚¬ìš©ìë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì§€ê¸ˆ ê´€ë¦¬ì ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
  if (!doLogin) return false;
  try {
    await signInWithPopup(auth, provider);
    return !!auth.currentUser;
  } catch (e) {
    alert('ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + (e?.message || e));
    return false;
  }
}

window.loadGroups = async function(restoreScrollY = null) {
  const currentScrollY = window.scrollY;
  const container = document.getElementById('group-container');
  container.innerHTML = 'ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...';
  try {
    const snapshot = await get(ref(db, 'liar_groups'));
    container.innerHTML = '';
    if (snapshot.exists()) {
      groupData = snapshot.val();
      renderGroups();
    } else {
      container.innerHTML = 'ğŸ”¥ ë°ì´í„° ì—†ìŒ';
      groupData = {};
    }
    toggleModified(false);
    modifiedItems.clear();
  } catch(error) {
    console.error("ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", error);
    container.innerHTML = 'âŒ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨';
    toggleModified(false);
    modifiedItems.clear();
  }
  window.scrollTo(0, restoreScrollY !== null ? restoreScrollY : currentScrollY);
};

async function processAndSaveGroups() {
  const groupsToDelete = Object.entries(groupData)
    .filter(([groupId, data]) => !data.words || (Array.isArray(data.words) && data.words.filter(word => String(word).trim() !== '').length === 0));

  for (const [groupId] of groupsToDelete) {
    const groupRef = ref(db, `liar_groups/${groupId}`);
    try {
      await remove(groupRef);
      delete groupData[groupId];
    } catch (error) {
      console.error(`ê·¸ë£¹ "${groupId}" ì‚­ì œ ì‹¤íŒ¨:`, error);
      alert(`ê·¸ë£¹ "${groupId}" ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ê¶Œí•œ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
    }
  }

  try {
    await set(ref(db, 'liar_groups'), groupData);
    alert('ì €ì¥ ì™„ë£Œ');
    toggleModified(false);
    modifiedItems.clear();
    renderGroups();
  } catch (error) {
    console.error("ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:", error);
    alert("ë°ì´í„° ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ê¶Œí•œ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
  }
}

/* â–¶ ì €ì¥: ë¡œê·¸ì¸ í™•ì¸ í›„ ì§„í–‰ */
window.saveGroups = async function() {
  const ok = await requireSignedIn();
  if (!ok) return;
  await processAndSaveGroups();
};

window.backupToJson = async function() {
  try {
    const snapshot = await get(ref(db, 'liar_groups'));
    if (snapshot.exists()) {
      const data = snapshot.val();
      const jsonString = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const date = new Date();
      const timestamp = date.getFullYear().toString().slice(-2) + 
                        ('0' + (date.getMonth() + 1)).slice(-2) + 
                        ('0' + date.getDate()).slice(-2) + 
                        ('0' + date.getHours()).slice(-2) + 
                        ('0' + date.getMinutes()).slice(-2);
      a.download = `liar_groups_backup_${timestamp}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      alert('ë°±ì—… íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
    } else {
      alert('ë°±ì—…í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
    }
  } catch (error) {
    console.error("ë°±ì—… ì‹¤íŒ¨:", error);
    alert('ë°±ì—…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
  }
};

function renderGroups() {
  const container = document.getElementById('group-container');
  container.innerHTML = '';

  let sorted = Object.entries(groupData || {});
  sorted.sort((a, b) => {
    const [idA, dataA] = a;
    const [idB, dataB] = b;
    switch (currentSortMethod) {
      case 'length_desc': {
        const lengthA = (dataA.words || []).join('').length + (dataA.statements || []).map(s => JSON.stringify(s)).join('').length;
        const lengthB = (dataB.words || []).join('').length + (dataB.statements || []).map(s => JSON.stringify(s)).join('').length;
        return lengthB - lengthA;
      }
      case 'length_asc': {
        const lengthA = (dataA.words || []).join('').length + (dataA.statements || []).map(s => JSON.stringify(s)).join('').length;
        const lengthB = (dataB.words || []).join('').length + (dataB.statements || []).map(s => JSON.stringify(s)).join('').length;
        return lengthA - lengthB;
      }
      case 'timestamp':
      default:
        return (dataB.timestamp || 0) - (dataA.timestamp || 0);
    }
  });

  sorted.forEach(([groupId, data]) => {
    const div = document.createElement('div');
    div.className = 'group-card';
    const titleEl = createEditableList(groupId, data.words, 'words', true);
    titleEl.title = groupId;
    div.appendChild(titleEl);
    const statementList = createEditableList(groupId, data.statements || [], 'statements', false);
    div.appendChild(statementList);
    container.appendChild(div);
  });
}

function createEditableList(groupId, items, key, isTitle = false) {
  const container = document.createElement(isTitle ? 'div' : 'ul');
  container.className = isTitle ? 'group-title' : 'statement-list';
  const currentItems = [...(items || [])];
  currentItems.forEach((item, idx) => {
    const el = createItemElement(groupId, currentItems, idx, key, isTitle);
    container.appendChild(el);
  });
  const emptyEl = createItemElement(groupId, currentItems, currentItems.length, key, isTitle);
  container.appendChild(emptyEl);
  return container;
}

function createItemElement(groupId, items, idx, key, isTitle = false) {
  const wrapper = document.createElement(isTitle ? 'div' : 'li');
  wrapper.className = 'item-wrapper';
  
  const item = items[idx];
  const isStatement = key === 'statements';
  
  const displayText = isStatement ? formatStatement(item) : item;
  const originalText = (isStatement ? displayText : (item || '')) || '';

  const span = document.createElement('span');
  span.className = 'item-text';
  span.textContent = displayText || '...';

  if (isStatement && item && item.author) span.title = `ì‘ì„±ì: ${item.author}`;
  
  const itemId = `${groupId}-${key}-${idx}`;
  if (modifiedItems.has(itemId)) span.classList.add('modified-text');
  
  const del = document.createElement('span');
  del.className = 'delete-btn';
  del.textContent = 'âœ–';
  del.onclick = async (e) => {
    e.stopPropagation();
    if (!item) return;
    const ok = await requireSignedIn();
    if (!ok) return;
    items.splice(idx, 1);
    groupData[groupId][key] = [...items];
    modifiedItems.delete(itemId);
    toggleModified(true);
    renderGroups();
  };
  del.style.display = 'none';

  wrapper.onmouseenter = () => { if (item) del.style.display = 'inline'; };
  wrapper.onmouseleave = () => { del.style.display = 'none'; };
  
  wrapper.onclick = () => {
    if (wrapper.querySelector('.editable-textarea')) return;
    
    const input = document.createElement('textarea');
    input.className = 'editable-textarea';
    input.value = originalText;
    input.onclick = (e) => e.stopPropagation();
    
    input.onkeydown = (e) => {
      if (e.key === 'Escape') {
        e.target.dataset.escapePressed = 'true';
        e.preventDefault();
        input.blur();
      }
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      }
    };
    
    input.onblur = () => {
      if (input.dataset.escapePressed !== 'true') {
        const newText = input.value.trim();
        const itemId = `${groupId}-${key}-${idx}`;
        let hasChanged = false;

        if (newText !== originalText) {
          hasChanged = true;
          if (newText) {
            items[idx] = isStatement ? parseStatement(newText) : newText;
            modifiedItems.add(itemId);
          } else {
            items.splice(idx, 1);
            modifiedItems.delete(itemId);
          }
        } else {
          if (modifiedItems.has(itemId)) {
            hasChanged = true;
            modifiedItems.delete(itemId);
          }
        }
        if (hasChanged) groupData[groupId][key] = [...items];
      }
      toggleModified(modifiedItems.size > 0);
      renderGroups();
    };

    wrapper.appendChild(input);
    input.focus();
    input.select();
  };

  wrapper.appendChild(span);
  wrapper.appendChild(del);
  return wrapper;
}

window.changeTheme = function(themeName) {
  document.body.dataset.theme = themeName;
  localStorage.setItem('theme', themeName);
}

window.changeSort = function(sortMethod) {
  currentSortMethod = sortMethod;
  localStorage.setItem('sortMethod', sortMethod);
  renderGroups();
}

function applyInitialSettings() {
  const savedTheme = localStorage.getItem('theme') || 'light';
  document.body.dataset.theme = savedTheme;
  document.getElementById('theme-selector').value = savedTheme;

  const savedSortMethod = localStorage.getItem('sortMethod') || 'timestamp';
  currentSortMethod = savedSortMethod;
  document.getElementById('sort-selector').value = savedSortMethod;
}

window.addEventListener('load', () => {
  applyInitialSettings();
  const savedScrollY = sessionStorage.getItem('scrollPosition');
  loadGroups(savedScrollY ? parseInt(savedScrollY, 10) : null);
});

window.addEventListener('beforeunload', () => {
  sessionStorage.setItem('scrollPosition', window.scrollY);
});
</script>

</body>
</html>
