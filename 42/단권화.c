#include <stdio.h>
#include <unistd.h>
//!  가이드
//: 확장(컨쉬X)		 폴더(컨쉬E)		노미(옵쉬F)			접기(컨K0)			헤더(컨옵H)		설정(컨,)
//: 🔴미해결		🌸평가필요		   ❌문제발생		 ❗️컴파일에러		✅기계통과
//: setting.json(알쉬,)

//!  SH00
///: z					--- 00 cat으로 접근시 Z를 출력하는 파일 (새 줄이 뒤따름)
///		⁡⁢⁢⁢echo는 터미널에 문자열을 출력해 줌.⁡
///			⁡⁢⁣⁣echo "Z"			터미널에 문자열 Z 출력⁡
///			⁡⁢⁢⁣Z⁡
///		⁡⁢⁢⁢이러한 출력 결과는 부등호 > 기호를 이용해서 파일에 저장할 수 있음⁡
///⁡⁢⁢⁣			echo "Z"  > z		Z라는 값을 z라는 파일에 덮어쓰기⁡
///			⁡⁢⁢⁣echo "Z" >> z		Z라는 값을 z라는 파일에 이어쓰기⁡
///		⁡⁢⁢⁢cat 명령어를 사용하면, 파일의 내용을 확인할 수 있음.⁡
///			⁡⁢⁣⁣cat z⁡
///			⁡⁢⁢⁣Z⁡
///		⁡⁢⁢⁢Z 이후에 새 줄이 뒤따른다고 하였음. 이것은 Z 문자 이후에 개행 문자 \n 를 넣으라는 의미.⁡
///		⁡⁢⁢⁢echo는 자체적으로 문자열에 \n을 추가해주므로 "Z" 까지만 입력해도 '새 줄' 을 만들 수 있음⁡.
///		⁡⁢⁢⁢-e 옵션을 사용하면, 개행 문자가 제대로 붙어있는지 확인할 수 있음.⁡
///			⁡⁢⁡⁢⁣⁣cat -e z⁡
///			⁡⁢⁢⁣Z$⁡
///
//:  testShell00.tar	--- 01 파일의 [접근 권한, 바이트, 날짜, 이름] 설정하고 압축하기
//		⁡⁢⁢⁢⁡⁢⁢⁢ls -l 명령어로 파일 정보를 확인할 수 있음⁡
//		⁡⁢⁢⁢-r--r-xr-x 1 XX XX 40 Jun 1 23:42 testShell00⁡
//
//:  과제의 요구사항
//		⁡⁢⁣⁢파일유형⁡	⁡⁢⁣⁣권한 비트⁡			⁡⁣⁢⁣하드링크	유저	그룹⁡		⁡⁢⁢⁢바이트⁡		⁡⁣⁢⁢날짜⁡			⁡⁢⁢⁣파일명⁡
//		⁡⁢⁣⁢일반⁡		⁡⁢⁣⁣r--  r-x  r-x⁡		⁡⁣⁢⁣1개			무관	무관⁡		⁡⁢⁢⁢40⁡			⁡⁣⁢⁢Jun 1 23:42	⁡	⁡⁢⁢⁣testShell00⁡
//		⁡⁢⁣⁢-⁡⁢⁣⁣r--r-xr-x⁡ ⁡⁣⁣⁢⁡⁣⁢⁣1⁡⁡ ⁡⁣⁢⁣XX⁡ ⁡⁣⁢⁣XX⁡ ⁡⁢⁢⁢40⁡ ⁡⁣⁢⁢Jun 1 23:42⁡ ⁡⁣⁢⁣⁡⁢⁢⁣testShell00⁡⁡
//
//:  파일의 유형 [-]
//		⁡⁣⁢⁣⁡⁢⁣⁢-⁡⁣⁢⁣r--r-xr-x 1 XX XX 40 Jun 1 23:42 testShell00⁡
//		⁡⁢⁣⁢맨 앞의 한글자⁡⁢⁢⁢는 파일의 유형에 해당함⁡
//		⁡⁢⁢⁢맨 앞이 ⁡⁢⁣⁢d ⁡⁡⁢⁢⁢라면 디렉토리를 의미함⁡
//		⁡⁢⁢⁢맨 앞이 ⁡⁢⁣⁢-⁡ ⁡⁢⁢⁢라면 평범하게 일반 파일을 의미함. 아무 파일이나 만들면 됨⁡
//
//:  파일의 용량 [40], 파일의 이름 [testShell00]
//		⁡⁣⁢⁣-r--r-xr-x 1 XX XX ⁡⁢⁣⁢40⁡⁡⁣⁢⁣ Jun 1 23:42 ⁡⁢⁣⁢testShell00⁡⁡
//		⁡⁢⁢⁢echo 명령어를 사용하면, 문자열을 가지고서 손쉽게 파일을 만들 수 있음⁡
//			⁡⁡⁢⁢⁣echo "문자열" > 파일명⁡
//		⁡⁢⁢⁢문자 하나는 1바이트이고, echo로 만든 문자열에는 개행 문자 '\n' 하나가 자동으로 따라붙는다.⁡
//		⁡⁢⁢⁢echo 명령어에 39개의 아무 문자열를 기입하여 파일을 만들면, 39+1 = 40바이트짜리 파일이 된다.⁡
//			⁡⁢⁢⁣echo "123456789012345678901234567890123456789" > testShell00⁡
//		⁡⁢⁢⁢echo로 만든 문자열에 개행 문자가 따라 붙지 않으려면 -n 옵션을 추가한다.⁡
//			⁡⁢⁢⁣echo -n "1234567890123456789012345678901234567890" > testShell00⁡
//
//:  파일의 시간 [Jun 1 23:42]
//		⁡⁣⁢⁣-r--r-xr-x 1 XX XX 40 ⁡⁣⁢⁢Jun 1 23:42⁡⁡⁣⁢⁣ testShell00⁡
//		⁡⁢⁢⁢touch 명령어를 사용하면, 파일의 수정 시간이 현재 시간으로 갱신됨⁡
//			⁡⁢⁢⁣touch 파일명⁡
//		⁡⁢⁢⁢touch 명령어의 -t 옵션을 사용하면, 파일의 수정 시간을 강제로 변경할 수 있음⁡
//			⁡⁢⁢⁣touch -t [yyyy][dddd][hhmm] 파일명⁡
//		⁡⁢⁢⁢2023년 june월 1일 23시 42분으로 변경하려면 다음과 같이 입력함⁡
//			⁡⁢⁢⁣touch -t 202306012342 testShell00⁡
//
//:  파일의 권한 [r-- r-x r-x]
//		⁡⁢⁢⁢파일에 접근하는 방식에는 ⁡⁢⁣⁣read / write / exec⁡⁡⁢⁢⁢ 이라는 세 가지 방식이 있음.⁡⁡
//		⁡⁢⁢⁢파일에 접근하는 각 방식이 허용되는지의 여부를 '예/아니오' 로 정해줄 수 있음.⁡
//
//		⁡⁢⁢⁢읽기가 가능하고, 쓰기가 가능하고, 실행이 불가능하다면 ⁡⁢⁣⁣r=1, w=1, x=0⁡⁡⁢⁢⁢ 으로 표현할 수 있음.⁡⁡
//		⁡⁣⁣⁢자릿수에 의미를 부여한다면⁡⁡⁢⁢⁢ 세자리의 비트를 응용해서 ⁡⁢⁣⁣110⁡ ⁡⁢⁢⁢처럼 축약해서 표현할 수 있음.⁡⁡
//		⁡⁣⁣⁢자릿수의 의미를 드러내려면⁡⁡⁢⁢⁢ 1대신에 ⁡⁢⁣⁣r/w/x⁡ ⁡⁢⁢⁢을 쓰고, 0대신에⁡ ⁡⁢⁣⁣-(묵음)⁡⁡⁢⁢⁢ 을 쓰는 방법을 생각할 수 있음.⁡⁡
//		⁡⁢⁢⁢읽기가 가능하고, 쓰기가 가능하고, 실행이 불가능하다면⁡ ⁡⁢⁣⁣rw-⁡ ⁡⁢⁢⁢처럼 표현할 수 있음⁡.
//		⁡⁢⁢⁢여기서 ⁡⁢⁣⁣rw-⁡⁡⁢⁢⁢ 는 알파벳처럼 보이지만 ⁡⁢⁣⁣110⁡⁡⁢⁢⁢ 이라는 2진법과 동일한 표현임.⁡
//			⁡⁣⁣⁢권한의 표현						권한⁡
//			⁡⁣⁢⁣자연어							읽기 가능, 쓰기 가능, 실행 불가능⁡
//			⁡⁣⁢⁣변수							r=1, w=1, x=0⁡
//			⁡⁣⁢⁣자리에 의미를 부여한 2진수		110⁡
//			⁡⁣⁢⁣자리의 의미를 드러낸 2진수		rw-⁡
//			⁡⁣⁢⁣의미가 부여된 10진수			6⁡
//
//		⁢⁢⁢그런데, 파일에 접근하는 방식만이 아니라, 파일에 접근하는 주체도 (접근자) 여러 종류가 있어서,⁡
//		⁡⁢⁢⁢접근자의 유형별로 '예/아니오' 를 또다시 매겨야함. 접근자의 유형은 3종류로 보고 있음.⁡
//			⁡⁣⁣⁢접근자 유형:	유저, 그룹, 기타⁡
//			⁡⁣⁣⁢접근의 방식:	읽기, 쓰기, 실행⁡
//
//		⁡⁡⁢⁢⁢그리하여,⁡ ⁢⁡⁢⁢⁢권한비트는 총 ⁡⁡⁢⁣⁣아홉 비트⁡⁡⁢⁢⁢가 되었고, 접근자마다 차별적으로 접근 ⁡⁢⁢⁢권한을 부여하게 되었음.⁡
//		⁡⁢⁢⁢읽기를 허용하려면 r, 쓰기를 허용하려면 w, 실행을 허용하려면 x를 부여함. 즉, 1을 부여하는 것임.⁡
//					⁡⁣⁣⁢읽기	쓰기	실행⁡
//			⁡⁣⁣⁢유저	⁡⁣⁢⁣r/-		w/-		x/-⁡
//			⁡⁣⁣⁢⁡⁣⁣⁢그룹	⁡⁣⁢⁣r/-		w/-		x/-⁡
//			⁡⁣⁣⁢기타	⁡⁣⁢⁣r/-		w/-		x/-⁡
//
//		⁡⁢⁢⁢과제의 요구 사항을 확인해보면⁡
//		⁡⁡⁣⁢⁣- ⁡⁢⁣⁣r-- r-x r-x⁡ ⁡⁣⁢⁣1 XX XX 40 Jun 1 23:42 testShell00⁡
//			⁡⁢⁣⁣⁡⁣⁣⁢유저에게는 ⁡⁢⁣⁣r--⁡⁣⁣⁢ 권한을 부여해야함. ⁡⁣⁢⁣(100 == 읽기1 쓰기0 실행0)⁡
//			⁡⁡⁣⁣⁢그룹에게는 ⁡⁢⁣⁣r-x⁡⁡⁣⁣⁢ 권한을 부여해야함.⁡ ⁡⁣⁢⁣(101 == 읽기1 쓰기0 실행1)⁡
//			⁡⁢⁣⁣⁡⁣⁣⁢기타에게는 ⁡⁣⁣⁢⁡⁢⁣⁣r-x⁡⁣⁣⁢ 권한을 부여해야함. ⁡⁡⁣⁢⁣(101 == 읽기1 쓰기0 실행1)⁡
//		
//		⁡⁡⁢⁢⁢chmod 명령어를 사용하면 ⁡⁢⁣⁣권한 비트⁡⁡⁢⁢⁢를 수정할 수 있음⁡ ⁡⁣⁢⁣(100 101 101)⁡
//		⁡⁢⁢⁢접근자 ( U유저 / G그룹 / O기타 ) 유형마다, 0~7 까지 숫자를 기입해서 '읽기 / 쓰기 / 실행' 권한을 부여함.⁡
//			⁡⁢⁢⁣chmod  [U][G][O] testShell00⁡
//
//		⁡⁢⁢⁢지금까지 비트를 이야기를 했는데 갑자기 0~7 이라는 숫자가 등장하는 것은,⁡
//		⁡⁢⁢⁢다음의 표처럼 2진수를 10진수 표기로 대체했더니 0~7 이라는 숫자가 된 것⁡
//			⁡⁣⁣⁢10진수		2진수	권한비트⁡ ⁡⁣⁣⁢(파일 접근 방식)⁡
//			⁡⁣⁢⁣0			000		- - -⁡
//			⁡⁣⁢⁣1			001		- - x⁡
//			⁡⁣⁢⁣2			010		- w -⁡
//			⁡⁣⁢⁣3			011		- w x⁡
//			⁡⁢⁣⁣4			100		r - -⁡
//			⁡⁢⁣⁣5			101		r - x⁡
//			⁡⁣⁢⁣6			110		r w -⁡
//			⁡⁣⁢⁣7			111		r w x⁡
//		⁡⁢⁢⁢표에서 ⁡⁢⁣⁣(r--)(r-x)(r-x)⁡⁡⁢⁢⁢ 에 해당하는 십진법 표기를 찾아보면 각각 4, 5, 5 이므로⁡
//		⁡⁢⁢⁢다음을 입력하면 파일의 권한이 최종적으로 결정됨⁡
//			⁡⁢⁢⁣chmod 455 testShell00⁡
//
//:  과제 파일 압축하기
//		⁡⁢⁢⁢tar 명령어와 -c 옵션을 사용하면, 파일을 압축할 수 있음. -f 옵션은 압축파일명을 무엇으로 할지 정할 수 있음.⁡
//			⁡⁢⁢⁣tar -cf⁡ ⁡⁣⁢⁢압축파일명⁡	⁡⁢⁢⁣	압축대상(들)⁡
//			⁡⁢⁢⁣tar -cf⁡ ⁡⁣⁢⁢testShell00.tar⁡	⁡⁢⁢⁣testShell00⁡
//
///: exo2.tar			--- 02 파일의 [접근 권한, 바이트, 날짜, 이름, 링크] 설정하고 압축하기
///:  과제의 요구사항
///		⁡⁢⁣⁢파일유형⁡⁡⁡⁡	⁡⁢⁣⁣권한 비트⁡	⁡⁣⁢⁡⁣⁣⁢하드링크⁡	⁡⁣⁢⁣유저⁡	⁡⁣⁢⁣그룹⁡	⁡⁢⁢⁢바이트⁡		⁡⁣⁢⁢날짜	⁡⁢⁢⁣파일명⁡⁡
///		⁡⁢⁣⁢d⁡ ⁡⁢⁣⁣rwx--xr-x⁡ ⁡⁣⁣⁢2⁡ ⁡⁣⁢⁣XX XX⁡ ⁡⁢⁢⁢XX⁡ ⁡⁣⁢⁢Jun 1 20:47⁡ ⁡⁣⁢⁡⁢⁢⁣test0⁡⁡
///		⁡⁢⁣⁢-⁡ ⁡⁢⁣⁣rwx--xr--⁡ ⁡⁣⁣⁢1⁡ ⁡⁣⁢⁣XX XX⁡ ⁡⁢⁢⁢4⁡  ⁡⁣⁢⁢Jun 1 21:46⁡ ⁡⁢⁢⁣test1⁡
///		⁡⁢⁣⁢d⁡ ⁡⁢⁣⁣r-x---r--⁡ ⁡⁣⁣⁢2⁡ ⁡⁣⁢⁣XX XX⁡ ⁡⁢⁢⁢XX⁡ ⁡⁣⁢⁢Jun 1 22:45⁡ ⁡⁢⁢⁣test2⁡
///		⁡⁢⁣⁢-⁡ ⁡⁢⁣⁣r-----r--⁡ ⁡⁣⁣⁢2⁡ ⁡⁣⁢⁣XX XX⁡ ⁡⁢⁢⁢1⁡  ⁡⁣⁢⁢Jun 1 23:44⁡ ⁡⁢⁢⁣test3⁡
///		⁡⁢⁣⁢-⁡ ⁡⁢⁣⁣rw-r----x⁡ ⁡⁣⁣⁢1⁡ ⁡⁣⁢⁣XX XX⁡ ⁡⁢⁢⁢2⁡  ⁡⁣⁢⁢Jun 1 23:43⁡ ⁡⁢⁢⁣test4⁡
///		⁡⁢⁣⁢-⁡ ⁡⁢⁣⁣r-----r--⁡ ⁡⁣⁣⁢2⁡ ⁡⁣⁢⁣XX XX⁡ ⁡⁢⁢⁢1⁡  ⁡⁣⁢⁢Jun 1 23:44⁡ ⁡⁢⁢⁣test5⁡
///		⁡⁢⁣⁢l⁡ ⁡⁢⁣⁣rwxrwxrwx⁡ ⁡⁣⁣⁢1⁡ ⁡⁣⁢⁣XX XX⁡ ⁡⁢⁢⁢5⁡  ⁡⁣⁢⁢Jun 1 22:20⁡ ⁡⁢⁢⁣test6 -> test0⁡
///
///:	파일의 권한, 용량, 날짜, 이름
///		⁡⁢⁢⁢이전 과제에서 실습한대로, 파일 권한/용량/날짜/이름을 부여함⁡
///			⁡⁣⁢⁣mkdir			⁡⁢⁢⁣test0⁡⁡⁢⁣⁢		디렉토리d⁡
///			⁡⁣⁢⁣echo -n "1234"	⁡⁡⁢⁢⁣test1		⁡⁡⁢⁢⁢4바이트⁡
///			⁡⁣⁢⁣mkdir			⁡⁡⁢⁢⁣test2		⁡⁡⁢⁣⁢디렉토리d⁡
///			⁡⁣⁢⁣echo -n "1"		⁡⁡⁢⁢⁣test3		⁡⁡⁢⁢⁢1바이트⁡
///			⁡⁣⁢⁣echo -n "12"	⁡⁡⁢⁢⁣test4		⁡⁡⁢⁢⁢2바이트⁡
///		
///:	링크란?
///		⁡⁢⁢⁢원본 파일을 ⁡⁢⁣⁢복제⁡⁡⁢⁢⁢하지 않아도 해당 파일을 여러 디렉토리에서 사용하고 싶을때 바로가기를 만든다.⁡
///		⁡⁢⁢⁢바로가기는 '하드링크'와 '심볼릭링크' 두 가지 방식이 있다.⁡
///
///:	하드링크 (분신/가명)
///		⁡⁢⁢⁢분신 중에 누구를 건드려도 모든 분신이 일제히 영향받는 가명 생성.⁡
///		⁡⁢⁢⁢하드링크는 동일한 대상을 일컫는 여러 개의 이름이다. 물리적으로는 하나의 본체만 존재한다.⁡
///		⁡⁢⁢⁢⁡⁢⁢⁢이름만 다르고 파일의 [권한, 바이트(텍스트 내용), 날짜] 를 공유한다.⁡
///			⁡⁢⁢⁣keunykim과 김근용은 이름만 다를 뿐이지 동일인이다.⁡
///			⁡⁢⁢⁣keunykim과 김근용의 생년월일은 같다. 사는 곳도 동일하다.⁡
///			⁡⁢⁢⁣keunykim을 때리면 김근용이 아프고, 김근용을 때리면 keunykim이 아프다.⁡
///			⁡⁢⁢⁣keunykim이 먹으면 김근용이 살찌고, 김근용이 먹으면 keunykim이 살찐다.⁡
///		⁡⁢⁢⁢파일정보 ls -l 에서 확인할 수 있는 ‘⁡⁣⁣⁢하드링크 수⁡⁡⁢⁢⁢’ 는 분신의 갯수를 의미한다⁡
///		⁡⁢⁢⁢⁡⁢⁢⁢ln 명령어를 실행해서, test5라는 분신을 생성한다.⁡
///			⁡⁢⁢⁣ln test3 test5⁡
///		⁡⁢⁢⁢test5가 나중에 만들어졌음에도 불구하고, 둘 중에서 누가 진짜인지 구별할 수 없다.⁡
///		⁡⁢⁢⁢하나의 진짜를 가리키는 2개의 분신일 뿐이다.⁡
///		⁡⁢⁢⁢파일의 DNA 같은 고유한 값을 대변하는 inode라는 변수가 있다.  ls -i 옵션으로 볼 수 있다.⁡
///			⁡⁢⁢⁣ls -i⁡
///		⁡⁢⁢⁢하드링크 명령어로 생성된 분신은 서로 똑같은 inode를 공유한다. 여기서 inode가 바로 본체이다.⁡
///
///:	심볼릭링크 (사생팬)
///		⁡⁢⁢⁢본인이 그 파일은 아니지만, 해당 파일로 연결해주는 또다른 파일 생성.⁡ ⁡⁢⁢⁢물리적으로 다른 파일.⁡
///		⁡⁡⁢⁢⁢심볼릭링크는 특정한 대상에게 접근하는 사생팬이다. 두 개의 서로 다른 인격체이며, 물리적으로 다른 공간에 거주한다.⁡
///		⁡⁢⁢⁢파일의 이름, 권한, 바이트, 날짜가 모두 다르다.⁡
///			⁡⁢⁢⁣밤이되면 연예인은 숙소에 들어가고, 사생팬은 본인 집으로 들어간다.⁡
///			⁡⁢⁢⁣연예인과 사생팬은 태어난 날짜도 다르고, 하는 일도 다르고, 사는 곳도 다르다.⁡
///			⁡⁢⁢⁣연예인이 밥을 먹는다고 사생팬이 살찌지 않는다.⁡
///			⁡⁢⁢⁣사생팬의 신변에 변화가 생겨도, 연예인은 변하지 않는다.⁡
///			⁡⁢⁢⁣연예인의 신변에 변화가 생겨도, 사생팬 그 자체는 변하지 않는다. 대신에 사생팬은 연예인의 소식을 커뮤에 널리널리 알려서 연예인을 대변한다⁡
///		⁡⁢⁢⁢ln 명령어에 -s (symbolic link) 옵션을 추가해서, test6라는 사생팬을 생성한다.⁡
///			⁡⁢⁢⁣ln -s 연예인 사생팬⁡
///			⁡⁢⁢⁣ln -s test0 test6⁡
///		⁡⁢⁢⁢둘 중에서 누가 진짜인지 구별할 수 있다. test0 이 원본이고, 원본을 스토킹하는 test6이 존재한다⁡
///		⁡⁢⁢⁢inode를 확인하면 연예인과 사생팬의 DNA가 다름을 알 수 있다.⁡
///			⁡⁢⁢⁣ls -i⁡
///		⁡⁢⁢⁢심볼릭링크는 자신의 고유한 내용을 가지지 않고, 원본 파일에 대한 참조 정보만을 가지고 있다. 그래서 바이트가 짧다. (자아의탁 ?!)⁡
///		⁡⁢⁢⁢비유를 위해서 나쁜 밈을 사용하였을 뿐이고 실제로는 사생팬을 싫어하지 않는다.⁡
///
///:  파일의 유형 [d l -]
///		⁡⁢⁢⁢과제에서 요구하는 파일의 유형은 세가지가 있다⁡
///			⁡⁣⁢⁣기호		파일의 유형⁡
///			⁡⁢⁣⁣-			일반파일 (하드링크가 존재한다는 이유로 변하지 않았음)⁡
///			⁡⁢⁣⁣d			디렉토리⁡
///			⁡⁢⁣⁣l 			심볼릭링크⁡
///		⁡⁢⁢⁢하드링크를 가진다고 파일의 성질이 변하는 것은 아닌 것인지 [ - ] 일반 유형임을 알 수 있고⁡
///		⁡⁢⁢⁢디렉토리는 철자에서 따온 [ d ] 유형임을 알 수 있고⁡
///		⁡⁢⁢⁢심볼릭링크는 본인의 정체성이 없이 링크라는 특수한 목적으로만 사용되므로 [ l ] 이라는 기호로 구별한다⁡
///		⁡⁢⁢⁢심볼릭링크의 짧은 바이트는 그러한 목적을 위해서 사용되었다 ⁡⁣⁢⁣(윈도우의 바로가기를 생각해보면, 원본 파일보다 바로가기의 용량이 상당히 작다)⁡
///
///:  파일의 권한
///		⁡⁢⁢⁢'사생팬과 연예인의 구별' 에도 불구하고, 심볼릭 링크의 속성을 변경하면 원본(연예인) 파일의 속성이 변경될 수 있는데,⁡
///			⁡⁢⁢⁣touch -t 06012220 test6 -h⁡
///		⁡⁢⁢⁢처럼 -h 옵션을 추가하면 사생팬이 가리키는 연예인이 아니라 사생팬 그 자체의 속성이 바뀐다⁡
///
///:  과제 파일 압축하기/압축풀기
///		⁡⁢⁢⁢파일이 깃에서 오르내리다보면 권한/날짜 같은 속성이 변경되기도 하는데, 이것을 방지하는 목적에서도 파일 압축이 사용됨⁡
///		⁡⁢⁢⁢tar 명령어를 사용하여 파일을 압축하거나 해제할 수 있음⁡
///		⁡⁣⁢⁣	tar 옵션	기능⁡
///⁡⁢⁣⁣			-c			압축하기⁡
///⁡⁢⁣⁣			-x			압축해제⁡
///⁡⁢⁣⁣			-f			아카이브 (저장고) 파일 지정⁡
///⁡⁢⁣⁣			-v			압축되거나 해제된 파일 내역 안내⁡
///⁡⁢⁢⁢		tar -c 는 '압축저장고' 와 '압축대상' 이라는 두 종류의 목적어를 요구함 (직접 목적어와 간접 목적어??)
///⁡⁢⁢⁢		압축대상은 하나하나 열거해도 되고, *와일드 카드*를 이용해서 한번에 여러개를 지정할수도 있음.⁡
///			⁡⁢⁢⁣tar  -cvf  <저장고>  <압축대상>⁡
///			⁡⁢⁢⁣tar  -cvf  exo2.tar  test0 test1 test2 ....⁡
///			⁡⁢⁢⁣tar  -cvf  exo2.tar  *⁡
///		⁡⁢⁢⁢압축하거나 해제하면, 기존에 설정한 것과는 다르게 파일 권한이 저절로 변경되기도 함.⁡
///		⁡⁢⁢⁢압축하거나 해제할때 -p 옵션을 추가하면 파일의 권한이 보존된 상태로 압축 해제가 가능⁡
///			⁡⁢⁣⁣-p			압축 및 해제시 권한 정보 유지⁡
///
//:  id_rsa_pub			--- 03 공개키를 인트라넷에 연동하고, push 하기
//: SSH키 만들기
//		⁡⁣⁢⁢조사를 열심히 했지만, 사이트마다 하는 말들이 다 다르고, 오개념도 섞여있어서 엄밀하게 이해하지 못하였음.⁡
//
//		⁡⁢⁢⁢하드웨어에 저장된 개인 정보를 이용해서, 서버와 데이터를 주고 받을 수 있는 'SSH' 라는 통신 방법이 있다⁡
//		⁡⁢⁢⁢비유하자면, 서버에 접속하기 위한 아이디와 비밀번호를 머리로 기억하고 입력하는게 아니라 하드웨어에 저장하는 방식이다.⁡
//		⁡⁢⁢⁢서버에 접속하기 위해서 매번 아이디와 비밀번호를 입력할 필요가 없고, 비밀번호보다 보안 수준이 높다.⁡
//		
//		⁡⁢⁢⁢ssh-keygen 명령어를 사용하면, 현재 사용중인 장치에다가 사용자의 개인정보가 만들어진다.⁡
//		⁡⁢⁢⁢id_rsa 라는 개인키와 id_rsa.pub 이라는 공개키가 만들어져서 ~/.ssh 폴더에 보관된다.⁡
//		⁡⁢⁢⁢공개와와 개인키는 한 쌍으로서, 어느 한 쪽의 주인이라면 반드시 다른 한 쪽의 주인이 된다.⁡
//
//		⁡⁢⁢⁢클라이언트가 서버에 접속을 요청한다. 서버는 클라이언트에게 도전 메시지를 보낸다.⁡
//		⁡⁢⁢⁢이러한 도전 메시지는 클라이언트에 차별적으로 전송되는 것이 아니다.⁡
//		⁡⁢⁢⁢동일한 도전 메시지에도 클라이언트마다 다른 대답을 내놓는다. 이러한 대답을 서명이라고 한다.⁡
//
//		⁡⁢⁢⁢개인키를 기반으로 클라이언트가 서명을 만들어서 서버에 전송한다.⁡
//		⁡⁢⁢⁢서버는 제출된 서명을 보고, 이 서명이 "무슨 공개키에서만 나올 수 있는 대답인지" 확인한다.⁡
//
//		⁡⁢⁢⁢서버가 클라이언트에게 모호한 그림을 보내본다. 클라이언트는 "꽥꽥" 이나 "깡총" 이라고 응답한다.⁡
//		⁡⁢⁢⁢이 그림을 두고 "꽥꽥" 이라고 말하게끔 설계된 공개키는 "오리" 밖에 없어서, 오리 집사의 접속이 허용된다.⁡
//		⁡⁢⁢⁢이 그림을 두고 "깡총" 이라고 말하도록 설계된 공개키는 "토끼" 밖에 없어서, 토끼 집의의 접속이 허용된다.⁡
//
//: 두 개의 파일 중에 무엇을 제출해야 하는지 (공개키)
//		⁡⁢⁢⁢id_rsa		파일은, cat 명령어로 확인하면 개인 키임을 안내하고 있음⁡
//		⁡⁢⁢⁢id_rsa.pub	파일은, 확장자가 public의 줄임말로서 공개 키임을 안내하고 있음⁡
//
//		⁡⁢⁢⁣cd  ~/.ssh							키 파일이 생성된 폴더에 방문⁡
//		⁡⁢⁢⁣cat  id_rsa.pub						공개키를 확인하고 인트라넷 설정칸에 복붙하였음⁡
//		⁡⁢⁢⁣cp  id_rsa.pub  id_rsa_pub			확장자가 없는 파일명으로 공개키를 복제하였음⁡
//		⁡⁢⁢⁣mv  id_rsa_pub  ~/git/sh00/ex03		복제된 공개키를 과제 제출 폴더로 이동하였음⁡
//
//: 파일 확장자를 변경해도 되는 이유
//		⁡⁢⁢⁢파일이란 근본적으로 바이트의 나열이다. 그림파일이든 음악파일이든 0과 1의 비트가 나열되어 있다.⁡
//		⁡⁢⁢⁢단순히 0과 1로 이루어진 덩어리를 어떤 식으로 인식하고 렌더링하느냐에 따라서,⁡
//		⁡⁢⁢⁢완전히 똑같은 덩어리가 비로소 그림이 되기도하고 소리가 되기도 한다.⁡
//		⁡⁢⁢⁢확장자는, 파일을 실행하려는 프로그램이 이러한 바이트를 어떻게 활용할 수도 있는지 제안하는 역할을 한다.⁡
//		⁡⁢⁢⁢한장의 사진을 특정한 방식으로 열람하면 그림이 되는데, 또다른 방식으로 열람하면 소리가 될 수도 있다.⁡
//		⁡⁢⁢⁢파일이란 그 자체로는 아무런 의미가 없는 바이트의 덩어리이기 때문이다.⁡
//		⁡⁢⁢⁢확장자를 없애버리고 확장자가 없는 새로운 파일로 복사하더라도. 본질적으로 파일의 성질은 변하지 않는다.⁡
//		⁡⁢⁢⁢사진 파일이라면 사진으로서 도움되는 바이트가, 음악 파일이라면 음악으로서 도움되는 바이트가 맨 앞에 깔린다.⁡
//		⁡⁢⁢⁢'이후의 바이트들을 이런 식으로 표집해가지고 사용해보시오' 라고 가이드하는 바이트이다.⁡
//		⁡⁢⁢⁢이러한 바이트들마저도, 내 맘대로 인식해서, 그림을 억지로 음악으로 렌더링하는게 원론적으로 불가능하지않다.⁡
//
///: midLS				--- 04 현재 디렉토리의 모든 파일/폴더를, 콤마/스페이스로 구분하고 날짜순으로 출력하는 명령어. 숨김파일은 제외.
///		⁡⁢⁢⁢ls 명령어는 현재 디렉토리의 모든 파일/폴더를 보여줌⁡
///		⁡⁢⁢⁣	⁡⁢⁢⁣exo2.tar  test0  test1  test2  test3  test4  test5  test6⁡
///
///		⁡⁢⁢⁢ls -m 옵션은 항목을 콤마와 띄어쓰기로 구분해줌⁡
///			⁡⁢⁢⁣exo2.tar, test0, test1, test2, test3, test4, test5, test6⁡
///
///		⁡⁢⁢⁢ls -p 옵션은 폴더에만 슬래쉬 문자를 붙여줌⁡
///			⁡⁢⁢⁣exo2.tar  test0/  test1  test2/  test3  test4  test5  test6⁡
///
///		⁡⁢⁢⁢ls -t 옵션은 수정된 순서대로 나열해줌⁡
///			⁡⁢⁢⁣exo2.tar  test3  test5  test4  test2  test6  test1  test0⁡
///
///		⁡⁢⁢⁢옵션을 조합해서 ls -tmp 라고 입력하면 다음과 같은 예시를 얻음⁡
///		⁡⁢⁢⁢일부러 쩜(dot)으로 시작하는 파일을 만들어봤지만 숨겨져서 보이지 않았음⁡
///			⁡⁢⁢⁣ls -tmp⁡
///			⁡⁢⁢⁣exo2.tar  test3  test5  test4  test2  test6  test1  test0⁡
///
///		⁡⁢⁢⁢-F 옵션도 슬래쉬 문자를 붙여주는데, 폴더가 아닌 다른 파일까지도 저마다의 기호로 구별해줌⁡
///			⁡⁢⁢⁣ls -Fmt⁡
///			⁡⁢⁢⁣exo2.tar, test3, test5, test4, test2/, test6@, test1, test0/⁡
///
//:  git_commit.sh		--- 05 최근 5개의 커밋 기록 중에서, 커밋ID만 뽑아내는 쉘 스크립트
//: 깃 명령어 add, commit, push
//		⁡⁢⁢⁢깃에는 많은 명령어가 있으며, 가장 많이 쓰이는 명령어는 add, commit, push 가 있다⁡
//	 		⁡⁢⁢⁣git add 파일명				저장소에 업로드할 파일을 예약함.		(무대에 올리기/내리기)⁡
//			⁡⁢⁢⁣git commit -m "버전명"		예약된 파일을 임시 폴더로 복제함.		(무대의 스냅샷 만들기)⁡
//			⁡⁢⁢⁣git push					임시 폴더의 내용을 서버에 업로드함.		(스냅샷을 저장소에 덮어쓰기)⁡
//		⁡⁢⁢⁢git add는 파일 혹은 폴더의 업로드를 예약한다. 저장소가 갖추길 희망하는 예비적인 구조를 만든다.⁡
//		⁡⁢⁢⁢단어 때문에 파일이 쌓이기만 할 것 같지만, 삭제한 파일을 add하면 예약 명단에서 제외된다.⁡
//		⁡⁢⁢⁢이러한 성질 때문에, 한번에 모든 파일을 add 하면, 작업 폴더의 구조 전체가 그대로 저장소의 구조가 된다.⁡
//			⁡⁢⁢⁣git add .					몰랐던 파일은 명부에 오르고, 없어진 파일은 명부에서 내려간다⁡
//		⁡⁢⁢⁢저장소가 갖추길 희망하는 예비적인 구조, 깃이 만들고 있는 형태를 무대라고 한다.⁡
//		⁡⁢⁢⁢git commit은 이러한 형태를 그대로 따라서, 예약된 파일들을 임시 폴더에 복제한다 (.git 하위 폴더)⁡
//		⁡⁢⁢⁢git push는 임시 폴더의 내용을 저장소에 업로드한다.⁡
//		⁡⁢⁢⁢무대가 추상적인 형태라면, 스냅샷은 조금 더 파일적인 실체가 있는 개념이다.⁡
//		⁡⁢⁢⁢임시 폴더의 파일 현황을 '스냅샷' 이라고 하며, git push 하면 저장소의 상태가 스냅샷으로 갱신된다.⁡
//
//: 깃 명령어 log
//		⁡⁢⁢⁢git commit을 할 때마다 해당 로그가 기록이 된다. 명령어로 확인할 수 있다.⁡
//			⁡⁣⁢⁣⁡⁢⁢⁣git log						커밋의 발자취를 보여줌.⁡
//		⁡⁢⁢⁢git log로 삼는 것이 add의 기록이 아니라 commit의 기록인 이유를 상상해보았음.⁡
//		⁡⁢⁢⁢add는 자주 일어나고 변동 사항이 많지만, git commit 은 어느 정도 결심이 섰을 때 사용하고⁡
//		⁡⁢⁢⁢파일적인 실체도 있어서 좀 더 무겁다. 버전명도 남길 수 있다.⁡
//		⁡⁢⁢⁢걸그룹이 무대에서 여러가지 포즈를 시도해보다가, 마음에 드는 구도를 확립하면 비로소 사진을 남기듯이.⁡
//		⁡⁢⁢⁢깃 로그 사진첩에도 add라는 모든 과정이(기억) 아니라, commit 이라는 추억이 담기는 것이다.⁡
//		
//		⁡⁢⁢⁢git log를 사용해서 역대 커밋을 살펴보면, 커밋 하나에도 여러가지 정보가 기록되어 있다.⁡
//		⁡⁢⁢⁢커밋 아이디, 커밋한 사람, 커밋한 날짜, 커밋할 때 지은 버전명이 나타난다.⁡
//		⁡⁢⁢⁢--format=%H 옵션을 사용하면, 로그에서 커밋 아이디만 뽑아볼 수 있다.⁡
//			⁡⁢⁢⁣git log --format=%H				커밋 기록 중에서 ID만 (HASH) 출력⁡
//			⁡⁢⁢⁣git log --format=%H | cat -e	개행 문자가 잘 붙어있는지 확인⁡
//		⁡⁢⁢⁢최신 로그를 최대 다섯개 만큼 출력할 수도 있다.⁡
//	 		⁡⁢⁢⁣git log -5						커밋 기록 중에서 최근 5개만 출력⁡
//			⁡⁢⁢⁣git log -5 --format=%H | cat -e	⁡
//
//: 쉘 스크립트 작성하고 실행하기
//		⁡⁢⁢⁢사용자가 터미널에 명령어를 입력하면, 쉘은 해당 명령어를 실행시켜준다. 쉘은 인터프리터의 일종이다.⁡
//			⁡⁢⁢⁣git log -5 --format=%H | cat -e	⁡
//		⁡⁢⁢⁢쉘 스크립트는, 여러줄의 터미널 명령어를 미리 작성해두고 차례대로 실행시키기 위한 문서이다.⁡
//		⁡⁢⁢⁢터미널에서 하던 것처럼 명령어를 그대로 작성하고, 파일의 확장자를 .sh 로 저장하면 쉘 스크립트로 인식한다.⁡
//		⁡⁢⁢⁢맨 윗줄의 #!/bin/bash 는, 이하의 명령어를 /bin 폴더에 설치된 bash 라는 인터프리터를 통해서 실행하겠다는 선언이다. 쉬뱅이라고 한다.⁡
//			⁡⁢⁣⁣(파일명) git_commit .sh⁡
//			⁡⁢⁢⁣#!/bin/bash⁡
//			⁡⁢⁢⁣git log -5 --format=%H
//			⁡⁢⁢⁣echo "abcde"⁡
//		⁡⁢⁢⁢쉘 스크립트 문서는 그 자체만으로도 실행이 가능하다.⁡
//		⁡⁢⁢⁢쉬뱅에서 인터프리터를 명시하였으므로, 해당 인터프리터를 통해서 실행된다.⁡
//			⁡⁢⁢⁣./git_commmit.sh⁡
//		⁡⁢⁢⁢문서를 실행시킬 인터프리터를 직접 선택할 수도 있다.⁡
//		⁡⁢⁢⁢인터프리터는 보통 #을 주석으로 인식하기 때문에, 이 방법에서는 쉬뱅이 무시된다.⁡
//			⁡⁢⁢⁣sh git_commit.sh⁡
//			⁡⁢⁢⁣bash git_commit.sh⁡
//			⁡⁢⁢⁣dash git_commit.sh⁡
//		⁡⁢⁢⁢⁡⁢⁢⁢sh / bash / dash 는 실행 결과가 거의 동일하다.⁡
//		⁡⁢⁢⁢bash는 기능이 좀더 많고 느리며, dash는 기능이 컴팩트하고 빠르다는 장단점이 있다고 한다.⁡
//		⁡⁢⁢⁡⁢⁢⁢42경산 교육장의 기본 쉘은 dash 로 설정되어있다.⁡
//
///: git_ignore.sh		--- 06 깃이 무시하는 모든 파일을 출력하는 쉘 스크립트
///: 깃 명령어 ls-files
///		⁡⁢⁢⁢git ls-files 명령어를 사용하면, git add를 통해서 업로드가 예약된 모든 파일이 표시된다⁡
///		⁡⁢⁢⁢업로드가 예약된 이러한 파일들을 '깃이 추적한다' 고 표현한다⁡
///			⁡⁢⁢⁣git ls-files⁡
///		⁡⁢⁢⁢--others 옵션은 정확하게 위 목록의 여집합을 보여준다⁡
///		⁡⁢⁢⁢--others 옵션이 출력하는 목록은, 깃이 ⁡⁢⁣⁣모르거나 거르는⁡⁡⁢⁢⁢ 파일들이다⁡
///			⁡⁢⁢⁣git ls-files --others⁡
///		⁡⁢⁢⁢PDF의 서론을 보면 오직 명시된 파일만을 제출하라는 규칙이 있다.⁡
///		⁡⁢⁢⁢압축 파일을 만드는 과제의 폴더에는 제출하면 안되는 불필요한 파일들이 많이 있다.⁡
///		⁡⁢⁢⁢.gitignore 에 이름 규칙을 작성하면, 선별해서 add 하거나, 불필요한 파일을 제거할 필요가 없이 add 단계에서 알아서 걸러진다⁡
///			⁡⁢⁢⁣cat .gitignore⁡
///		⁡⁢⁢⁢--ignored 옵션은 이처럼, 실제로 존재함에도 불구하고 add 단계에서 걸러진 파일들을 보여준다⁡
///			⁡⁢⁢⁣git ls-files --others⁡
///		⁡⁢⁢⁢그런데 거르는 기준이 다양해서 어떤 기준으로 걸러진 파일을 보고 싶은건지 명시해줘야한다⁡
///		⁡⁢⁢⁢.gitignore라는 데스노트 뿐만 아니라 표준적으로 거르는 기준이 있는데, 이를 통틀어서 --exclude-standard 라고 한다⁡
///			⁡⁢⁢⁣git ls-files --others --ignored⁡
///			⁡⁢⁢⁣git ls-files --others --ignored --exclude-standard⁡
///		⁡⁢⁢⁢의문점이 생긴다. ls-files는 깃이 추적하는 대상이고, ignored는 추적에서 걸러진 대상들이다.⁡
///		⁡⁢⁢⁢others랑 ignored는 똑같은게 아닌가?⁡
///			⁡⁢⁢⁣echo 'zzz' > zigak⁡
///		⁡⁢⁢⁢지각생 파일은 add를 거친적이 없기 때문에 ls-files가 모르고 있다⁡
///			⁡⁢⁢⁣git ls-files⁡
///		⁡⁢⁢⁢여집합을 출력하면 지각생 파일을 확인할 수 있다⁡
///			⁡⁢⁢⁣git ls-files --others⁡
///		⁡⁢⁢⁢걸러진 목록에서는 지각생 파일이 출력되지 않는다⁡
///		⁡⁢⁢⁢즉, --others란 --ignored 만을 뜻하는 것이 아니라, 아직 add 하지 않아서 깃이 '모르는' 파일도 포함된다⁡
///			⁡⁢⁢⁣git ls-files --others --ignored --exclude-standard⁡
///		⁡⁢⁢⁢파일을 이미 추적한 상태에서 제외가 안된다면 다음 명령어를 사용한다.⁡
///		⁡⁢⁢⁢git rm은 예약 명부에서만 지우면 되는데 아예 파일을 지워버리는 무서운 명령어이므로, 대신에 다음을 사용한다.⁡
///		⁡⁢⁢⁢파일은 삭제하지 않고 예약 명부에서만 지워준다.⁡
///			⁡⁢⁢⁣git rm -r --cached .⁡
///		⁡⁢⁢⁢파일명을 ~.sh 으로 설정하면 쉘 스크립트가 만들어진다.⁡
///		⁡⁢⁣⁣	(파일명) git_commit .sh⁡
///	 		⁡⁢⁢⁣#!/bin/bash⁡
///			⁡⁢⁢⁣git ls-files --others --ignored --exclude-standard
///		⁡⁢⁢⁢터미널에서 쉘 스크립트를 실행하고 결과를 확인한다.⁡
///			⁡⁢⁢⁣bash git_ignore.sh | cat -e⁡
///
//:  b					--- 07 두 파일 사이의 차이점을 (명시한 vs 추적한) diff 파일을 활용해서, 원본 파일을 목적 파일로 패치시키기
//		⁡⁢⁢⁢diff 명령어는 두 문서의 차이점을 알려주는데,⁡
//			⁡⁢⁢⁣diff a → b⁡
//		⁡⁢⁢⁢a라는 파일이 b라는 파일처럼 되기 위해서는 무슨 짓을 해야하는지 알려준다.⁡
//			⁡⁢⁢⁣1,2	 change	 1,8			a파일의 1~2번 라인을,  b파일의 1~8라인으로 교체하시오⁡
//			⁡⁢⁢⁣4,6	 delete	 9				a파일의 4~6번 라인을 삭제하시오⁡
//			⁡⁢⁢⁣8	 delete	 10				a파일의 8번 라인을 삭제하시오⁡
//		⁡⁢⁢⁢부등호 > 를 사용해서 차이점을 저장한다.⁡
//			⁡⁢⁢⁣diff a b > sw.diff⁡
//		⁡⁢⁢⁢인트라에서 다운받은 sw.diff 라는 파일이 바로, 이렇게 만들어진 차이점 분석서이다⁡
//		⁡⁢⁢⁢patch는, 차이점 분석서의 요구 사항을 따라서 파일을 업데이트 시켜준다. 명세서대로 a가 변화한다.⁡
//			⁡⁢⁢⁣patch a sw.diff⁡
//		⁡⁢⁢⁢patch는 기본적으로 원본 파일에 덮어쓰는 방식이다.⁡
//		⁡⁢⁢⁢-o 옵션을 사용하면 a를 보존하고 b라는 파일을 새로 만들어준다.⁡
//			⁡⁢⁢⁣patch a sw.diff -o b⁡
//
///: clean				--- 08 현재 경로로부터, 이름규칙을 만족하는 '파일' 만을 속속들이 찾아내서 출력하고 삭제하는 명령어.
///		⁡⁢⁢⁢find 명령어를 사용하면, 현재 경로로 시작하는 모든 하위 폴더/파일을 속속들이 찾아준다⁡
///			⁡⁢⁢⁣find .⁡
///		⁡⁢⁢⁢-name 옵션을 사용하면, 이름 규칙을 만족하는 대상만을 뽑아준다⁡
///			⁡⁢⁢⁣find . -name "이름규칙"⁡
///		⁡⁢⁢⁢#으로 시작해서, *(공란이거나 아무 문자열이 존재하고), #으로 끝나는 이름은 #*# 으로 특정할 수 있다⁡
///		⁡⁢⁢⁢이름이 달랑 #인 파일은 찾아주지 않는데, "맨앞에 #이 ⁡⁢⁣⁣⁡⁢⁣⁣있고!⁡⁡⁢⁢⁢ (아무런 문자가 오고) 마지막에 #이 ⁡⁢⁣⁣있다!⁡⁢⁢⁢" 라서, ##처럼 무조건 두 개는 있어야한다⁡
///		⁡⁢⁢⁢*(공란이거나 아무 문자열이 존재하고), ~으로 끝나는 이름은 *~ 으로 특정할 수 있다⁡
///			⁡⁢⁢⁣find . -name "#*#"⁡
///			⁡⁢⁢⁣find . -name "*~"⁡
///		⁡⁢⁢⁢-or(또는) 옵션을 사용하면, 이름 규칙을 추가해서 더 많은 대상을 찾아준다⁡
///			⁡⁢⁢⁣find . -name "이름규칙1" -or -name "이름규칙2"⁡
///			⁡⁢⁢⁣find . -name "#*#" -or -name "*~"⁡
///		⁡⁢⁢⁢-delete 옵션은 발견한 파일을 삭제하는데, 말없이 삭제만 할 뿐이지 리스트를 보여주지 않음.⁡
///			⁡⁢⁢⁣find . -name "#*#" -or -name "*~" -delete⁡
///		⁡⁢⁢⁢ls 로 확인해보면 파일이 지워졌는데, 물결(~) 친구들만 지워진 것을 알 수 있음.⁡
///		⁡⁢⁢⁢or로 연결된 두 개의 항목 중에서, 자기가 걸려있는 항목에만 -delete가 적용되었기 때문.⁡
///			⁡⁢⁢⁣find . -name "#*#" -or⁡⁡⁢⁣⁣ -name "*~" -delete⁡
///		⁡⁢⁢⁢백슬래쉬와 함께 \(  \) 괄호를 써서 하나로 묶어주면 양쪽 모두에 적용됨. 괄호와 옵션 사이에 띄어쓰기가 필요함.⁡
///			⁡⁢⁢⁣find . \( -name "#*#" -or -name "*~" \) -delete⁡
///		⁡⁢⁢⁢-print 옵션은 삭제하기 이전에 리스트를 보여줌.⁡
///			⁡⁢⁢⁣find . \( -name "#*#" -or -name "*~" \) -delete -print⁡
///		⁡⁢⁢⁢-type f 를 추가해주면 디렉토리가 아니라 파일만 보여줌. (f는 파일 / d는 디렉토리 / l은 심볼릭링크 / ...) 인데, 파일만 보고 싶음.⁡
///			⁡⁢⁢⁣find . -type f⁡
///			⁡⁢⁢⁣find . -type f \( -name "#*#" -o -name "*~" \) -delete -print⁡
///		⁡⁢⁢⁢해당 명령어를 저장하는 텍스트를 만드는 것이 과제의 요구 조건이므로 echo의 > 기능을 이용함⁡
///			⁡⁢⁢⁣echo 'find . -type f \( -name "#*#" -or -name "*~" \) -delete -print' > clean⁡
///			⁡⁢⁢⁣cat clean⁡
///
//:  ft_magic			--- 09 42번째 바이트부터 "42" 라는 문자열이 등장하는 "42 file" 이라는 파일타입을 판별해주는 매직파일
//		⁡⁢⁢⁢프로그래밍 언어에 int형, char형, double형 같은 다양한 타입이 있듯이, 파일의 타입에도 여러가지가 있다.⁡
//		⁡⁢⁢⁢폴더, 심볼릭링크, ASCII Text, ssh key와 같은 다양한 타입들이 있다. file 이라는 명령어는 이러한 파일의 타입을 알려준다.⁡
//			⁡⁢⁢⁣file 파일명⁡
//		⁡⁢⁢⁢파일의 타입을 사용자가 직접 정의할 수도 있다.⁡
//		⁡⁢⁢⁢file -m 명령어를 사용하면, 특정 파일이 사용자가 정의한 무슨 타입인지 확인할 수 있다.⁡
//		⁡⁢⁢⁢파일이 사용자가 정의한 타입에 해당하지 않는다면, 기본적으로는 무슨 타입에 해당하는지 알려준다.⁡
//			⁡⁢⁢⁣file  -m [파일명]			(에러)⁡
//	⁡⁢⁢⁢	파일이 사용자가 정의한 타입에 해당하는지를 판단하려면 기준이 필요하다.⁡
//	⁡⁢⁢⁢	기준이 정해져있으면 그것을 바탕으로 판단을 할 수 있다. 그런 기준이되는 메뉴얼을 매직 파일이라고 한다.⁡
//	⁡⁢⁢⁢	매직 파일은 처음부터 file 명령어랑 연동될 목적으로 제작되는 메뉴얼 파일이다.⁡
//			⁡⁢⁢⁣file  -m [매직파일명] [파일명]⁡
//		⁡⁢⁢⁢문제가 요구하는 것은, "42 file" 이라는 타입을 판정하는 메뉴얼을(=매직 파일) 작성하는 것이다.⁡
//		⁡⁢⁢⁢ft_magic 이라는 이름의 메뉴얼을 만들어서, file -m 에게 제공하면 특정한 파일이 사용자가 정의한 타입인지 판단해준다.
//			⁡⁢⁢⁣file  -m   ft_magic   [파일명]⁡
//		⁡⁢⁢⁢"42 file" 이라는 타입은 다음 성질을 가진다.⁡
//			⁡⁢⁢⁣타입의 이름: '42 file' 형
//			⁡⁢⁢⁣타입의 특징: 42바이트 자리에 42라는 문자열 내용이 존재⁡
//		⁡⁢⁢⁢매직 파일을 작성하기 위한 문법이 있다. (말장난:  41 이후 == 42 부터 )⁡
//			⁡⁢⁣⁢(41)⁡ ⁡⁢⁣⁣(string)⁡ ⁡⁣⁣⁢(42)⁡ ⁡⁣⁢⁢(42 file)⁡
//			⁢⁣⁢(41)⁡ ⁡⁢⁢⁣바이트 이후에, 즉 42번째 바이트부터 무엇이 올 것인지. 바이트로 뜯어보았을때 42번째부터 무엇이 올 것인지.⁡
//			⁡⁢⁣⁣(string)⁡ ⁡⁢⁢⁣42번째 자리 부터는 문자열이 올 것임을 선언.⁡
//			⁡⁣⁣⁢(42)⁡ ⁡⁢⁢⁣구체적으로 42라는 문자열이 올 것이다. 
//			⁡⁣⁢⁢(42 file)⁡ ⁡⁢⁢⁣그렇다면 해당 파일은 '42 file' 타입이라고 판정해주세요.⁡
//		⁡⁢⁢⁢낱말이 5개라서 인자가 5개인 것 같지만 사실은 4개의 인자로 이루어져있다.⁡
//	⁡⁢⁢⁢	⁡⁢⁢⁢echo 명령어를 사용하면, 문자열을 이용해서 손쉽게 파일을 만들 수 있다. -n 옵션을 이용하면 개행 문자를 추가하지 않는다.⁡
//			⁡⁢⁢⁣41 string 42 42 file⁡
//			⁡⁢⁢⁣echo '41 string 42 42 file' > ft_magic⁡
//		⁡⁢⁢⁢빈 파일에 아무렇게나 41개의 글자를 채우고, 42자리부터 '42' 라고 기입하고, 추가적으로 글자를 아무렇게나 채워서 저장한다.⁡
//		⁡⁢⁢⁢저장한 파일을 다음 명령어로 확인해보면 42 file 이라고 판정해준다. 만약에 메뉴얼에 부합하지않는 파일이라면 기본적인 타입을 알려준다.⁡
//			⁡⁢⁢⁣echo "1234567890123456789012345678901324567890142777777777777777777777777777777777777777777777" > hello⁡
//			⁡⁢⁢⁣file -m ft_magic hello⁡
//

//!  SH01
///: print_groups.sh		--- 01 환경 변수 FT_USER에 저장된 유저가 속해있는 모든 그룹을 콤마로 구분하여 출력하는 쉘 스크립트
///		⁡⁢⁢⁢리눅스 사용자의 계정은 한개 이상의 그룹에 소속되어 있다.⁡
///		⁡⁢⁢⁢사용자가 속해있는 그룹 목록은 두 가지 방법으로 출력할 수 있다. PDF에서 id를 권장하므로 id를 이용한다.⁡
///			⁡⁢⁢⁣groups 유저명⁡
///			⁡⁢⁢⁣id -Gn 유저명⁡
///		⁡⁢⁢⁢id -G는 사용자가 속해있는 그룹의 일련번호를 출력한다.⁡
///			⁡⁢⁢⁣id -G	keunykim⁡
///			⁡⁢⁢⁣4223 204⁡
///		⁡⁢⁢⁢id -Gn은 사용자가 속해있는 그룹의 일련번호를 닉네임으로 출력한다.⁡
///			⁡⁢⁢⁣id -Gn	keunykim⁡
///			⁡⁢⁢⁣2023_42gyeongsan  _developer⁡
///		⁡⁢⁢⁢파이프라인을 사용하면, 왼쪽 명령어의 출력을 오른쪽 명령어의 입력으로 전달해서 연쇄적으로 데이터를 가공할 수 있다⁡
///		⁡⁢⁢⁢tr 명령어는 집합 두 개를 받아서, 한쪽 집합에 속하는 원소를 다른 집합의 원소로 치환해주는 기능을 가지고 있다.⁡
///			⁡⁢⁢⁣id -Gn keunykim | tr ' ' ','⁡
///			⁡⁢⁢⁣2023_42gyeongsan,_developer⁡
///		⁡⁢⁢⁢과제 예시를 보면, 결과물을 출력하고 새로운 명령줄이 곧바로 이어지는 것을 볼 수 있다. 이것은 개행문자가 생략 되었음을 의미한다⁡
///		⁡⁢⁢⁢tr -d 명령어는 집합에 속하는 원소를 모두 찾아서 삭제해주는 기능을 가지고 있다⁡
///			⁡⁢⁢⁣id -Gn keunykim | tr ' ' ',' | tr -d '\n'⁡
///			⁡⁢⁢⁣22023_42gyeongsan,_developer%⁡
///		⁡⁢⁢⁢명령어는 인자를 필요로한다. 인자를 직접 입력하지 않고 변수의 값으로 대신할 수 있다.⁡
///		⁡⁢⁢⁢export 명령어를 사용하면 변수에 값을 저장할 수 있다.⁡
///			⁡⁢⁢⁣export FT_USER="keunykim"⁡
///		⁡⁢⁢⁢이러한 인자를 명령어의 변수로 사용할때는 변수 앞에 $달러를 붙여준다⁡
///			⁡⁢⁢⁣echo $FT_USER⁡
///			⁡⁢⁢⁣keunykim⁡
///		⁡⁢⁢⁢변수에 저장된 유저명에 따라 유저가 속한 그룹의 목록을 달리 보여줄 수 있게된다.⁡
///			⁡⁢⁢⁣id -Gn keunykim | tr ' ' ',' | tr -d '\n'⁡
///			⁡⁢⁢⁣id -Gn ⁡⁡⁢⁣⁢$FT_USER⁡⁡⁢⁢⁣ | tr ' ' ',' | tr -d '\n'⁡
///		⁡⁢⁢⁢getent 명령어를 사용하면 특정 그룹에 속한 모든 유저를 확인할 수 있다.⁡
///			⁡⁢⁢⁣getent group⁡
///			⁡⁢⁢⁣getent group 2023_gyeongsan⁡
///		⁡⁢⁢⁢이러한 유저를 FT_USER 변수에 저장해가면서 테스트 해보면 어떤 그룹에 속하는지 알 수 있다⁡
///			⁡⁢⁢⁣export FT_USER="keunykim"⁡
///			⁡⁢⁢⁣export FT_USER="taegkang"⁡
///			⁡⁢⁢⁣export FT_USER="dae-lee"⁡
///			⁡⁢⁢⁣id -Gn $FT_USER | tr ' ' ',' | tr -d '\n'⁡
///		⁡⁢⁢⁢파일명을 ~.sh 으로 설정하고 쉘 스크립트를 작성한다.⁡
///		⁡⁢⁢⁢쉬뱅(#!)을 명시하면, 다른 명령어를 거치지 않고 쉘 스크립트가 자체적으로 실행될 때, 무슨 인터프리터를 사용할 것인지 결정할 수 있다.⁡
///		⁡⁢⁢⁢bash 같은 명령어를 사용하지 않고도, 쉘 스크립트가 자체적으로 실행되게끔 과제에서 요구하므로, 쉬뱅을 명시해준다.⁡
///			⁡⁢⁣⁣(파일명) print_groups .sh⁡
///. 		⁡⁢⁢⁣⁡⁣⁣⁢#!/bin/sh⁡
///			⁡⁢⁢⁣id -Gn $FT_USER | tr ' ' ',' | tr -d '\n'⁡
///		⁡⁢⁢⁢쉘 스크립트를 편집하지 않았는데도, 환경 변수를 변경하므로써 결과를 달라지는 것을 확인할 수 있다. ⁡
///			⁡⁢⁢⁣./print_groups.sh | cat -e⁡
///			⁡⁢⁢⁣export FT_USER="keunykim"⁡
///			⁡⁢⁢⁣export FT_USER="taegkang"⁡
///			⁡⁢⁢⁣export FT_USER="dae-lee"⁡
///
//:  find_sh.sh				--- 02 이름이 '.sh'로 끝나는 파일을 속속들이 찾아내어, 이름에서 확장자를 제외해서 출력하는 쉘 스크립트
//		⁡⁢⁢⁢find 명령어를 사용하면, 지정한 경로로 시작하는 하위 폴더/파일을 속속들이 찾아준다⁡
//			⁡⁢⁢⁣find .⁡
//		⁡⁢⁢⁢-name 옵션을 사용하면, 이름 규칙을 만족하는 대상만을 뽑아준다⁡
//		⁡⁢⁢⁢공란이거나 아무 문자열이 이어지다가 .sh 으로 끝나는 이름은 "*.sh" 으로 특정할 수 있다⁡
//			⁡⁢⁢⁣find . -name "이름규칙"⁡
//			⁡⁢⁢⁣find . -name "*.sh"⁡
//		⁡⁢⁢⁢그런데 디렉토리가 아닌 파일만을 찾아야하므로 -type f 옵션도 추가해준다⁡
//			⁡⁢⁢⁣find . -type f -name "*.sh"⁡
//		⁡⁢⁢⁢basename 명령어를 사용하면, 파일의 이름을 가공하여 새로운 문자열을 만들 수 있다⁡
//		⁡⁢⁢⁢파일명 다음 인자에 접미사를 넣으면, 파일이름 뒷자리가 접미사와 일치할 경우에 해당 문자열을 지워준다⁡
//			⁡⁢⁢⁣basename 파일명⁡
//			⁡⁢⁢⁣basename 파일명 접미사⁡
//		⁡⁢⁢⁢그러므로, 파일명 다음 인자에 확장자를 묘사하면 확장자만 지워진다⁡
//			⁡⁢⁢⁣basename a.out .out⁡
//			⁡⁢⁢⁣a⁡
//		⁡⁢⁢⁢find 명령어의 결과물을 파이프라인으로 넘겨서, basename 명령어로 가공하면 되겠다는 생각이든다.⁡
//		⁡⁢⁢⁢find 명령어는 여러줄의 데이터 리스트를 출력하는데, 리스트의 원소가 여러 개라서 파이프라인이 제대로 작동하지 않는다.⁡
//		⁡⁢⁢⁢find 명령어에 -exec 옵션을 사용하면, 리스트 각각의 원소를 대상으로 추가적인 작업을 수행할 수 있다.⁡
//			⁡⁢⁣⁣1.	명령문은 -exec 으로 시작한다.⁡
//			⁡⁢⁣⁣2.	찾아낸 리스트의 각 원소는 {} 라는 대명사로 지칭한다.⁡
//			⁡⁢⁣⁣3.	명령문의 끝에는 이스케이프 문자와 함께 세미콜론이 \; 온다.⁡
//					⁡⁢⁢⁣명령어1 -exec 명령어2 {} \;⁡
//					 ⁡⁢⁢⁣find . -exec  명령어 {} \;⁡
//		⁡⁢⁢⁢find로 찾아낸 리스트에서 .sh 만을 제거하려면,  다음과 같이 작성할 수 있다.⁡
//			⁡⁢⁢⁣find . 						-exec basename {} ".sh" \;⁡
//			⁡⁢⁢⁣find . -type f -name "*.sh" -exec basename {} ".sh" \;⁡
//		⁡⁢⁢⁢파일명을 ~.sh 으로 설정하고 쉘 스크립트를 작성한다.⁡
//			⁡⁢⁣⁣(파일명) find_sh .sh⁡
//	 		⁡⁢⁢⁣#!/bin/sh⁡
//			⁡⁢⁢⁣find . -type f -name "*.sh" -exec basename {} ".sh" \;⁡
//
///: count_files.sh			--- 03 현재 경로로 시작하는 모든 '하위 폴더'와 '레귤러 파일'을 찾아내고 총 갯수를 표시하는 쉘 스크립트
///		⁡⁢⁢⁢다음과 같은 파일이 존재한다.⁡
///			⁡⁢⁣⁣cat -e test⁡
///			⁡⁢⁢⁣aaaa$⁡
///			⁡⁢⁢⁣bbbb$⁡
///			⁡⁢⁢⁣cccc$⁡
///			⁡⁢⁢⁣dddd$⁡
///		⁡⁢⁢⁢wc 명령어를 사용하면, 파일 내용을 읽어서 라인수(line), 단어수(word), 문자수(char), 파일명을 알려준다⁡
///			⁡⁢⁢⁣wc test⁡
///			⁡⁢⁢⁣ 4  4 20 test⁡
///		⁡⁢⁢⁢세가지 정보의 앞글자를 따서 (l, w, c) 명령어 옵션으로 입력하면 해당 정보만 알아낼 수 있다⁡
///			⁡⁢⁢⁣wc -l test⁡
///			⁡⁢⁢⁣4 test⁡
///		⁡⁢⁢⁢파이프라인은, 왼쪽 명령어의 결과물을 오른쪽 명령어의 입력으로 전달해서, 연쇄적으로 데이터를 가공할 수 있게한다⁡
///		⁡⁢⁢⁢find 명령어를 사용하면, 지정한 경로에서 시작하는 모든 하위 폴더와 파일들을 속속들이 찾아주고, 각 항목을 줄마다 하나씩 알려준다⁡
///		⁡⁢⁢⁢이러한 find의 출력 결과물을 그대로 wc -l 명령어의 인자로 넘기면, 파일의 갯수를 알 수 있다⁡
///			⁡⁢⁢⁣find . | wc -l⁡
///		⁡⁢⁢⁢그런데 wc는 본래 여러가지 정보를 표현하는 명령어이고,⁡
///		⁡⁢⁢⁢한가지 정보를 출력하기 전에 공백을 두므로써, 서로 다른 정보들을 칸처럼 구분하는 특징이 있다. 이러한 공백을 제거해야한다.⁡
///		⁡⁢⁢⁢cat -e 명령어로 문자열의 끝이 어디인지 확인하면, 뒷쪽으로는 스페이스나 탭같은 잡문자가 따로 붙지 않음을 알 수 있다.
///			⁡⁢⁢⁣find . | wc -l | cat -e⁡
///			⁡⁢⁢⁣~~~~~~~55$						(스페이스 대신 ~~라고 표현했음)⁡
///		⁡⁢⁢⁢tr -d 명령어는 주어진 집합의 원소를 모두 찾아서 삭제해주는 기능을 가지고 있다⁡
///			⁡⁢⁢⁣find . | wc -l | tr -d ' '⁡
///			⁡⁢⁢⁢⁡⁢⁢⁣55⁡
///		⁡⁢⁢⁢교육장 컴퓨터 환경에서는 ⁡⁢⁣⁣find . | wc -l⁡⁡⁢⁢⁢ 까지만 작성해도 처음부터 스페이스가 제거되어서 출력된다⁡
///		⁡⁢⁢⁢두 가지 명령어 중에서 어떤 명령어를 사용해야할지 고민이다⁡
///			⁡⁢⁢⁣find . | wc -l⁡
///			⁡⁢⁢⁣find . | wc -l | tr -d ' '⁡
///		⁡⁢⁢⁢공백이 없는 문자열에서, 구태여 없는 공백을 삭제하더라도, 성능에 차이가 있을 뿐 결과에 차이가 없다면,⁡
///		⁡⁢⁢⁢공백이 있는 환경도 호환되도록 하였다. 어떤 환경에서 채점될지 모르니까.⁡
///			⁡⁢⁢⁣find . | wc -l | tr -d ' '⁡
///		⁡⁢⁢⁢파일의 종류는 (- d l) 말고도 무척 다양하다. 과제는 그 중에서 '레귤러 파일'과 '디렉토리' 만 찾아내라고 하였다.⁡
///			⁡⁢⁢⁣find . -type f					레귤러 파일만 찾아냄⁡
///			⁡⁢⁢⁣find . -type d					디렉토리만 찾아냄⁡
///			⁡⁢⁢⁣find . -type f -or -type d		레귤러 파일과 디렉토리를 모두 찾아냄⁡
///		⁡⁢⁢⁢명령어를 조합하면 다음과 같다⁡
///			⁡⁢⁢⁣find . -type f -or -type d | wc -l⁡
///		⁡⁢⁢⁢파일명을 ~.sh 으로 설정하고 쉘 스크립트를 작성한다.⁡
///			⁡⁢⁣⁣(파일명) count_files .sh⁡
///	 		⁡⁢⁢⁣#!/bin/sh⁡
///			⁡⁢⁢⁣⁣find . -type f -or -type d | wc -l⁡
///
//:  MAC.sh					--- 04 ifconfig에서 볼 수 있는 장치 정보들 중에서 맥어드레스 값만 추출해서 표시하는 쉘 스크립트
//		⁡⁢⁢⁢우리 주위의 다양한 장치들이 근거리 네트워크를 이룰 때, 이것이 돌아가게 하는 시스템이 이더넷이다.⁡
//		⁡⁢⁢⁢이더넷에 참여하기 위해서는, 지문과 같이 하드웨어마다 부여된 고유번호가 필요한데 이것이 맥 어드레스이다.⁡
//		⁡⁢⁢⁢이러한 맥 어드레스는 ifconfig 실행시 'ether 이더' 항목으로 안내가 된다.⁡
//			⁡⁢⁣⁣ifconfig⁡
//			⁡⁢⁢⁣enp0s31f6: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500⁡
// 			⁡⁢⁢⁣inet 10.11.2.6  netmask 255.255.0.0  broadcast 10.11.255.255⁡
//			⁡⁢⁢⁣inet6 fe80::2288:10ff:fe77:bbb7  prefixlen 64  scopeid 0x20<link>⁡
//			⁡⁢⁢⁡⁣⁣⁢ether 20:88:10:77:bb:b7  txqueuelen 1000  (イーサネット)⁡
//			⁡⁢⁢⁣RX packets 20813601  bytes 16729692109 (16.7 GB)⁡
//			⁡⁢⁢⁣RX errors 0  dropped 3  overruns 0  frame 0⁡
//			⁡⁢⁢⁣TX packets 28730443  bytes 34978577728 (34.9 GB)⁡
//			⁡⁢⁢⁣TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0⁡
//			⁡⁢⁢⁣device interrupt 19  memory 0x74300000-74320000  ⁡
//		⁡⁢⁢⁢교육장 컴퓨터에 부착된 스티커에 MAC: 20881077BBB7 처럼 적혀있는데⁡
//		⁡⁢⁢⁢ifconfig에서 찾아보면 신기하게도 이것과 똑같은 맥 어드레스가 존재한다.⁡
//		⁡⁢⁢⁢교육장 컴퓨터를 다른 건물에 설치한다고 스티커의 글자가 바뀌지는 않을 것이다.⁡
//		⁡⁢⁢⁢스티커의 글자는 교육장 컴퓨터가 설치된 장소와 목적과는 무관한 값일 것이다.⁡
//		⁡⁢⁢⁢즉, 스티커의 글자는 이 하드웨어가 고유하게 지니는, 지문처럼 쉽사리 중복되지않는 고유한 번호이다.⁡
//		⁡⁢⁢⁢의도적으로 이 값을 변경하는 것도 가능하지만, 스티커에 적혀있는 맥 어드레스는 공장 초기값에 해당할 것이다.⁡
//			⁡⁢⁢⁣Service Tag:	9HBMWP3⁡
//			⁡⁣⁣⁢MAC:			20881077bbb7⁡
//			⁡⁢⁢⁣Wireless MAC:	687A64800070⁡
//			⁡⁢⁢⁣Build Data:		2023-08-18⁡
//		⁡⁢⁢⁢장치들의 리스트와 함께 ether도 여러개 등장한다. 이러한 ether만 뽑아내고 싶다.⁡
//		⁡⁢⁢⁢grep 명령어는 주어진 정규식에 해당하는 라인만을 뽑아준다 (편의상 공백은 언더라인으로 표시함)
//			⁡⁢⁣⁣ifconfig | grep "ether"⁡
//			_______⁡⁢⁢⁣ether ⁡⁡⁣⁣⁢02:42:28:e4:b3:d6⁡⁡⁢⁢⁣  txqueuelen 0  (イーサネット)⁡
//			_______⁡⁢⁢⁣ether⁡⁡⁡⁣⁣⁢ 20:88:10:77:bb:b7⁡⁡⁢⁢⁣  txqueuelen 1000  (イーサネット)⁡
//			_______⁡⁢⁢⁣ether⁡⁡⁣⁣⁢ 52:54:00:dd:31:66⁡⁡⁢⁢⁣  txqueuelen 1000  (イーサネット)⁡
//		⁡⁢⁢⁢출력 결과를 가공하여서 맥 어드레스를 온전하게 추출하고 싶다.⁡
//		⁡⁢⁢⁢tr -d 명령어는 주어진 집합의 원소를 모두 찾아서 삭제해주는 기능을 가지고 있다.⁡
//		⁡⁢⁢⁢"ethr" 라는 집합을 주면, 맥 어드레스에 들어있는 16진수 e까지 삭제되어버린다⁡
//			⁡⁢⁣⁣ifconfig | grep "ether" | tr -d 'ethr'⁡
//			_______⁡⁢⁢⁣02:42:28:4:b3:d6  xquuln 0  (イーサネット)⁡
//			_______⁡⁢⁢⁣20:88:10:77:bb:b7  xquuln 1000  (イーサネット)⁡
//			_______⁡⁢⁢⁣52:54:00:dd:31:66  xquuln 1000  (イーサネット)⁡
//		⁡⁢⁢⁢다른 방법을 찾아보자.⁡
//		⁡⁢⁢⁢sed 's/찾을문자열/바뀐문자열/g' 라는 명령어는 찾아바꾸기를 적용해준다. 정규이이라 불리는 문자열 규칙을 사용한다.⁡
//		⁡⁢⁢⁢s옵션은 찾아바꾸기를 사용하겠다는 선언이고, 처음으로 발견한 문자열에만 찾아바꾸기를 적용한다.⁡
//		⁡⁢⁢⁢g옵션을 사용하면 최초 1회만이 아니라, 규칙에 해당하는 모든 문자열에 전부 찾아바꾸기를 적용한다.⁡
//			⁡⁢⁢⁣sed 's/찾을문자열/바뀐문자열/'⁡
//			⁡⁢⁢⁣sed 's/문자열규칙/문자열규칙/'⁡
//		⁡⁢⁢⁢맥 어드레스 앞에 놓여있는 불필요한 정보들은, 다음과 같이 표현할 수 있다.⁡
//			⁡⁢⁣⁣_______ether_⁡⁡⁢⁢⁣02:42:28:e4:b3:d6  txqueuelen 0  (イーサネット)⁡
//			⁡⁢⁢⁣스페이스바 또는 탭문자가 반복되다가 ether등장하고 스페이스가 하나 등장⁡
//		⁡⁢⁢⁢이것을 정규식으로 번역하면 "[ \t]+ether " 가 된다.
//			⁡⁢⁢⁣[ \t]			스페이스바 또는 탭문자 하나.		[대괄호]는 "또는" 을 의미한다.⁡
//			⁡⁢⁢⁣[ \t]+			스페이스바 또는 탭문자의 반복.		+는 특정 내용의 "반복" 을 의미한다.⁡
//			⁡⁢⁢⁣[ \t]+ether		스페이스바 또는 탭문자가 반복되고,	이후 ether가 등장한다⁡
//			⁡⁢⁢⁣[ \t]\+ether	정규식은 이미 완성되었지만, sed에서 쓰려면 반복 기호에 백슬래시를 추가해준다⁡
//		⁡⁢⁢⁢문자열의 규칙을 고안하였고, 규칙에 해당하는 모든 문자열을 없애버리기 위해서 '바꿀 문자열' 을 공란으로 채운다.⁡
//		⁡⁢⁢⁢맥 어드레스 앞에 놓여있는 불필요한 정보들이 삭제되었다⁡
//			⁡⁢⁡⁢⁣⁣ifconfig | grep "ether " | sed 's/[ \t]\+ether //g'⁡
//			⁡⁢⁢⁣02:42:28:e4:b3:d6  txqueuelen 0  (イーサネット)⁡
//			⁡⁢⁢⁣20:88:10:77:bb:b7  txqueuelen 1000  (イーサネット)⁡
//			⁡⁢⁢⁣52:54:00:dd:31:66  txqueuelen 1000  (イーサネット)⁡
//		⁡⁢⁢⁢맥 어드레스 뒤에 따라오는 불필요한 정보들은 다음과 같이 표현할 수 있다. (편의상 공백은 언더라인으로 표시함)⁡
//			⁡⁢⁢⁣02:42:28:e4:b3:d6⁡⁡⁢⁣⁣__txqueuelen 0  (イーサネット)⁡
//			⁡⁢⁢⁣공백로 시작하면서 뒤이어 나타나는 모든 문자⁡
//		⁡⁢⁢⁢이것을 정규식으로 번역하면 " .+" 가 된다.⁡
//			⁡⁢⁢⁣.				정규식에서 '쩜' 이란 "모든 문자" 를 의미한다. 와일드카드와 비슷하다⁡.
//			⁡⁢⁢⁣.+				+는 특정 규칙의 "반복" 을 의미한다.⁡
//			⁡⁢⁢⁣.\+				정규식은 완성되었지만, sed에서 쓰려면 반복 기호에 백슬래시를 추가해준다⁡
//		⁡⁢⁢⁢파이프라인으로 sed를 한번 더 먹여서, 맥 어드레스 뒤에 있는 불필요한 정보들도 삭제해준다⁡
//			⁡⁢⁣⁣ifconfig | grep "ether " | sed 's/[ \t]\+ether //g' | sed 's/ .\+//g'⁡
//			⁡⁢⁢⁣02:42:28:e4:b3:d6⁡
//			⁡⁢⁢⁣20:88:10:77:bb:b7⁡
//			⁡⁢⁢⁣52:54:00:dd:31:66⁡
//		⁡⁢⁢⁢파일명을 ~.sh 으로 설정하고 쉘 스크립트를 작성한다.⁡
//			⁡⁢⁣⁣(파일명) MAC .sh⁡
//	 		⁡⁢⁢⁣#!/bin/sh⁡
//			⁡⁢⁢⁣ifconfig | grep "ether " | sed 's/[ \t]\+ether //g' | sed 's/ .\+//g'⁡
//
///: "\?$*'MaRViN'*$?\"		--- 05 오직 4와 2라는 두개 문자를 내용으로 가지면서, 이름으로 사용할 수 없는 특수문자를 이름으로 갖는 파일
///		⁡⁢⁢⁢다음과 같은 명세에 따라서 파일을 작성하기⁡
///			⁡⁢⁣⁣ls -lRa *MaRV* | cat -e⁡
///			⁡⁢⁢⁣-rw---xr-- 1 75355 32015 2 Oct 2 12:21 "\?$*'MaRViN'*$?\"$⁡
///				⁡⁢⁢⁣파일의 유형:	일반 파일 (-)⁡
///				⁡⁢⁢⁣파일의 내용:	42⁡
///				⁡⁢⁢⁣파일의 용량:	2바이트⁡
///				⁡⁢⁢⁣파일의 이름:	마빈⁡
///				⁡⁢⁢⁣파일의 날짜:	Oct 2   12:21⁡
///				⁡⁢⁣⁣⁡⁢⁢⁣파일의 권한:	rw-  --x  r--⁡
///		⁡⁢⁢⁢echo는 문자열을 출력한다. 기본적으로 개행문자를 포함해서 출력하는데, -n 옵션은 개행문자를 제거해준다.⁡
///		⁡⁢⁢⁢cat -e 를 이용해서 개행문자가 사라짐을 확인할 수 있다.⁡
///			⁡⁢⁢⁣echo -n "42" | cat -e⁡
///			⁡⁢⁢⁣42%⁡
///		⁡⁢⁢⁢부등호 > 기호는 다양한 명령어와 연동되면서, 출력값을 파일로 저장해준다.⁡
///			⁡⁢⁢⁣echo -n "42" > 파일명⁡
///			⁡⁢⁢⁣ls -l 파일명⁡
///			⁡⁢⁢⁣-rw-r--r-- 1 keunykim 2023_42gyeongsan 54 12월 13 23:48 파일명⁡
///		⁡⁢⁢⁢컴퓨터 시스템에서 특정한 기능을 수행하기 위해서 특별하게 정의된 기호들이 있다.⁡
///		⁡⁢⁢⁢큰따옴표"  역슬래시\  물음표?  달러$  별표*  작은따옴표'  는 특정한 기능을 위해서 예약된 기호들이다.⁡
///		⁡⁢⁢⁢이스케이프 문자를 (\) 사용하면, 이러한 기호들을 기능으로서가 아니라 단순히 문양으로서 사용할 수 있게된다.⁡
///		⁡⁢⁢⁢PDF에 나와있는 "마빈" 을 복붙하고 알맞은 곳에 이스케이프 문자를 기입한다.⁡
///			⁡⁢⁢⁣"\?*$'MaRViN'*$?\"⁡
///			⁡⁢⁢⁣"		\		?		*		$		'		MaRViN		'		*		$		?		\		"⁡
///			⁡⁢⁢⁣\"		\\		\?		\*		\$		\'		MaRViN		\'		\*		\$		\?		\\		\"⁡
///		⁡⁢⁢⁢최종적으로 파일 생성 명령어는 다음과 같다⁡
///			⁡⁢⁢⁣echo -n "42" > \"\\\?\$\*\'MaRViN\'\*\$\?\\\"⁡
///		⁡⁢⁢⁢만들어진 파일을 확인하면 작은 따옴표가 이상하게 출력되는 것을 알 수 있다.⁡
///			⁡⁢⁢⁣ls -l⁡
///			⁡⁢⁢⁣'"\?$*'\''MaRViN'\''*$?\"'⁡
///		⁡⁢⁢⁢마빈 파일이 정상적으로 만들어졌는지 확인하기 위해서, 두 가지 방법을 생각해보았음.⁡
///		⁡⁢⁢⁢첫번째 방법으로, 현재 디렉토리를 GUI 탐색기로 열어서 확인할 때의 이름만큼은 적어도 일치하는지 확인할 수 있다.⁡
///			⁡⁢⁢⁣open .⁡
///		⁡⁢⁢⁢두번째 방법으로, 심볼릭 링크의 바이트 수는 자신이 참조하는 파일의 이름과 동일하다는 점을 이용할 수 있다.⁡
///		⁡⁢⁢⁢심볼릭 링크의 바이트 수는 파일의 이름 혹은 파일 경로의 길이와 동일하다.⁡
///		⁡⁢⁢⁢과제가 요구하는 마빈은 총 18글자인데, 심볼릭 링크의 바이트 수도 18임을 확인할 수 있다.⁡
///			⁡⁢⁢⁣ln -s [ 탭키 ] aaa⁡
///			⁡⁢⁢⁣ls -l aaa⁡
///		⁡⁢⁢⁢파일의 권한과 시간은 다음과 같이 부여한다. 혹시나 권한에 걸릴 수 있어서, 권한은 다른 명세보다도 마지막에 충족시키는 편이 유리하다.⁡
///		⁡⁢⁢⁢바이트/문자/이름을 채점하는 과제라서, 혹시나 권한과 시간이 과제의 명시된 것과는 다르더라도 기계 평가에서는 통과한다고 한다⁡
///			⁡⁢⁢⁣touch -t 10021221 마빈⁡
///			⁡⁢⁢⁣chmod 614 마빈⁡
///
//:  skip.sh				--- 06 명령어 ls -l의 출력 결과를 필터링하여, 홀수 열만 나타나게끔하는 쉘 스크립트
//		⁡⁢⁢⁢ls -l 명령어를 사용하면, 첫번째 줄에는 파일의 갯수가 출력되고, 이후에는 파일마다 한줄씩 상세 정보가 출력된다.⁡
//			⁡⁢⁣⁣ls -l⁡
//			⁡⁢⁢⁣합계 0⁡
//			⁡⁢⁢⁣drwxr-xr-x 5 keunykim 2023_42gyeongsan 100 12월 14 00:09 etc⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan  29 12월 17 00:02 ex00⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex01⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex02⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex03⁡
//		⁡⁢⁢⁢sed 명령어는 텍스트를 변환하거나 필터링하는데, 지시 사항을 코딩해서 복잡한 기능도 수행할 수 있다.⁡
//		⁡⁢⁢⁢명령문 '⁡⁡⁢⁣⁢0⁡⁡⁢⁣⁣~2⁡⁡⁣⁣⁢p⁡⁡⁢⁢⁢' 는 ⁡⁡⁢⁣⁢0번 라인부터 시작해서 ⁡⁡⁢⁣⁣두 줄마다 ⁡⁡⁣⁣⁢출력하게끔 ⁡⁢⁢⁢sed에게 지시한다.⁡
//		⁡⁢⁢⁢sed는 기본적으로 모든 내용을 출력하는 습성이있는데, p를 통해서 출력을 또다시 지시받았기 때문에, 짝수 줄이 중복해서 출력되는 것을 볼 수 있다.⁡
//			⁡⁢⁣⁣ls -l | sed '0~2p'⁡
//			⁡⁢⁢⁣합계 0⁡
//			⁡⁢⁢⁣drwxr-xr-x 5 keunykim 2023_42gyeongsan 100 12월 14 00:09 etc⁡
//			⁡⁣⁢⁢drwxr-xr-x 5 keunykim 2023_42gyeongsan 100 12월 14 00:09 etc⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan  29 12월 17 00:02 ex00⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex01⁡
//			⁡⁣⁣⁡⁣⁢⁢drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex01⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex02⁡
//			⁡⁢⁢⁣drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex03⁡
//			⁡⁣⁣⁢⁡⁣⁢⁢drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex03⁡
//		⁡⁢⁢⁢출력을 지시받은 경우에만 출력하고, 기본적인 출력 기능은 중단하려면 -n 옵션을 추가한다.⁡
//		⁡⁢⁢⁢'합계' 도 1번 라인으로 여겨져서 제외되고 2,4,6,8,... 라인만 출력된다.⁡
//			⁡⁢⁣⁣ls -l | sed -n '0~2p'⁡
//			⁡⁣⁢⁢drwxr-xr-x 5 keunykim 2023_42gyeongsan 100 12월 14 00:09 etc⁡
//			⁡⁡⁣⁢⁢drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex01⁡
//			⁡⁣⁢⁢drwxr-xr-x 2 keunykim 2023_42gyeongsan   6 12월 13 23:47 ex03⁡
//		⁡⁢⁢⁢파일명을 ~.sh 으로 설정하고 쉘 스크립트를 작성한다.⁡
//			⁡⁢⁣⁣(파일명) skip .sh⁡
//	 		⁡⁢⁢⁣#!/bin/sh⁡
//			⁡⁢⁢⁣ls -l | sed -n '0~2p'⁡
//
///: r_dwssap.sh			--- 07 
///		⁡⁢⁢⁢/etc/passwd 파일은 여러 사용자의 계정 정보를 담고있다.⁡
///		⁡⁢⁢⁢사용자의 계정 정보는 콜론(:)으로 구분되는 여러 개의 필드로 구성된다.⁡
///			⁡⁢⁣⁣cat /etc/passwd⁡
///			⁡⁣⁣⁢username	:	password	:	UID		:	GID		:	comment	:	home_directory	:	shell⁡
///			⁡⁢⁢⁣root		:	x			:	0		:	0		:	root	:	/root			:	/bin/bash⁡
///			⁡⁢⁢⁣daemon		:	x			:	1		:	1		:	daemon	:	/usr/sbin		:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣bin			:	x			:	2		:	2		:	bin		:	/bin			:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣sys			:	x			:	3		:	3		:	sys		:	/dev			:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣sync		:	x			:	4		:	65534	:	sync	:	/bin			:	/bin/sync⁡
///			⁡⁢⁢⁣games		:	x			:	5		:	60		:	games	:	/usr/games		:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣man			:	x			:	6		:	12		:	man		:	/var/cache/man	:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣lp			:	x			:	7		:	7		:	lp		:	/var/spool/lpd	:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣...⁡
///		sed -n '2~2p' 명령어는 2번 라인부터 시작하는 짝수열만 출력한다
///			cat /etc/passwd
///			⁡⁣⁣⁢username	:	password	:	UID		:	GID		:	comment	:	home_directory	:	shell⁡
///			⁡⁢⁢⁣daemon		:	x			:	1		:	1		:	daemon	:	/usr/sbin		:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣sys			:	x			:	3		:	3		:	sys		:	/dev			:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣games		:	x			:	5		:	60		:	games	:	/usr/games		:	/usr/sbin/nologin⁡
///			⁡⁢⁢⁣lp			:	x			:	7		:	7		:	lp		:	/var/spool/lpd	:	/usr/sbin/nologin⁡
///			...
///		과제에서는 각각의 줄을 
///reversing each login
///sorted in reverse alphabetical order
///keeping only logins between FT_LINE1 and FT_LINE2 included
///they must separated by  ,
///the output must end with a ".".
///마지막 개행 지우기 tr -d
///•Example: Between lines 7 and 15, the result should be something like this :
///sstq_, sorebrek_brk_, soibten_, sergtsop_, scodved_, rlaxcm_, rgmecived_, revreswodniw_, revressta_
///		$> ./r_dwssap.sh
///		cat /etc/passwd | grep -v '^#' | awk -F: '{print $1}' | sed -n '2~2p' | rev | sort -r | awk "NR >= $FT_LINE1 && NR <= $FT_LINE2" | tr '\n' ',' | sed 's/,/, /g' | sed 's/, $/./'
///		환경에 따라서 차이가 있으나, 특정 OS 에서는 샾으로 시작하는 주석이 앞서서 출력된다고 한다.
//:  add_chelou.sh			--- 08 특수문자로 매핑된 5진법 숫자의 합산을, 특수문자로 매핑된 13진법 숫자로 출력하는 쉘 스크립트
//		FT_NBR1 변수에는 '\"?! (=01234) 문자로 표현된 5진법 수가 저장되어 있고
//		FT_NBR2 변수에는 mrdoc (=01234) 문자로 표현된 5진법 수가 저장되어 있다.
//		이러한 두 수를 더하여서, gtaio luSnemf 문자로 표현된 13진법의 수로 나타내는 문제이다.
//
//		변수		진법체계			표현				10진법			5진법/13진법
//		---------------------------------------------------------------------------------------
//　	$FT_NBR1	'\"?!				\'?"\"'\			88926			10321201 (5)
//　	$FT_NBR2	mrdoc				rcrdmddd			145062			14120222 (5)
//		---------------------------------------------------------------------------------------
//		합산		gtaio luSnemf		Salut				233988			  82671 (13)
//																			24441423 (5)
//		export FT_NBR1="\\'?\"\\\"'\\"
//		export FT_NBR2="rcrdmddd"
//
//		echo "Obase=13; ibase=5; $FT_NBR1 + $FT_NBR2" | tr 'mrdoc' '01234' | tr "\'" "0" | tr '\\\"?!' '1234' | tr 'O' 'o' | bc | tr '0123456789ABC' 'gtaio luSnemf'
//
//		export FT_NBR1="\\\"\\\"!\\\"\\\"!\\\"\\\"!\\\"\\\"!\\\"\\\"!\\\"\\\""
//		export FT_NBR2="dcrcmcmooododmrrrmorcmcrmomo"
//

//!	 C00
void ft_putchar(char c) //　문자 하나를 찍어주는 함수
{
//	⁡⁢⁢⁢첫번째인자는 모드를 의미. (0은 입력모드, 1은 일반 출력모드, 2는 오류 출력모드)⁡
//	⁡⁢⁢⁢두번째인자는 주소를 의미. (메모리상에서 연속된 데이터의 위치)⁡
//	⁡⁢⁢⁢세번째인자의 바이트만큼, 주소에서부터 연속적으로 데이터를 읽어서 아스키코드로 출력⁡
		write(1, &c, 1);
}
void ft_print_alphabet(void) //　알파벳을 순서대로 출력하는 함수
{
//	⁡⁢⁢⁢문자열 리터럴은 자신만의 고유한 주소를 갖는다⁡
//	⁡⁢⁢⁢변수로 지정해서 붙잡아두지도 않았는데, 휘발되지도 않고 자신만의 고유한 주소를 갖는다⁡
//	⁡⁢⁢⁢맨땅에 근본없이 선언한 문자열이라도, 그것을 받아주는 변수가 없더라도, 컴파일 시간에 프로그램이 붙잡아서 주소를 부여한다⁡
		"세상의 중심에서 리터럴을 외치다";

//	⁡⁢⁢⁢문자열 리터럴은 메모리 상에서 고정된 주소를 가지는 연속된 데이터이기 때문에 인덱스를 이용한 참조가 가능하다.⁡
		"Hello World"[6];

//	⁡⁡⁢⁢⁢문자열 리터럴은 자기 자신의 주소를 리턴하기도 한다. (배열의 이름이 배열의 시작 주소를 가리키는 것처럼)⁡
//	⁡⁢⁢⁢⁡⁢⁢⁢마치, 큰 따옴표 자체가 주소를 리턴하는 연산자인 것마냥 비유할 수 있다.⁡
//	⁡⁢⁢⁢문자 자료형의 주소 변수는, 문자 자료형의 주소를 저장하거나 탐방하는 데 쓰인다. 주소 변수를 포인터라고 한다.⁡
//	⁡⁢⁢⁢문자 자료형의 주소 변수가 문자열 리터럴의 주소를 붙잡을 수 있다.⁡
		char *p;
		p = "Hello World";

//	⁡⁢⁢⁢write함수는 두번째 인자로 데이터의 주소를 받고, 세번째 인자의 바이트 만큼 데이터를 출력한다.⁡
//	⁡⁢⁢⁢문자열 리터럴은 그 자체로 자기 자신의 주소를 리턴하기 때문에, 그대로 사용해도 write함수가 특정해낼 수 있다.⁡
//	⁡⁢⁢⁢포인터에 인계시키는 과정을 생략해도 된다⁡
		write(1, p, 11);
		write(1, "abcdefghijklmnopqrstuvwxyz", 26);

}
void ft_print_reverse_alphabet(void) //　알파벳을 역순으로 출력하는 함수
{
	int i;
	i = 'z';
	while (i >= 'a')
	{
		write(1, &i, 1);
		i--;
	}
}
void ft_print_numbers(void) //　0~9를 오름차순으로 출력하는 함수
{
	write(1, "0123456789", 10);
}
void ft_is_negative(int n) //　양수와 음수를 구분하는 함수
{
	char flag;
	flag = 'P' - 2 * (n < 0); //음수에 대해서만 'P'의 아스키코드에 -2가 더해져서 'N'의 아스키코드가 됨

	write(1, &flag, 1);
}
void ft_print_comb(void) //　0~9로 이루어진 세자리 수 조합을, 오름차순으로 출력하는 함수
{
	char dec[4];	// 세자리 수이므로, 자릿값을 나타내기 위한 세자리의 배열을 사용함 (앞에서부터 첫번째 자리, 두번째 자리, 세번째 자리)
	dec[0] = '0' - 1; // 0번째 자리는 없지만, 자릿값을 초기화하는 양식을 통일하려고 임의로 값을 부여함

	dec[1] = dec[0] + 1; // 첫번째 자릿값을 '0' 으로 초기화
	while (dec[1] <= '7') // 조합의 최댓값이자 최종값은 789이므로, 첫번째 자리값은 '7' 이 한계임
	{

		dec[2] = dec[1] + 1; // 두번째 자릿값을 '1' 로 초기화. 이전 자릿값보다 크게끔. (같으면 중복, 작으면 No오름차순)
		while (dec[2] <= '8') // 순열의 최댓값이자 최종값은 789이므로, 두번째 자리값은 '8' 이 한계임
		{
								
			dec[3] = dec[2] + 1; // 셋번째 자릿값을 '2' 로 초기화. 이전 자릿값보다 크게끔.
			while (dec[3] <= '9') // 세번째 자리값은 '9'가 한계임. '2'에서 증가하다가 '9' 도달하면 while문 종료되고, 상위 while문은 한 단계 진척됨.
			{

				write(1, &dec[1], 3); // dec[1] ~ dec[3] 까지 한번에 찍어냄.
				if (dec[1] + dec[2] + dec[3] < '7' + '8' + '9')
					write(1, ", ", 2);  // dec[1] ~ dec[3] 이 각각 최대값인 경우는 마지막 조합이므로, 구두점을 생략함.

				dec[3]++;
			}
			dec[2]++; // 세번째 자릿값이 끝까지 차오르고 나서야, 비로소 두번째 자릿값이 증가하여, 자리올림 됨
		}
		dec[1]++;
	}
}
void ft_print_comb2(void) //　0~9로 이루어진 두자리 수 조합을, 오름차순으로, "00 00" 꼴로 출력하는 함수
{
	int dec[3];
	char temp[2];

	dec[1] = 0;
	while (dec[1] <= 98) // dec[1] <----- 0 ~ 98 까지 모든 수가 될 수 있음
	{
		dec[2] = dec[1] + 1;
		while (dec[2] <= 99) // dec[2] <----- 앞자리 수보다 크다는 조건하에, 1 ~ 99 까지 모든 수가 될 수 있음
		{
			temp[0] = dec[1] / 10 + '0';
			temp[1] = dec[1] % 10 + '0';
			write(1, temp, 2); // 10으로 나눈 몫을 10의 자리로 추출하고, 나머지를 1의 자리로 추출해서, 배열에 저장한 뒤 한번에 찍어냄
			write(1, " ", 1);
			temp[0] = dec[2] / 10 + '0';
			temp[1] = dec[2] % 10 + '0';
			write(1, temp, 2);
			if (dec[1] + dec[2] < 98 + 99) // while문의 상태가 최댓값으로 도달하면 구두점을 생략함.
				write(1, ", ", 2);
			dec[2]++;
		}
		dec[1]++;
	}
}
void ft_putnbr(int nb) //! 정수를 숫자문자열로 출력하는 함수
{
	char conv[10];
	char start;
	int i;

	if (nb == -2147483648)
		write(1, "-2147483648", 11);
	else
	{
		if (nb < 0)
		{
			write(1, "-", 1);
			nb = -nb;
		}
		i = 10;
		start = 9; // ⁡⁢⁢⁢출력의 시작위치를 9로 초기화하면, nb가 0일때 한번도 숫자를 못만나서 0000000000 출력되는 것을 방지⁡
		while (i--)
		{
			conv[i] = nb % 10 + '0';
			nb = nb / 10;
			if (conv[i] != '0') // ⁡⁢⁢⁢수가 몇 자린지 알아내기 (앞에서 어느 인덱스부터 숫자가 등장하는지)⁡
				start = i;
		}
		write(1, conv + start, 10 - start); // ⁡⁢⁢⁢숫자가 처음 나오는 시점에서부터, 말단까지 출력⁡
	}
}
void EXPLAIN_print_comb(int N) //: 0~9로 이루어진 N자리 수 조합을, 오름차순으로 출력하는 함수
{
	int K = 0;
	char dec[11];
	dec[0] = '0' - 1;

//	⁡⁢⁢⁢2중 while문 ---> 2자리 조합을 출력⁡
	dec[1] = dec[0] + 1;
	while (dec[1] <= '8')
	{
		dec[2] = dec[1] + 1;
		while (dec[2] <= '9') //말단 while
		{
			write(1, dec + 1, 2);
			write(1, ", ", 2);
			dec[2]++;
		}
		dec[1]++;
	}

//	⁡⁢⁢⁢3중 while문 ---> 3자리 조합을 출력⁡
	dec[1] = dec[0] + 1;
	while (dec[1] <= '7')
	{
		dec[2] = dec[1] + 1;
		while (dec[2] <= '8')
		{
			dec[3] = dec[2] + 1;
			while (dec[3] <= '9') //말단 while
			{
				write(1, dec + 1, 3);
				write(1, ", ", 2);
				dec[3]++;
			}
			dec[2]++;
		}
		dec[1]++;
	}

//	⁡⁢⁢⁢4중 while문 ---> 4자리 조합을 출력⁡
	dec[1] = dec[0] + 1;
	while (dec[1] <= '6')
	{
		dec[2] = dec[1] + 1;
		while (dec[2] <= '7')
		{
			dec[3] = dec[2] + 1;
			while (dec[3] <= '8')
			{
				dec[4] = dec[3] + 1;
				while (dec[4] <= '9') //말단 while
				{
					write(1, dec + 1, 4);
					write(1, ", ", 2);
					dec[4]++;
				}
				dec[3]++;
			}
			dec[2]++;
		}
		dec[1]++;
	}

//	⁡⁢⁢⁢N중 while문 ---> N자리 조합을 출력⁡
//	⁡⁣⁣⁢N중 while문에서, K번째 while의 구조는?⁡
//	⁡⁢⁢⁢K번째 while블럭은 K+1번째 while블럭을 소환하고, K+1번째는 K+2번째를, K+2번째는 K+3번째를 소환한다⁡
//	⁡⁢⁢⁢K, K+1, K+2 블럭이 소환되다가, 마지막에는 N번째 while문이 소환된다. (N자리 수니까)⁡
	dec[K] = dec[K - 1] + 1;					//<	(초기화) 왼쪽 자릿수보다 +1 큰 숫자부터 시작해서~
	while (dec[K] <= K + '9' - N)				//<	(최종값을 고려할때) 이 자리가 가질 수 있는 최대값까지만
	{
		dec[K + 1] = dec[K] + 1;
		while ("K+1번째 while문 소환!!");		//>	K+1번째 while문 소환!!
		dec[K]++;								//<	while문 카운트 주기적으로 상승
	}

//	⁡⁣⁣⁢N중 while문에서, 마지막 N번째 while의 구조는?⁡
//	⁡⁢⁢⁢1번째 블럭이 2번째 블럭을, 2번째 블럭이 3번째 블럭을, ..K번째 블럭이 K+1번째 블럭을 소환한다⁡
//	⁡⁢⁢⁢마지막 N번째 블럭은, 다음 블럭을 소환하지 않는다. decimal 배열을 통째로 출력한다.⁡
	dec[N] = dec[N - 1] + 1;					//<	(초기화) 왼쪽 자릿수보다 +1 큰 숫자부터 시작해서~
	while (dec[N] <= K + '9' - N)				//<	(최종값을 고려할때) 이 자리가 가질 수 있는 최대값까지만
	{
		write(1, dec + 1, N);					//>	조합은 N자리의 숫자이므로 N바이트 찍어준다
		write(1, ", ", 2);						//>	새로운 항을 콤마와 띄어쓰기로 구분
		dec[N]++;								//<	while문 카운트 주기적으로 상승
	}
}
void ft_kth_while(int K, int N, char *dec) //: K번째 while문을 생성하는 함수
{
	dec[K] = dec[K - 1] + 1;						  //<	(초기화) 왼쪽 자릿수보다 +1 큰 숫자부터 시작해서~
	while (dec[K] <= K + '9' - N)					  //<	(최종값을 고려할때) 이 자리가 가질 수 있는 최대값까지만
	{	
		if (K != N)
			ft_kth_while(K + 1, N, dec);			  //>	K+1번째 while문 소환!!
		if (K == N)
		{											  //>	보통은 다음 while문을 소환하지만, 말단에서는 다르다
			write(1, dec + 1, N);					  //>	조합은 총 N자리 문자열이므로 N바이트 찍어준다
			if (dec[1] + dec[N] != (1 + '9' - N) + '9') //>	새로운 항을 콤마와 띄어쓰기로 구분
				write(1, ", ", 2);					  //	첫째와 마지막 자리가 최대로 최종값 도달시, 구분기호 출력 중단
		}
		dec[K]++;									  //<	while문 카운트 주기적으로 상승
	}
}
void ft_print_combn(int n) //　0~9로 이루어진 세자리 수 조합을, 오름차순으로 출력하는 함수
{
	char dec[11];
	dec[0] = '0' - 1;

	ft_kth_while(1, n, dec); //　1번째 while문을 소환
}

//!  C01
void ft_ft(int *nbr) //　int의 주소를 받아서, 원본 int변수에 42를 할당하는 함수
{
//		⁡⁢⁢⁢변수를 선언하면, 컴퓨터의 메모리 트랜지스터 어딘가에 a라는 장소가 확보되고, 77이라는 값을 박아넣는다.⁡
//			⁡⁢⁢⁣int a = 77;⁡
//		⁡⁢⁢⁢모든 변수는 자기만의 주소를 갖는다. 주소는 어마어마하게 거대한 양수이다.⁡
//		⁡⁢⁢⁢메모리의 크기가 8GB 16GB 32GB 으로 거대하기 때문에, 주소도 거대한 값을 갖는다.⁡
//			⁡⁢⁢⁣printf("%p\n", &a);⁡
//			⁡⁢⁢⁣printf("%lld", (long long) &a);⁡
//		⁡⁢⁢⁢140731412403148 번지가 출력되는데, 여기가 바로 변수 a가 거주하는 집이다.⁡
//		⁡⁢⁢⁢주소에다가 별 기호를 사용하면, 주소에 보관되어 있는 내용에 접근할 수 있다.⁡
//			⁡⁢⁢⁣*( &a )⁡
//			⁡⁢⁢⁣*( a의 주소 )⁡
//			⁡⁢⁢⁣*( 140731412403148 번지 )⁡
//		⁡⁢⁢⁢별 기호를 통해서 값을 출력하거나, 변경할 수 있다.⁡
//			⁡⁢⁢⁣int a = 77;⁡
//			⁡⁢⁢⁣printf(  "%d",  *( &a )  );⁡
//			⁡⁢⁢⁣*( &a ) = 42;⁡
//			⁡⁢⁢⁣printf(  "%d",  *( &a )  );⁡
//		⁡⁢⁢⁢포인터는, 원본의 주소를 기억해두었다가 원본에 접근하려는 목적을 가진다.⁡
//		⁡⁢⁢⁢주소라고하는 그 어마어마하게 거대한 숫자를 포인터가 기억한다.⁡
//			⁡⁢⁢⁣int *p;⁡
//			⁡⁢⁢⁣p = &a;⁡
//		⁡⁢⁢⁢p라는 변수가 우리집 주소 (&a) 를 기억하고 있으므로,⁡
//		⁡⁢⁢⁢*p = 42 라는 표현은, 우리집 주소 140731412403148 번지에 찾아가서 42를 보관한다는 의미이다.⁡
//			⁡⁢⁢⁣*p = 42;⁡
//		⁡⁢⁢⁢포인터에 42를 대입한다면, 14073141203148 번지에 42 라는 내용을 변경하는게 아니라, "42번지" 를 저장하게 된는다.⁡
//		⁡⁢⁢⁢엄청나게 거대한 메모리 주소에서 14073141203148 번지가 아닌, 애먼 주소인 42번지를 의미하게 된다. (컵밥을 보관 vs 컵밥이라는 거리로 이동)⁡
//			⁡⁢⁢⁣p = 42;⁡
//
//		⁡⁢⁢⁢ft_ft 함수는, 원본의 주소를 이용해서 원본에 접근하려는 목적을 가진다.⁡
//		⁡⁢⁢⁢ft_ft 함수의 인자에 주소에 전달하면, 그 주소를 nbr이라는 포인터가 포착한다.⁡
//			⁡⁢⁢⁣nbr = &a⁡
//		⁡⁢⁢⁢선언문에 쓰이는 별과(*) 평문에서 쓰이는 별은(*) 모양만 똑같고 완전히 다른 의미를 갖는다.⁡
//		⁡⁢⁢⁢선언에서 쓰이는 별은, 포인터 선언을 의미한다. 주소를 기억하는 용도로 선언한다는 뜻이다.⁡
//		⁡⁢⁢⁢평문에서 쓰이는 별은, 주소가 가리키는 내용을 의미한다.⁡
//			⁡⁢⁢⁣int *nbr⁡
//			⁡⁢⁢⁣*nbr = 42⁡
//		⁡⁢⁢⁢nbr = 42 를 하면, 원본 변수의 값이 42로 바뀌는 것이 아니라, 42번지라고 하는 외딴 장소로 이동해버린다.⁡
//		⁡⁢⁢⁢우리가 원하는 것은, 원본 변수의 값을 42로 바꾸는 것이므로, 주소 앞에 *을 붙여서 해당 주소의 [내용] 에 접근해야한다.⁡
//
	*nbr = 42;
}
void ft_ultimate_ft(int *********nbr) //! 정수의 포인터의 포인터의 포인터의.. 포인터를 매개변수로 받고, 원본 정수에 값 "42"를 설정하는 함수
{
//		변수		접근방법		값
//		j			nbr				&i
//		i			*nbr			&h
//		h			**nbr			&g
//		g			***nbr			&f
//		f			****nbr			&e
//		e			*****nbr		&d
//		d			******nbr		&c
//		c			*******nbr		&b
//		b			********nbr		&a
//		a			*********nbr	77
	*********nbr = 42;
}
void ft_swap(int *a, int *b) //　주소가 매개변수로 입력된 두 정수의 값을 교환하는 함수
{
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}
void ft_div_mod(int a, int b, int *div, int *mod) //　a와 b의 나눗셈. div가 가리키는 int에 몫을 저장, mod가 가리키는 int에 나머지를 저장
{

//div = a/b; //&resA = a/b  주소라는 것은 16진수로 이루어진 어떤 기괴한 숫자일텐데, 그런 숫자 대신에 a/b라는 평범한 숫자를 넣겠는다는 의미가 됨
	*div = a / b; //resA = a/b   주소에는 앞에 *를 붙여줘야지 비로소 그 주소가 가리키는 변수에 값을 할당할 수 있게 됨
	*mod = a % b; //	 	 	 	선언할때 사용하는 *은 포인터로 선언하겠다는 의미이고, 식에 쓰일 때에는 '주소에 보관된 값' 을 사용하겠다는 의미
}
void ft_ultimate_div_mod(int *a, int *b) //! a와 b의 나눗셈. a가 가리키는 int에 몫을 저장, b가 가리키는 int에 나머지를 저장
{
	int div;
	int mod;

	div = *a / *b;
	mod = *a % *b;

	*a = div;
	*b = mod;
}
void ft_putstr(char *str) //　표준 출력에 문자열을 표시하는 함수
{
	int i;
	i = 0;

	while (str[i] != '\0')
	{
		write(1, &str[i], 1);
		i++;
	}
}
int ft_strlen(char *str) //　문자열의 문자 수를 세고 리턴하는 함수 (문자열 길이) >널문자 제외
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		i++;
	}
	return i;
}
void ft_rev_int_tab(int *tab, int size) //! 정수의 배열을 거꾸로 뒤집는 함수. int의 포인터와 배열의 사이즈가 주어짐.
{
	int i;
	int tmp;

	i = 0;
	while (i < size / 2)
	{
		tmp = tab[i];
		tab[i] = tab[size - 1 - i];
		tab[size - 1 - i] = tmp;
		i++;
	}
}
void ft_sort_int_tab(int *tab, int size) //! 정수의 배열을 오름차순으로 정렬하는 함수. 배열의 주소와 사이즈가 주어짐.
{
//! 버블 정렬 과정 (여러 차례의 비교 웨이브)
///		 ⁡⁢⁣⁣4	1	0	9	7	2		sorted = 1; 해놓고 드가자!!   (웨이브 1)⁡
///		⁡⁢⁢⁢[4	1]	0	9	7	2⁡
///		⁡⁢⁢⁣[1	4]	0	9	7	2		정렬 안됐네.. sorted = 0;⁡
///		 ⁡⁢⁢⁢1	[4	0]	9	7	2⁡
///		 ⁡⁢⁢⁢1	[0	4]	9	7	2⁡
///		 ⁡⁢⁢⁢1	0	[4	9]	7	2⁡
///		 ⁡⁢⁢⁢1	0	[4	9]	7	2⁡
///		 ⁡⁢⁢⁢1	0	4	[9	7]	2⁡
///		 ⁡⁢⁢⁢1	0	4	[7	9]	2⁡
///		 ⁡⁢⁢⁢1	0	4	7	[9	2]⁡
///		 ⁡⁢⁢⁢1	0	4	7	[2	9]⁡
//		 ⁡⁢⁣⁣1	0	4	7	2	9		sorted = 1; 해놓고 드가자!!   (웨이브 2)⁡
//		⁡⁢⁢⁢[1	0]	4	7	2	9⁡
//		⁡⁢⁢⁣[0	1]	4	7	2	9		정렬 안됐네.. sorted = 0;⁡
//		 ⁡⁢⁢⁢0	[1	4]	7	2	9⁡
//		 ⁡⁢⁢⁢0	[1	4]	7	2	9⁡
//		 ⁡⁢⁢⁢0	1	[4	7]	2	9⁡
//		 ⁡⁢⁢⁢0	1	[4	7]	2	9⁡
//		 ⁡⁢⁢⁢0	1	4	[7	2]	9⁡
//		 ⁡⁢⁢⁢0	1	4	[2	7]	9⁡
//		 ⁡⁢⁢⁢0	1	4	2	[7	9]⁡
//		 ⁡⁢⁢⁢0	1	4	2	[7	9]⁡
///		 ⁡⁢⁣⁣0	1	4	2	7	9		sorted = 1; 해놓고 드가자!!   (웨이브 3)⁡
///		⁡⁢⁢⁢[0	1]	4	2	7	9⁡
///		⁡⁢⁢⁢[0	1]	4	2	7	9⁡
///		 ⁡⁢⁢⁢0	[1	4]	2	7	9⁡
///		 ⁡⁢⁢⁢0	[1	4]	2	7	9⁡
///		 ⁡⁢⁢⁣0	1	[4	2]	7	9		정렬 안됐네.. sorted = 0;⁡
///		 ⁡⁢⁢⁢0	1	[2	4]	7	9⁡
///		 ⁡⁢⁢⁢0	1	2	[4	7]	9⁡
///		 ⁡⁢⁢⁢0	1	2	[4	7]	9⁡
///		 ⁡⁢⁢⁢0	1	2	4	[7	9]⁡
///		 ⁡⁢⁢⁢0	1	2	4	[7	9]⁡
//		 ⁡⁢⁣⁣0	1	2	4	7	9		sorted = 1; 해놓고 드가자!!   (웨이브 4)⁡
//		⁡⁢⁢⁢[0	1]	2	4	7	9⁡
//		⁡⁢⁢⁢[0	1]	2	4	7	9⁡
//		 ⁡⁢⁢⁢0	[1	2]	4	7	9⁡
//		 ⁡⁢⁢⁢0	[1	2]	4	7	9⁡
//		 ⁡⁢⁢⁢0	1	[2	4]	7	9⁡
//		 ⁡⁢⁢⁢0	1	[2	4]	7	9⁡
//		 ⁡⁢⁢⁢0	1	2	[4	7]	9⁡
//		 ⁡⁢⁢⁢0	1	2	[4	7]	9⁡
//		 ⁡⁢⁢⁢0	1	2	4	[7	9]⁡
//		 ⁡⁢⁢⁢0	1	2	4	[7	9]		⁡⁣⁡⁣⁣⁢마지막까지 여전히 sorted == 1 이네? 더 이상 정렬할 필요가 없군!⁡

	int i;
	int sorted;

	sorted = 0;
	while (sorted == 0) //! 버블 정렬은 여러 차례의 비교 웨이브를 갖는다
	{
		sorted = 1; //> 이번이 마지막 웨이브이기를 기도하며 1을 설정함
		i = 0;
		while (i < size - 1) //: 한 차례의 비교 웨이브
		{
			if (tab[i] > tab[i + 1])
			{
				ft_swap(&tab[i], &tab[i + 1]);	//　이번 웨이브에서 스왑했다면, 배열이 정렬되지 않았을 수 있다
				sorted = 0;						//　sorted = 0 으로 남기므로써, 다음 웨이브를 예약
			}
			i++;
		}
	}
}

//!  C02
char *ft_strcpy(char *dest, char *src) //　NULL문자만큼 문자열을 복사하는 함수. 복사본의 주소를 리턴.
{
//	⁡⁢⁣⁣strcpy의 작동⁡
//	⁡⁢⁢⁡⁢⁢⁢src를 통째로 dest에 복사한다.⁡
//	⁡⁢⁢⁢dest가 src보다 길다면, src의 NULL 문자까지 복사해오기 때문에 dest는 src와 같은 길이가 된다⁡
//	⁡⁢⁢⁢dest가 src보다 짧으면, src의 NULL 문자까지 복사해오지 못해서 dest는 널문자를 잃어버리고 경계가 사라져 메모리 침범에 취약해진다⁡
//	⁡⁢⁢⁢dest가 src보다 짧으면, 버퍼 오버플로우가 발생한다. 무조건 실행 오류로 종료되거나 하지는 않는다⁡
//	⁡⁢⁢⁢src의 부분 문자열을 dest가 다 가져가서 dest는 NULL이 없는 문자열이되고 나머지 데이터는 엉뚱한 참조(메모리)가 가져가는 것으로 strcpy의 실행이 완료된다⁡
//	⁡⁢⁢⁢복사본의 주소를 리턴한다.⁡

	int i;

	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0'; //` 널을 찍기는 찍지만, 정말로 dest에 찍힐지는 장담할 수 없다
	return dest;
}
char *ft_strncpy(char *dest, char *src, unsigned int n) //　N자리만큼 문자열을 복사하는 함수. 복사본의 주소를 리턴.
{
//	⁡⁢⁣⁣strncpy의 작동⁡
//	⁡⁢⁢⁢src를 길이 n만큼 dest에 복사한다.⁡
//	⁡⁢⁢⁢src가 n미만이면, dest에 src가 온전하게 복사되고, 남은 분량은 NULL 문자를 채운다. dest는 src와 같은 길이가 된다⁡
//	⁡⁢⁢⁢src가 n이상이면, src의 NULL 문자가 복사되지 않아서 dest는 처음 길이를 그대로 가진다. 복사된 데이터 이후에는 기존의 데이터가 뒤따른다.⁡
//	⁡⁢⁢⁢복사본의 주소를 리턴한다.⁡

	unsigned int i;

	i = 0;
	while (src[i] != '\0' && i < n)
	{
		dest[i] = src[i];
		i++;
	}
	while (i < n)
	{
		dest[i] = '\0';
		i++;
	}
	return dest;
}
unsigned int ft_strlcpy(char *dest, char *src, unsigned int size) //　N-1 길이만큼 문자열을 복사하고, 남은 한 자리는 NULL을 넣는 함수. src의 길이를 리턴.
{
//	⁡⁢⁣⁣⁡⁢⁣⁣strlcpy의 작동⁡
//	⁡⁢⁢⁢src를 길이 n-1 만큼 dest에 복사하고, 쟁여둔 한 자리에 널을 채운다.⁡
//	⁡⁢⁢⁢src가 n미만이면, dest에 src가 온전하게 복사되고, 남은 분량은 NULL 문자를 채운다. dest는 src와 같은 길이가 된다⁡
//	⁡⁢⁢⁢src가 n이상이면, dest에 src가 n-1 만큼 복사되고, 쟁여둔 한 자리에 널을 채운다. 이후의 dest는 짤린다.⁡
//	⁡⁢⁢⁢src의 길이를 리턴한다.⁡

	unsigned int n;
	unsigned int i;

	n = size;
	if (n == 0)
		return (ft_strlen(src)); //　사이즈가 0이면 바로 리턴

	i = 0;
	while (src[i] != '\0' && i + 1 < n) //　다른 cpy와는 다르게, 일부러 하나 빼먹은 만큼만 복사한다
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';	//　쟁여둔 자리 하나에는 널문자를 넣는다. src 길이가 size 보다 작다면 
	return (ft_strlen(src));
}
int ft_str_is_alpha(char *str) 		//　문자열에 알파벳만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('A' <= str[i] && str[i] <= 'Z') && !('a' <= str[i] && str[i] <= 'z'))
			return 0;
		i++;
	}

	return 1;
}
int ft_str_is_numeric(char *str) 	//　문자열에 숫자만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('0' <= str[i] && str[i] <= '9'))
			return 0;
		i++;
	}
	return 1;
}
int ft_str_is_lowercase(char *str) 	//　문자열에 소문자 알파벳만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('a' <= str[i] && str[i] <= 'z'))
			return 0;
		i++;
	}
	return 1;
}
int ft_str_is_uppercase(char *str) 	//　문자열에 대문자 알파벳만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!('A' <= str[i] && str[i] <= 'Z'))
			return 0;
		i++;
	}
	return 1;
}
int ft_str_is_printable(char *str) 	//　문자열에 출력가능 문자만 존재하면 1을, 다른 문자도 포함되면 0을 리턴하는 함수. 비어있으면 1을 리턴.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if (!(32 <= str[i] && str[i] <= 126))
			return 0;
		i++;
	}
	return 1;
}
char *ft_strupcase(char *str) 		//　모든 소문자를 대문자로 변경하여 리턴하는 함수. 수정된 str을 반환.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if ('a' <= str[i] && str[i] <= 'z')
			str[i] = str[i] - 32;
		i++;
	}
	return str;
}
char *ft_strlowcase(char *str) 		//　모든 대문자를 소문자로 변경하여 리턴하는 함수. 수정된 str을 반환.
{
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		if ('A' <= str[i] && str[i] <= 'Z')
			str[i] = str[i] + 32;
		i++;
	}
	return str;
}
int ft_is_word(char c) 				//: 주어진 문자가 '영숫자' 이면 1을, '영숫자' 가 아니라면 0을 리턴하는 함수.
{
	int d;
	d = ('A' <= c & c <= 'Z') | ('a' <= c & c <= 'z') | ('0' <= c & c <= '9');
	return (d);
}
char *ft_strcapitalize(char *str) 	//　연속된 영숫자를 단어라고 할때, 단어의 첫글자는 대문자로, 나머지는 소문자로 변환하여 리턴하는 함수. 수정된 str을 반환.
{
//　	숫자 또는 알파벳 문자를	'영숫자' 라고 한다
//　	영숫자가 연속되는 것을	'단어' 라고 한다
//　	영숫자 아닌 모든 문자를	'공백' 이라고 한다 (, ?-;+" 등등)
//
//>		"salut, comment tu vas ? 42mots quarante-deux; cinquante+et+un"
//>		"Salut, Comment Tu Vas ? 42mots Quarante-Deux; Cinquante+Et+Un"
//　	단어의 첫글자는 대문자, 나머지는 소문자로 변환
//
//　	현재 문자가 영숫자가 아니라면 그대로 자신을 리턴
//　	현재 문자가 영숫자이면서 문자열의 첫번째이면 대문자로 변경
//　	현재 문자가 영숫자이면서 '공백'이 앞에 있으면 대문자로 변경
//　	현재 문자가 영숫자이면서 영숫자가 앞에 있으면 소문자로 변경

	int i;
	char *now;

	i = 0;
	while (str[i] != '\0')
	{
		now = &str[i];
		if (ft_is_word(*now)) //현재 문자가 영숫자이면서
		{
			if (i == 0) //문자열의 첫번째 ---> 대문자
				ft_strupcase(now);
			else if (!ft_is_word(str[i - 1])) //공백이 앞에 있음 ---> 대문자
				ft_strupcase(now);
			else if (ft_is_word(str[i - 1])) //영숫자가 앞에 있음 ---> 소문자
				ft_strlowcase(now);
		}
		i++;
	}
	return str;
}
char *ft_strcapitalize2(char *str)	//　다른 방법
{
	int	i;
	int	zinif;

	zinif = 0;
	i = 0;
	while (str[i])
	{
		if (('0' <= str[i] && str[i] <= '9')
			|| ('a' <= str[i] && str[i] <= 'z')
			|| ('A' <= str[i] && str[i] <= 'Z'))
		{
			if (zinif == 0)
			{
				if ('a' <= str[i] && str[i] <= 'z')
					str[i] = str[i] - 32;
			}
			else if ('A' <= str[i] && str[i] <= 'Z')
				str[i] = str[i] + 32;
			zinif = 1;
		}
		else
			zinif = 0;
		i++;
	}
	return (str);
}
void ft_putstr_non_printable(char *str) //　문자열을 출력하는 함수. 출력불가 문자는 백슬래시와 함께 16진수(소문자) 모양으로 표시함.
{
//Coucou\ntu vas bien ?	//:   아스키코드 10번은 개행 문자 \n이고, 출력불가 문자
//Coucou\0atu vas bien ?   //:   10을 두자리 16진수로 바꿔서 \0a 모양으로 출력함
	unsigned char bf;
	char *hex;
	hex = "0123456789abcdef";
	int i;
	i = 0;
	while (str[i] != '\0')
	{
		bf = (unsigned char)str[i];
		if (32 <= bf && bf <= 126) //확장아스키도 자신만의 출력 모양이 있지만, printable이 아니라고 정해서 미포함
			write(1, &bf, 1);		 //printable은 그냥 그대로 출력하고, printable이 아니라면 변형해서 출력
		else
		{
			write(1, "\\", 1);
			write(1, &hex[bf / 16], 1);
			write(1, &hex[bf % 16], 1);
		}
		i++;
	}
}
void ft_put_address(unsigned long long bit64) //: '주소' 라는 64비트 정수를 16진수 16자리로 출력하는 함수
{
	char *dict;
	char conv[16];
	int i;

	dict = "0123456789abcdef";
	i = 16;
	while (i--)
	{
		conv[i] = dict[bit64 % 16];
		bit64 = bit64 / 16;
	}
	write(1, conv, 16);
}
void ft_put_contents_in_hex(unsigned char *str, int size) //: 메모리에 담긴 내용을 16진수로 출력하는 함수
{
//　"ACCURATE"					"ACCURATE"
//　^							  ^
//　65 / 16 == 4				 67 / 16 == 4
//　65 % 16 == 1				 67 % 16 == 3
	char *dict;
	char digit[2];
	int i;

	dict = "0123456789abcdef";
	i = 1;
	while (i <= size)
	{
		digit[0] = dict[*str / 16];
		digit[1] = dict[*str % 16];
		write(1, digit, 2);
		if (i % 2 == 0)
			write(1, " ", 1);
		str++;
		i++; //　while문이 종료됐을때, i의 상태는 size+1
	}
	while (i <= 16)
	{
		write(1, "  ", 2); //　위의 로직에서 digit 두개가 공백이었다고 상상하기
		if (i % 2 == 0)
			write(1, " ", 1);
		i++;
	}
}
void ft_write(char *str, int size) 	//: 출력불가 문자까지 온점으로 출력하는, 확장 write 함수
{
	int i;
	i = 0;
	while (i < size)
	{
		if (32 <= str[i] && str[i] <= 126)
			write(1, &str[i], 1);
		else
			write(1, ".", 1);
		i++;
	}
}
void *ft_print_memory(void *addr, unsigned int size) //　메모리 영역을 출력하는 함수.
{
//: 각 라인은 세개의 구간으로 나뉘어져 있음.
//: 1.  메모리 주소. 16진수로 나타냄.
//: 2.  메모리 내용. 16진수로 나타냄. 내용 두개가 하나로 짝지어져 표시되고, 공백으로 구분.
//: 3.  메모리 내용. 출력불가 문자는 점으로 대체함. 16글자를 한 줄에 다름.
//: size는 총 문자의 갯수이며, 0이면 아무것도 표시하지 않음
//< $> ./ft_print_memory | cat -te
//< 0000000107ff9f40: 426f 6e6a 6f75 7220 6c65 7320 616d 696e Bonjour les amin$
//< 0000000107ff9f50: 6368 6573 090a 0963 0720 6573 7420 666f ches...c. est fo$
//< 0000000107ff9f60: 7509 746f 7574 0963 6520 7175 206f 6e20 u.tout.ce qu on $
//< 0000000107ff9f70: 7065 7574 2066 6169 7265 2061 7665 6309 peut faire avec.$
//< 0000000107ff9f80: 0a09 7072 696e 745f 6d65 6d6f 7279 0a0a ..print_memory..$
//< 0000000107ff9f90: 0a09 6c6f 6c2e 6c6f 6c0a 2000           ..lol.lol. .$
//< $>
	void *rewind;
	int line;

	rewind = addr;
	line = size / 16;
	while (line--)
	{
		ft_put_address((unsigned long long)addr);
		write(1, ": ", 2);
		ft_put_contents_in_hex((unsigned char *)addr, 16);
		ft_write(addr, 16);
		write(1, "\n", 1);
		addr += 16;
	}
	if (size % 16 > 0)
	{
		ft_put_address((unsigned long long)addr);
		write(1, ": ", 2);
		ft_put_contents_in_hex((unsigned char *)addr, size % 16);
		ft_write(addr, size % 16);
		write(1, "\n", 1);
	}
	return rewind;
}

//!	 C03
int ft_strcmp(char *s1, char *s2) //　두 문자열을 비교하는 함수. 문자열이 완전히 일치하면 0을 리턴하고, 어긋나면 사전순으로 앞서는 쪽을 알려줌.
{
//　dragonfly0️⃣	dragon0️⃣		dragonfly0️⃣	dragonfly0️⃣	dragonfly0️⃣	dragon0️⃣	0️⃣
//　dragonfly0️⃣	dragonball0️⃣	dragonball0️⃣	dragon0️⃣		ball0️⃣			0️⃣ 		0️⃣
	unsigned int i;

	// i = 0;
	// while (s2[i] != '\0' && s1[i] == s2[i])
	// 	i++;
	// return s1[i] - s2[i];


	i=0;
	while (s1[i] != '\0' || s2[i] != '\0')
	{
		if (s1[i] != s2[i])
			break;
		i++;
	}
	return s1[i] - s2[i];
//	아스키 사전 상에서 왼쪽이 빠르다면 (왼쪽이 작다면) 음수를 리턴
//	아스키 사전 상에서 오른쪽이 빠르면 (오른이 작다면) 양수를 리턴
//	문자열이 동일하다면 0을 리턴
}
int ft_strncmp(char *s1, char *s2, unsigned int n) //　두 문자열을 비교하는 함수. 일치하면 0을 리턴. 사전순으로 앞서는 쪽를 알려줌. 앞에서 N자리 만큼만 비교함.
{
//　dragonfly0️⃣	dragon0️⃣		dragonfly0️⃣	dragonfly0️⃣	dragonfly0️⃣	dragon0️⃣	0️⃣
//　dragonfly0️⃣	dragonball0️⃣	dragonball0️⃣	dragon0️⃣		ball0️⃣			0️⃣ 		0️⃣
	unsigned int i;

	// i = 0;
	// while (s2[i] != '\0' && s1[i] == s2[i])
	// 	i++;
	// if (i >= n)
	// 	return 0;
	// return (s1[i] - s2[i]);


	i=0;
	while (s1[i] != '\0' || s2[i] != '\0')
	{
		if (i >= n)
			return 0;
		if (s1[i] != s2[i])
			break;
		i++;
	}
	return s1[i] - s2[i];
//	아스키 사전에서 왼쪽이 빠르다면 (왼쪽이 작다면) 음수를 리턴
//	아스키 사전에서 오른쪽이 빠르면 (오른이 작다면) 양수를 리턴
//	문자열이 동일하다면 0을 리턴
}
char *ft_strcat(char *dest, char *src) //　두 문자열을 연결하는 함수. 받아주는쪽 문자열의 널문자부터 시작해서 주는쪽을 전부 이어붙이고 널문자로 마무리. 합본을 리턴.
{
//:  dest에 할당된 capacity는 정해져있다. 받는쪽과 주는쪽 문자열의 length를 합해도 capacity를 넘지않아야한다
	int i;
	int begin_of_null; // 처음 dest 길이

	i = 0;
	while (dest[i] != '\0')
		i++;
	begin_of_null = i; //dest[ begin_of_null ] 에는 널이 들어있음

	i = 0;
	while (src[i] != '\0')
	{
		dest[begin_of_null + i] = src[i]; //dest의 널자리부터 src의 모든 원소를 채우기 시작함
		i++;
	}
	dest[begin_of_null + i] = '\0'; //끝자리에 널문자를 박어주므로써 문자열의 경계를 부여함 (널-터미네이트)

	return dest;
}
char *ft_strncat(char *dest, char *src, unsigned int nb) //　두 문자열을 연결하는 함수. N자리 만큼 복사, 받아주는쪽 널문자 자리부터 붙여넣음. 널문자로 마무리.
{
//:  cpy함수는 앞에서부터 데이터를 붙여넣고(복사하고), cat함수는 빈공간에서부터 데이터를 붙여넣는다(복사한다)
	int i;
	int begin_of_null; // 처음 dest 길이

	i = 0;
	while (dest[i] != '\0')
		i++;
	begin_of_null = i; //dest[ begin_of_null ] 위치에는 널이 들어있음

	i = 0;
	while (nb && src[i] != '\0')
	{
		dest[begin_of_null + i] = src[i]; //dest의 널자리부터 src의 모든 원소를 채우기 시작함
		i++;
		nb--;
	}
	dest[begin_of_null + i] = '\0'; //끝자리에 널문자를 박아주므로써 문자열의 경계를 부여함 (널-터미네이트)

	return dest;
}
unsigned int ft_strlcat(char *dest, char *src, unsigned int size) //　두 문자열을 연결하는 함수.
{
//!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
//>  [ ===================================SIZE====================================== ]	기준 size
//:  [ <-----------len(dst)------------>0=========================================== ]	len(dest) < SIZE - 1
//　 [ <-----------len(dst)------------><-----len_src----->0======================== ]	적재: size한도내에서 dst가 채워진 분량을 제외한만큼 src를 채움
//　 [ <-----------len(dst)------------><------------len_src---------->0============ ]	적재
//　 [ <-----------len(dst)------------><------------len_src---------------------->0 ]	적재: 딱맞는 경우
//　 [ <-----------len(dst)------------><------------------------------------len_sr0 ]	적재: 한도를 초과한다면 src의 일부만 채움 (SIZE - len(dst) - 1 개)
//<  [ <-----------len(dst)------------><-----len_src----->========================= ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
//<  [ <-----------len(dst)------------><------------len_src---------->============= ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
//<  [ <-----------len(dst)------------><------------len_src---------------------->= ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 = 0, 꽉찬 상태)
//<  [ <-----------len(dst)------------><------------------------------------len_src ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
//
//!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
//>  [ ===================================SIZE====================================== ]	기준 size
//:  [ <--------------------------------len(dst)---------------------------------->0 ]	len(dest) = SIZE - 1
//　 [ <--------------------------------len(dst)---------------------------------->0 ]	적재: 한도를 초과하여 src를 채울 수 없음
//<  [ <--------------------------------len(dst)---------------------------------->0 ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
//
//!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
//>  [ ==================SIZE=====================---------------------------------- ]	기준 size
//:  [ <------len(dst)------->0===================---------------------------------> ]	len(dest) < SIZE - 1
//　 [ <------len(dst)-------><--len_src-->0======---------------------------------> ]	적재: size한도내에서 dst가 채워진 분량을 제외한만큼 src를 채움
//　 [ <------len(dst)-------><---len_src--->0====---------------------------------> ]	적재
//　 [ <------len(dst)-------><-----len_src----->0---------------------------------> ]	적재: 딱맞는 경우
//　 [ <------len(dst)-------><------------len_sr0---------------------------------> ]	적재: 한도를 초과한다면 (널문자부터 확보하고) src의 일부만 채움 (SIZE -len(dst) -1 개)
//<  [ <------len(dst)-------><--len_src-->=======---------------------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
//<  [ <------len(dst)-------><---len_src--->=====---------------------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 > 0, 남은 용량)
//<  [ <------len(dst)-------><-----len_src----->=---------------------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 = 0, 꽉찬 상태)
//<  [ <------len(dst)-------><------------len_src---------->----------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
//
//!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
//>  [ ==================SIZE=====================---------------------------------- ]	기준 size
//:  [ <------len(dst)-------------------------->0---------------------------------> ]	len(dest) = SIZE - 1
//　 [ <------len(dst)-------------------------->0---------------------------------> ]	적재: 한도를 초과하여 src를 채울 수 없음 (SIZE -len(dst) -1 == 0개)
//　 [ <------len(dst)-------------------------->0---------------------------------> ]	적재
//<  [ <------len(dst)--------------------------><--len_src-->---------------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
//<  [ <------len(dst)--------------------------><-----len_src----->---------------> ]	리턴값 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
//
//!  [ ----------------------------------capacity----------------------------------- ]	dest 배열의 용량 (최대 수용 공간)
//>  [ ==================SIZE=====================---------------------------------- ]	기준 size
//:  [ <------len(dst)---------------------------------->0-------------------------> ]	len(dest) > SIZE - 1     불가능한 사이즈
//　 [ <------len(dst)---------------------------------->0-------------------------> ]	적재: 한도를 초과하여 src를 채울 수 없음
//　 [ <------len(dst)---------------------------------->0-------------------------> ]	적재
//　 [ <------len(dst)---------------------------------->0-------------------------> ]	적재
//<  [ <------len(dst)----------------------------------><--len_src-->-------------> ]	평소면 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
//<  [ <------len(dst)----------------------------------><-----len_src----->-------> ]	평소면 == dst길이 + src길이  (size - 리턴값 - 1 < 0, 부족한 용량)
//&  [ ==================SIZE=====================<--len_src-->--------------------> ]	리턴값 == SIZE + src길이  (size -리턴값 - 1 = src 길이 +1 < 0)
//&  [ ==================SIZE=====================<-----len_src----->--------------> ]	리턴값 == SIZE + src길이  (size -리턴값 - 1 = src 길이 +1 < 0)

//!  리턴값의 해석 (뇌피셜)
//:  일반적으로, dst길이 + src길이를 리턴한다.
//:  리턴값의 응용1  [ 리턴값 - src길이 ] == src의 시작 위치
//src가 시작하는 위치는 오직 이 순간에만 기록할 수 있다. "abeeebeee" 에서 어느 beee가 src인가? 하는 식으로 판정할 수 없다. 기록하지 않으면 나중에 src만 찾아볼 수 없다.
//리턴값을 시작점으로, 보존된 만큼 src를 출력하는데 쓰일 수 있다. 보존된게 있다면 보존된 만큼을, 없다면 ""를 출력할 수 있다.
//:  리턴값의 응용2  [ size - 리턴값 - 1 ]
//0이상이면 남은 공간을 의미하며, src가 잘리지 않았다는 것을 알 수 있다.
//0미만이면 남은 공간이 음수로서, 부족한 용량을 의미하며, src가 얼마나 잘렸는지 알 수 있다.
//:  불가능한 size를 전달받은 경우에는 [ SIZE + src길이 ] 를 리턴한다.
//	  (src의 길이 + 1) 만큼이 음수로 주어져서, 널문자까지 확보해서 src가 들어가기에 모자란 공간을 알려준다.

//:  총 size개 만큼을 dest에다가 저장하는데, 그 중의 한 개는 반드시 널 문자.

	unsigned int i;
	unsigned int begin_of_null; // 처음 dest 길이

	i = 0;
	while (dest[i] != '\0')
		i++;
	begin_of_null = i; //dest + begin_of_null 위치에는 널이 들어있음, 널문자를 제외한 dest의 길이이기도 함

	if (size <= begin_of_null)
		return ft_strlen(src) + size; //비정상적인 사이즈인 경우, src의 길이 + size를 리턴하라는 주문

	i = 0;
	while (i < size - 1 - begin_of_null && src[i] != '\0') //> 후자로 마쳤으면 몽땅 복사한것이고, 전자로 마쳤으면 한도 만큼 복사한 것
	{
		dest[begin_of_null + i] = src[i]; //dest의 널자리부터 src의 모든 원소를 채우기 시작함
		i++;
	}
	dest[begin_of_null + i] = '\0'; //끝자리에 널문자를 박아주므로써 문자열의 경계를 부여함 (널-터미네이트)

	return ft_strlen(src) + begin_of_null; //! dest는 현재 덮어쓰기된 상태이며, 문제가 요구하는 리턴값은 처음 dest의 길이임
}
char *ft_strstr(char *str, char *to_find) //　특정 문자열을 포함하는지 확인하고, 포함한다면 문자열의 시작 위치를 리턴함. 포함하지 않는다면 널 포인터를 리턴함.
{
	int i;

	if (to_find[0] == '\0') //If needle is an empty string, haystack is returned; 이라는 구절이 맨에 있기 때문에 넣어줬음
		return str;
	i = 0;
	while (str[i] != '\0')
	{
		if (str[i] == to_find[0])
			if (ft_strncmp(str + i, to_find, ft_strlen(to_find)) == 0) //to_find 전체를 읽어서, str의 str + i 이후 문자열과 일치하는지 확인
				return (str + i);
		i++;
	}
	return (void*)0;
}

//!  C04
int ft_strlen(char *str);	//> C01  문자열의 문자 수를 세고 리턴하는 함수 (문자열 길이)
void ft_putstr(char *str);	//> C01  표준 출력에 문자열을 표시하는 함수
void ft_putnbr_(int nb);	//> C00  숫자를 문자로 표시하는 함수
int mn_atoi(char *str)		//: 문자열에서 숫자를 발굴하고 진짜 수로 변환해서 리턴하는 함수 (MAN 버전)
{
	int i;
	int zinif;
	int sign;
	int sinif;
	int result;

	result = 0;
	zinif = 0;
	sinif = 0;
	sign = 1;
	i = 0;
	while(str[i])
	{
		if ('0' <= str[i] && str[i] <= '9') // 지금 숫자인가?
		{
			if (zinif == 0) // 최초 진입인가?
				zinif = 1;
			result = 10 * result + str[i] - '0';
		}
		else if (str[i] != '-' && str[i] != '+') // 지금 숫자도 아니고, 부호도 아닌가?
		{
			if (zinif == 1) // 지금 숫자가 아닌데, 숫자에 진입한 적이 있다면, 지금 숫자를 탈출한 상태
			{
				if (sinif == 0)
					return result;
				else 
					return result * sign;
			}
			if (zinif == 0) // 지금 숫자가 아닌데, 부호도 아니고, 숫자에 진입한 적이 없다면
				if (! (9 <= str[i] && str[i] <= 13 || str[i] == ' ') ) // 허용된 공백이 아니라면
					return 0;
		}
		else if (str[i] == '-' || str[i] == '+') // 지금 부호인가?
		{
			if (sinif == 0) // 최초 진입인가?
			{
				sinif = 1;
				if (str[i] == '-')
					sign = -sign;
			}
			else
				return 0;	// 부호가 여러개 등장하므로 잘못된 입력
		}
		i++;
	}
	return result * sign;
}
int ft_atoi(char *str)		//　문자열에서 숫자를 발굴하고, 진짜 수로 변환해서 리턴하는 함수 (FT 버전)
{
	int res;
	int sign;
	int i;

	res = 0;
	sign = 1;
	i = 0;
	while ((9 <= str[i] && str[i] <= 13) || str[i] == ' ')
		i++;
	while (str[i] == '-' || str[i] == '+')
		sign = sign * (44 - str[i++]); // 음의 부호는 45,  양의 부호는 43
	while ('0' <= str[i] && str[i] <= '9')
		res = 10 * res + str[i++] - '0';
	return res * sign;
}
int vaild_base(char *base)	//: 진법-체계가 정상적인 집합인지 확인하고, 정상이라면 몇 진수인지 리턴하는 함수
{
	int i;
	int exist[256];
	unsigned char bf;

	i = 0;
	while (i < 256)
		exist[i++] = 0;

	i = 0;
	while (base[i] != '\0')
	{
		bf = (unsigned char) base[i];
		exist[(int)bf]++;
		i++;
		if (bf == '-' || bf == '+' || exist[(int)bf] >= 2) // 부호거나 중복되거나
			return 0;
		if (bf == ' ' || bf == '\t' || bf == '\n' || bf == '\v' || bf == '\f' || bf == '\r') // 공백문자
			return 0;
	}

	return i;
}
void ft_putnbr_base(int nbr, char *base)	//　정수를 주어진 진법-체계로 변환하여 출력하는 함수
{
//진법-체계는 숫자를 묘사하기 위해서 사용될 수 있는 모든 문자를 들고있음
//"0123456789" 는 10진수를 표현하는 일반적인 진법-체계이다
//"0123456789ABCDEF" 는 16진수를 표현하는 일반적인 진법-체계이다
//"poneyvif" 는 8진수를 표현하는 일반적인 진법-체계이다
//함수는 음수를 처리해야함
//진법-체계의 문자가 하나 뿐이거나, 비었거나, 중복되거나, +- 기호가 존재한다면 아무것도 출력하지 않음

	char conv[33];
	char start;
	int i;
	int nary;
	long long n;

	n = (long long)nbr;
	nary = vaild_base(base);
	if (nary < 2)
		return;
	if (n < 0)
	{
		write(1, "-", 1);
		n = -n;
	}
	i = 33;
	start = i - 1; //시작위치를 마지막 자리로 초기화하면, nb가 0일때 한번도 숫자를 못만나서 0000000000 출력되는 것을 방지
	while (i--)
	{
		conv[i] = base[n % nary];
		n = n / nary;
		if (conv[i] != base[0]) //수가 몇 자린지 알아내기 (앞에서 어느 인덱스부터 숫자가 등장하는지)
			start = i;
	}
	write(1, conv + start, 33 - start); //숫자가 처음 나오는 시점에서부터, 말단까지 출력
}
int custom_number(char ch, char *base)	//: 특정한 문자가 base에서 정의하는 커스텀 숫자에 해당하면 그 연번을 리턴하고, 해당하지 않으면 -1을 리턴하는 함수
{
	int i;

	i = 0;
	while (base[i] != '\0')
	{
		if (ch == base[i])
			return i;
		i++;
	}
	return -1;
}
int ft_atoi_base(char *str, char *base)
{
	int res;
	int sign;
	int nary;
	int i;

	res = 0;
	sign = 1;
	i = 0;
	nary = vaild_base(base);
	if (nary < 2)
		return 0;
	while ((9 <= str[i] && str[i] <= 13) || str[i] == 32)
		i++;
	while (str[i] == '-' || str[i] == '+')
		sign = sign * (44 - str[i++]); // 음의 부호는 45,  양의 부호는 43
	while ( custom_number(str[i], base) != -1 )
		res = nary * res + custom_number(str[i++], base);
	return res * sign;
}

//!  C05
int ft_iterative_factorial(int nb) //! 팩토리얼을 리턴하는 반복문 함수. 0의 계승은 1을 리턴. 음수의 계승은 0을 리턴.
{
	int ret;

	if (nb == 0 || nb == 1)
		return 1;
	if (nb < 0)
		return 0;	//	관대한 수학적 관점에서 음수의 팩토리얼은 정의하지 않는다고하므로, 잘못된 입력이라 판단하였음.
	ret = 1;
	while (nb)
	{
		ret = ret * nb; //nb * (nb-1) * (nb-2) * (nb-3) *  ~~~  * 2 * 1
		nb--;
	}
	return ret;
	//	15! 부터는 오버플로우가 발생하여 잘못된 결과가 출력됨. PDF에서 오버플로우는 신경쓰지 말라고하므로, 이것으로 완료.
}
int ft_recursive_factorial(int nb) //　팩토리얼을 리턴하는 재귀 함수. 0의 계승은 1을 리턴. 음수의 계승은 0을 리턴.
{
	if (nb == 0 || nb == 1)
		return 1;
	if (nb < 0)
		return 0;
	if (nb > 1)
		return nb * ft_recursive_factorial(nb - 1);
	return 0;
//인자가 유효하지 않다면 0을 리턴함, 오버플로를 처리해서는 안 되며, 리턴값은 정의되지 않습니다
}
int ft_iterative_power(int nb, int power) //! 거듭제곱을 리턴하는 반복문 함수. 0보다 작은 제곱은 0을, 0의 0승은 1을 반환하기로 함
{
	int ret;

	if (power < 0)
		return 0;
	if (power == 0)
		return 1;
	ret = 1;
	while (power) //power가 카운트 다운되는 횟수만큼, nb를 누적해서 곱함 (5를 집어넣으면 5,4,3,2,1 일때 통과되어 5번 실행됨)
	{
		ret = ret * nb; //nb * nb * nb *  ~~~  * nb * nb
		power--;
	}
	return ret;
}
int ft_recursive_power(int nb, int power) //　거듭제곱을 리턴하는 재귀 함수. 0보다 작은 제곱은 0을, 0의 0승은 1을 반환하기로 함
{
	if (power == 1)
		return nb;
	if (power == 0)
		return 1;
	if (power > 0)
		return ft_recursive_power(nb, power - 1) * nb;
	return 0;
}
int ft_fibonacci(int index) //　index번째 피보나치수를 리턴하는 재귀 함수
{
//피보나치 수열의 첫번째 항은 0번 인덱스에 있음
//피보나치 수열은 0, 1, 1, 2 으로 시작하기로 함
//index가 0보다 작다면 -1을 리턴함
//		i		0	1	2	3	4	5	6	7	8	9	10	11	12		13		14
//		F(i)	0	1	1	2	3	5	8	13	21	34	55	89	144		233		377

	if (index < 0)
		return -1;
	if (index == 0)
		return 0;
	if (index == 1)
		return 1;

	return ft_fibonacci(index - 2) + ft_fibonacci(index - 1);
}
int ft_sqrt(int nb) //　제곱근이 존재한다면 리턴하는 함수. 허수는 0을 리턴.
{
	long long i;

	if (nb <= 0)
		return 0;
	i = 0;
	while (i * i <= nb)
	{
		if (i * i == nb)
			return i;
		i++;
	}
	return 0;
}
int ft_is_prime(int nb) //! 소수이면 1을 리턴하고, 아니면 0을 리턴. (0과 1은 소수 아님)
{
	long long int i;

	if (nb < 2)
		return 0;
	if (nb == 2)
		return 1;
	i = 2;
	while (i * i <= nb)
	{
		if (nb % i == 0)
			return 0;
		i++;
	}
	return 1;
//N = A*B 에서, A가 점점 커지면  B는 점점 작아진다
//A가 점점 커지면서 N의 약수인지 검사한다
//A가 루트N 근처에 이르었을때, B도 루트N 근처에 이른다
//A가 루트N 을 넘어서면, B는 루트N 보다 작아진다
//루트N 보다 작은 수에 대해서는 A를 통해서 이미 검사하였으므로 중복 검사가 된다
//1부터 루트N 만큼만 i를 증가시켜서 나누어 떨어지는지만 검사하면 모든 약수를 다 검사할 수 있다
//루트 연산을 쓸 수 없으므로 i * i <= nb 으로 대체한다
}
int ft_find_next_prime(int nb) //! 주어진 수 이상의, 가장 가까운 소수를 리턴하는 함수
{
	while (!ft_is_prime(nb))
		nb++;
	return nb;
}
int is_valid_n_queen(int *dec) {
    int i = 0;
    while (i < 10)
    {
        int j = i + 1;
        while (j < 10)
        {
            if (dec[i] == dec[j]
            || (dec[i] - dec[j] == i - j)
            || (dec[i] - dec[j] == j - i)) {
                return 0;
            }
            j++;
        }
        i++;
    }
    return 1;
}
void kth_while(int k, int n, int *dec, int *exist, int *sols)
{
	int able[10];
	int i;

	i = 0;
    dec[k] = 0;
    while (dec[k] <= 9)
    {
        if (exist[dec[k]] == 0)
            exist[dec[k]] = 1;
        else
        {
            dec[k]++;
            continue;
        }
        if (k != n)
            kth_while(k + 1, n, dec, exist, sols);
        if (k == n && is_valid_n_queen(dec))
        {
			for (i=0; i<=n; i++)
            	ft_putnbr(dec[i]);
			write(1, "\n", 1);
			(*sols)++;
        }
		exist[dec[k]] = 0;
        dec[k]++;
    }
}
int ft_ten_queens_puzzle(void) //　10x10 체스판에서, 퀸 10개를 안전하게 배치할 수 있는 모든 경우의 수를 출력 (재귀 사용)
{
	int dec[10];
	int exist[10];
	int i;
	int sols;

	i=0;
	sols=0;
	while (i<10)
	{
		dec[i]=0;
		exist[i]=0;
		i++;
	}
	kth_while(0, 9, dec, exist, &sols);

	return sols;
}

//!  C06 ( 함수명을 main으로 변경 )
int ft_print_program_name(int argc, char **argv) //! 자신의 이름을 출력하는 프로그램
{
	int i;

	(void) argc;
	i = 0;
	while(argv[0][i] != '\0')
	{
		write(1, &argv[0][i], 1);
		i++;
	}
	write(1,"\n",1);
	return 0;
}
int ft_print_params(int argc, char **argv) //! 터미널에서 입력받은 인자를 출력하는 프로그램
{
	int i;
	int argn;

	argn = 1;
	while(argn <= argc - 1)
	{
		i = 0;
		while(argv[argn][i] != '\0')
		{
			write(1, &argv[argn][i], 1);
			i++;
		}
		write(1,"\n",1);
		argn++;
	}
	return 0;
}
int ft_rev_params(int argc, char **argv) //! 주어진 인자를 역순으로 출력하는 프로그램
{
	int i;
	int argn;

	argn = argc - 1;
	while(argn >= 1)
	{
		i = 0;
		while(argv[argn][i] != '\0')
		{
			write(1, &argv[argn][i], 1);
			i++;
		}
		write(1,"\n",1);
		argn--;
	}
	return 0;
}
int ft_sort_params(int argc, char **argv) //! 주어진 인자를 아스키 순서로 출력하는 프로그램
{
//		(중의적) ⭕️ 인자들 사이에 아스키 우선순위가 높은 것부터 출력?
//		(중의적) ❌ 인자로 받은 문자열 하나하나를 아스키순으로 정렬해서 출력?
//		argv[0]를 제외한 모든 인수를, 한줄에 하나씩 출력
//		인자 하나하나 마다 개행 문자가 따라 붙을 것
	int argn;
	int sorted;
	char *tmp;

	argv[0] = "";
	sorted = 0;
	while (sorted == 0)
	{
		sorted = 1;
		argn = 1;
		while (argn <= argc - 1)
		{
			if (ft_strcmp(argv[argn-1], argv[argn]) > 0)
			{
				tmp = argv[argn];
				argv[argn] = argv[argn-1];
				argv[argn-1] = tmp;
				sorted = 0;
			}
			argn++;
		}
	}
	ft_print_params(argc, argv);
	return 0;
}

//!  C07
char *ft_strdup(char *src) //　strdup의 동작을 재현하는 함수
{
	int i;
	char *dest;

	i = 0;
	while (src[i])
		i++;
	dest = (char *) malloc(sizeof (char) * i + 1);
	i = 0;
	while (src[i])
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return dest;
}
int *ft_range(int min, int max) //　min이상 max미만의 모든 정수를 포함하는 배열을 리턴하는 함수
{
	int size;
	int *tab;
	int i;

	if (max <= min)
		return (void*)0;
	size = max - min;
	tab = (int *) malloc(sizeof (int) * (max - min));
	i = 0;
	while (i < max - min)
	{
		tab[i] = min + i;
		i++;
	}
	return tab;
}
int ft_ultimate_range(int **range, int min, int max) //　min이상 max미만의 모든 정수를 포함하는 배열 ...... 하는 함수
{
//	Create a function ft_ultimate_range which allocates and assigns an array of ints.
	if (max <= min) //　(max <= min) 이라면 범위는 NULL을 가리키고, 리턴값은 0이어야함.
	{
		range = (void*)0;
		return 0;
	}
	return max - min; //　The size of range should be returned (or -1 on error).
}
char *ft_strjoin(int size, char **strs, char *sep) //　문자열들을 sep를 기준으로 연결하여 리턴하는 함수
{
//	size는 strs의 "문자열" 갯수
//	size가 0이라면, free() 할 수 있는 빈 문자열을 리턴
	size = 0;
	**strs = 0;
	*sep = 0;
	return NULL;
}
char *ft_convert_base(char *nbr, char *base_from, char *base_to) //　특정한 진법 표현으로 주어진 숫자를 또다른 진법 표현으로 변환하는 함수
{
	*nbr = 0;
	*base_from = 0;
	*base_to = 0;
	return 0;
//nbr, base_from, base_to 는 수정할 수 없을 수도 있음
//nbr은 ft_atoi_base 에서 사용되는 진법-체계의 문자와 같은 방식임
//+ - 부호와 공백 문자를 유의하시오
//& The number represented by nbr must fit inside an int.
//진법이 잘못되었다면 NULL을 리턴
//반환된 숫자는 (진법화된 숫자 문자열) 공백이나 +가 없으며, 필요한 경우 -를 하나만 붙일 수 있음
}
char *extract(char *start, char *end)
{
	char *dest;

	dest = (char*) malloc (sizeof (char) * (end - start + 1));
	int i;
	i=0;

	// printf("\n\n___%s\n", start);
	// printf("___%s\n\n", end);
	dest[0] = '7';

	// while(dest[i])
	// printf("%c", dest[i]);
	// while (start != end)
		// start++;
	// {
		// *dest = *start;
		// start++;
	// }
	// *dest = '\0';
	return dest;
}

int is_sep(char ch, char *charset)
{
	while (*charset)
	{
		if (ch == *charset || ch == '\0')
			return 1;
		charset++;
	}
	return 0;
}

char **ft_split(char *str, char *charset) //　구분자를 기준으로 문자열을 분할하고, 분할된 문자열을 인덱싱할 수 있는 모음을 리턴하는 함수
{
	char *rewind;
    char *start;
    char *end;
    char **frame;
	int words;


	rewind = str;
	words=0;
	while(*str)
	{
		printf("%c", *str);
		end = (char*)0;
		while(is_sep(*str, charset))
			start = str++;
		while(!is_sep(*str, charset))
			end = str++;
		words++;
	}

	str = rewind;
	frame = (char **) malloc(sizeof(char *) * (words + 1));
	frame[words] = 0;

	words = 0;
	char *tmp;

	while(*str)
	{
		printf("%c", *str);
		end = (char*)0;
		while(is_sep(*str, charset))
			start = str++;
		while(!is_sep(*str, charset))
			end = str++;
		frame[words] = extract(start, end);
		words++;
	}

    return frame;
}

//!  RUSH 1주차
void rush(int x, int y)
{
	int i;
	int put;
	i = 0;

	while (i++ < x * y)
	{
		put = 4;
		put += ((i - 1) % x > 0) + ((i - 1) % x == x - 1);
		put += -3 * ((i - 1) / x == 0) + 3 * ((i - 1) / x == y - 1);
		put += -(x == 1) - 3 * (y == 1);
		write(1, &"07894 6123"[put], 1); //numpad
		write(1, &"0o-o| |o-o"[put], 1); //RUSH 00			oooo
		write(1, &"0/*\\* *\\*/"[put], 1); //RUSH 01		hamburger
		write(1, &"0ABAB BCBC"[put], 1); //RUSH 02		AACC
		write(1, &"0ABCB BABC"[put], 1); //RUSH 03		ACAC
		write(1, &"0ABCB BCBA"[put], 1); //RUSH 04		ACCA
		if (i % x == 0)
			write(1, "\n", 1);
	}
}

//!	 뻘짓
///: 자바스크립트
///		try { if(tick >= 500 && location.href.includes("profile.intra.42.fr") && !document.title.includes('!!')) location.reload(); document.title = document.title; tick++} catch {tick=1} try {document.title=document.querySelector("div.vbox.flex-auto.console-view-pinpane").shadowRoot.querySelector(".console-pin-preview").innerText*1 > 0 ? ['확인!!','평가!!'][tick % 2] : "ㅣ｜"[tick % 2];} catch {[...document.getElementsByClassName('overflowable-item')].filter(x=>x.innerText.includes('eval')).length}
///		new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(1e3).join(111)).play()


///		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